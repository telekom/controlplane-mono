// Package kong provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package kong

import (
	"bytes"
	"context"
	"encoding/json"
	"encoding/xml"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for VaultConfigPrefix.
const (
	VaultsConfigNegTtl       VaultConfigPrefix = "vaults.config.neg_ttl"
	VaultsConfigResurrectTtl VaultConfigPrefix = "vaults.config.resurrect_ttl"
	VaultsConfigTtl          VaultConfigPrefix = "vaults.config.ttl"
)

// Defines values for CreatePluginForConsumerRequestProtocols.
const (
	CreatePluginForConsumerRequestProtocolsGrpc  CreatePluginForConsumerRequestProtocols = "grpc"
	CreatePluginForConsumerRequestProtocolsGrpcs CreatePluginForConsumerRequestProtocols = "grpcs"
	CreatePluginForConsumerRequestProtocolsHttp  CreatePluginForConsumerRequestProtocols = "http"
	CreatePluginForConsumerRequestProtocolsTcp   CreatePluginForConsumerRequestProtocols = "tcp"
	CreatePluginForConsumerRequestProtocolsTls   CreatePluginForConsumerRequestProtocols = "tls"
)

// Defines values for CreateRouteRequestHttpsRedirectStatusCode.
const (
	CreateRouteRequestHttpsRedirectStatusCodeN301 CreateRouteRequestHttpsRedirectStatusCode = 301
	CreateRouteRequestHttpsRedirectStatusCodeN302 CreateRouteRequestHttpsRedirectStatusCode = 302
	CreateRouteRequestHttpsRedirectStatusCodeN307 CreateRouteRequestHttpsRedirectStatusCode = 307
	CreateRouteRequestHttpsRedirectStatusCodeN308 CreateRouteRequestHttpsRedirectStatusCode = 308
	CreateRouteRequestHttpsRedirectStatusCodeN426 CreateRouteRequestHttpsRedirectStatusCode = 426
)

// Defines values for CreateRouteRequestPathHandling.
const (
	V0 CreateRouteRequestPathHandling = "v0"
	V1 CreateRouteRequestPathHandling = "v1"
)

// Defines values for CreateServiceRequestProtocol.
const (
	CreateServiceRequestProtocolGrpc           CreateServiceRequestProtocol = "grpc"
	CreateServiceRequestProtocolGrpcs          CreateServiceRequestProtocol = "grpcs"
	CreateServiceRequestProtocolHttp           CreateServiceRequestProtocol = "http"
	CreateServiceRequestProtocolHttps          CreateServiceRequestProtocol = "https"
	CreateServiceRequestProtocolTcp            CreateServiceRequestProtocol = "tcp"
	CreateServiceRequestProtocolTls            CreateServiceRequestProtocol = "tls "
	CreateServiceRequestProtocolTlsPassthrough CreateServiceRequestProtocol = "tls_passthrough"
	CreateServiceRequestProtocolUdp            CreateServiceRequestProtocol = "udp"
	CreateServiceRequestProtocolWs             CreateServiceRequestProtocol = "ws"
	CreateServiceRequestProtocolWss            CreateServiceRequestProtocol = "wss"
)

// Defines values for CreateUpstreamRequestAlgorithm.
const (
	ConsistentHashing CreateUpstreamRequestAlgorithm = "consistent-hashing"
	Latency           CreateUpstreamRequestAlgorithm = "latency"
	LeastConnections  CreateUpstreamRequestAlgorithm = "least-connections"
	RoundRobin        CreateUpstreamRequestAlgorithm = "round-robin"
)

// Defines values for CreateUpstreamRequestHashFallback.
const (
	CreateUpstreamRequestHashFallbackConsumer   CreateUpstreamRequestHashFallback = "consumer"
	CreateUpstreamRequestHashFallbackCookie     CreateUpstreamRequestHashFallback = "cookie"
	CreateUpstreamRequestHashFallbackIp         CreateUpstreamRequestHashFallback = "ip"
	CreateUpstreamRequestHashFallbackNone       CreateUpstreamRequestHashFallback = "none"
	CreateUpstreamRequestHashFallbackPath       CreateUpstreamRequestHashFallback = "path"
	CreateUpstreamRequestHashFallbackQueryArg   CreateUpstreamRequestHashFallback = "query_arg"
	CreateUpstreamRequestHashFallbackUriCapture CreateUpstreamRequestHashFallback = "uri_capture"
)

// Defines values for CreateUpstreamRequestHashOn.
const (
	CreateUpstreamRequestHashOnConsumer   CreateUpstreamRequestHashOn = "consumer"
	CreateUpstreamRequestHashOnCookie     CreateUpstreamRequestHashOn = "cookie"
	CreateUpstreamRequestHashOnIp         CreateUpstreamRequestHashOn = "ip"
	CreateUpstreamRequestHashOnNone       CreateUpstreamRequestHashOn = "none"
	CreateUpstreamRequestHashOnPath       CreateUpstreamRequestHashOn = "path"
	CreateUpstreamRequestHashOnQueryArg   CreateUpstreamRequestHashOn = "query_arg"
	CreateUpstreamRequestHashOnUriCapture CreateUpstreamRequestHashOn = "uri_capture"
)

// Defines values for CreateUpstreamRequestHealthchecksActiveType.
const (
	CreateUpstreamRequestHealthchecksActiveTypeGrpc  CreateUpstreamRequestHealthchecksActiveType = "grpc"
	CreateUpstreamRequestHealthchecksActiveTypeGrpcs CreateUpstreamRequestHealthchecksActiveType = "grpcs"
	CreateUpstreamRequestHealthchecksActiveTypeHttp  CreateUpstreamRequestHealthchecksActiveType = "http"
	CreateUpstreamRequestHealthchecksActiveTypeHttps CreateUpstreamRequestHealthchecksActiveType = "https"
	CreateUpstreamRequestHealthchecksActiveTypeTcp   CreateUpstreamRequestHealthchecksActiveType = "tcp"
)

// Defines values for CreateUpstreamRequestHealthchecksPassiveType.
const (
	CreateUpstreamRequestHealthchecksPassiveTypeGrpc  CreateUpstreamRequestHealthchecksPassiveType = "grpc"
	CreateUpstreamRequestHealthchecksPassiveTypeGrpcs CreateUpstreamRequestHealthchecksPassiveType = "grpcs"
	CreateUpstreamRequestHealthchecksPassiveTypeHttp  CreateUpstreamRequestHealthchecksPassiveType = "http"
	CreateUpstreamRequestHealthchecksPassiveTypeHttps CreateUpstreamRequestHealthchecksPassiveType = "https"
	CreateUpstreamRequestHealthchecksPassiveTypeTcp   CreateUpstreamRequestHealthchecksPassiveType = "tcp"
)

// Defines values for CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatuses.
const (
	CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatusesN200 CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatuses = 200
	CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatusesN201 CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatuses = 201
	CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatusesN202 CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatuses = 202
	CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatusesN203 CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatuses = 203
	CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatusesN204 CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatuses = 204
	CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatusesN205 CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatuses = 205
	CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatusesN206 CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatuses = 206
	CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatusesN207 CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatuses = 207
	CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatusesN208 CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatuses = 208
	CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatusesN226 CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatuses = 226
	CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatusesN300 CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatuses = 300
	CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatusesN301 CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatuses = 301
	CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatusesN302 CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatuses = 302
	CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatusesN303 CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatuses = 303
	CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatusesN304 CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatuses = 304
	CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatusesN305 CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatuses = 305
	CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatusesN306 CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatuses = 306
	CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatusesN307 CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatuses = 307
	CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatusesN308 CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatuses = 308
)

// Defines values for CreateUpstreamRequestHealthchecksPassiveUnhealthyHttpStatuses.
const (
	N429 CreateUpstreamRequestHealthchecksPassiveUnhealthyHttpStatuses = 429
	N500 CreateUpstreamRequestHealthchecksPassiveUnhealthyHttpStatuses = 500
	N503 CreateUpstreamRequestHealthchecksPassiveUnhealthyHttpStatuses = 503
)

// Defines values for ListPluginsForConsumer200ResponseProtocols.
const (
	Grpc  ListPluginsForConsumer200ResponseProtocols = "grpc"
	Grpcs ListPluginsForConsumer200ResponseProtocols = "grpcs"
	Http  ListPluginsForConsumer200ResponseProtocols = "http"
	Tcp   ListPluginsForConsumer200ResponseProtocols = "tcp"
	Tls   ListPluginsForConsumer200ResponseProtocols = "tls"
)

// Defines values for GetSniWithCertificateParamsCertificateNameOrId.
const (
	GetSniWithCertificateParamsCertificateNameOrIdA3ad71a866854b03A101980a953544f6 GetSniWithCertificateParamsCertificateNameOrId = "a3ad71a8-6685-4b03-a101-980a953544f6"
	GetSniWithCertificateParamsCertificateNameOrIdName                             GetSniWithCertificateParamsCertificateNameOrId = "name"
)

// Defines values for CreateSniForCertificateParamsCertificateNameOrId.
const (
	CreateSniForCertificateParamsCertificateNameOrIdA3ad71a866854b03A101980a953544f6 CreateSniForCertificateParamsCertificateNameOrId = "a3ad71a8-6685-4b03-a101-980a953544f6"
	CreateSniForCertificateParamsCertificateNameOrIdName                             CreateSniForCertificateParamsCertificateNameOrId = "name"
)

// Defines values for PutDebugClusterControlPlanesNodesLogLevelLogLevelParamsLogLevel.
const (
	PutDebugClusterControlPlanesNodesLogLevelLogLevelParamsLogLevelCrit   PutDebugClusterControlPlanesNodesLogLevelLogLevelParamsLogLevel = "crit"
	PutDebugClusterControlPlanesNodesLogLevelLogLevelParamsLogLevelError  PutDebugClusterControlPlanesNodesLogLevelLogLevelParamsLogLevel = "error"
	PutDebugClusterControlPlanesNodesLogLevelLogLevelParamsLogLevelInfo   PutDebugClusterControlPlanesNodesLogLevelLogLevelParamsLogLevel = "info"
	PutDebugClusterControlPlanesNodesLogLevelLogLevelParamsLogLevelNotice PutDebugClusterControlPlanesNodesLogLevelLogLevelParamsLogLevel = "notice"
	PutDebugClusterControlPlanesNodesLogLevelLogLevelParamsLogLevelWarn   PutDebugClusterControlPlanesNodesLogLevelLogLevelParamsLogLevel = "warn"
)

// Defines values for PutDebugClusterLogLevelLogLevelParamsLogLevel.
const (
	PutDebugClusterLogLevelLogLevelParamsLogLevelCrit   PutDebugClusterLogLevelLogLevelParamsLogLevel = "crit"
	PutDebugClusterLogLevelLogLevelParamsLogLevelError  PutDebugClusterLogLevelLogLevelParamsLogLevel = "error"
	PutDebugClusterLogLevelLogLevelParamsLogLevelInfo   PutDebugClusterLogLevelLogLevelParamsLogLevel = "info"
	PutDebugClusterLogLevelLogLevelParamsLogLevelNotice PutDebugClusterLogLevelLogLevelParamsLogLevel = "notice"
	PutDebugClusterLogLevelLogLevelParamsLogLevelWarn   PutDebugClusterLogLevelLogLevelParamsLogLevel = "warn"
)

// Defines values for PutDebugNodeLogLevelLogLevelParamsLogLevel.
const (
	Crit   PutDebugNodeLogLevelLogLevelParamsLogLevel = "crit"
	Error  PutDebugNodeLogLevelLogLevelParamsLogLevel = "error"
	Info   PutDebugNodeLogLevelLogLevelParamsLogLevel = "info"
	Notice PutDebugNodeLogLevelLogLevelParamsLogLevel = "notice"
	Warn   PutDebugNodeLogLevelLogLevelParamsLogLevel = "warn"
)

// CACertificate A CA certificate object represents a trusted CA. These objects are used by Kong to verify the validity of a client or server certificate. CA Certificates can be both tagged and filtered by tags.
type CACertificate struct {
	// Cert PEM-encoded public certificate of the CA.
	Cert *string `json:"cert,omitempty"`

	// CertDigest SHA256 hex digest of the public certificate.
	CertDigest *string `json:"cert_digest,omitempty"`

	// CreatedAt Unix epoch when the resource was created.
	CreatedAt *int                `json:"created_at,omitempty"`
	Id        *openapi_types.UUID `json:"id,omitempty"`

	// Tags An optional set of strings associated with the Certificate for grouping and filtering.
	Tags *[]string `json:"tags,omitempty"`
}

// Certificate A certificate object represents a public certificate. These fields are _referenceable_, and can be stored as [secrets](http://docs.konqhq.com/gateway/latest/plan-and-deploy/security/secrets-management/getting-started) in a vault. References must follow a [specific format](/gateway/latest/plan-and-deploy/security/secrets-management/reference-format).
type Certificate struct {
	// Cert PEM-encoded public certificate chain of the SSL key This field is referenceable and can be stored in a vault. References must follow a [specific format](/gateway/latest/plan-and-deploy/security/secrets-management/reference-format).
	Cert *string `json:"cert,omitempty"`

	// CertAlt PEM-encoded public certificate chain of the alternate SSL key pair. This should only be set if you have both RSA and ECDSA types of certificate available and would like Kong to prefer serving using ECDSA certs.
	CertAlt *string `json:"cert_alt,omitempty"`

	// CreatedAt Unix epoch when the resource was created.
	CreatedAt *int `json:"created_at,omitempty"`

	// Id The UUID representation of the certificate object.
	Id *openapi_types.UUID `json:"id,omitempty"`

	// Key PEM-encoded private key of the SSL key pair. This field is _referenceable_, which means it can be securely stored as a [secret](/gateway/latest/plan-and-deploy/security/secrets-management/getting-started) in a vault. References must follow a [specific format](/gateway/latest/plan-and-deploy/security/secrets-management/reference-format).
	Key *string `json:"key,omitempty"`

	// KeyAlt PEM-encoded private key of the alternate SSL key pair. This should only be set if you have both RSA and ECDSA types of certificate available and would like Kong to prefer serving using ECDSA certs when client advertises support for it. This field is _referenceable_, which means it can be securely stored as a [secret](/gateway/latest/plan-and-deploy/security/secrets-management/getting-started) in a vault. References must follow a [specific format](/gateway/latest/plan-and-deploy/security/secrets-management/reference-format).
	KeyAlt *string `json:"key_alt,omitempty"`

	// Snis A list of SNIs associated with the certificate.
	Snis *[]string `json:"snis,omitempty"`

	// Tags An optional set of strings associated with the Certificate for grouping and filtering.
	Tags *[]string `json:"tags,omitempty"`
}

// Consumer The Consumer object represents a consumer - or a user - of a service. You can either rely on Kong as the primary datastore, or you can map the consumer list with your database to keep consistency between Kong and your existing primary datastore.
type Consumer struct {
	// CreatedAt Unix epoch when the resource was created.
	CreatedAt *int `json:"created_at,omitempty"`

	// CustomId Field for storing an existing unique ID for the Consumer - useful for mapping Kong with users in your existing database. You must send either this field or `username` with the request.
	CustomId *string `json:"custom_id,omitempty"`
	Id       *string `json:"id,omitempty"`

	// Tags An optional set of strings associated with the Consumer for grouping and filtering.
	Tags *[]string `json:"tags,omitempty"`

	// Username The unique username of the Consumer. You must send either this field or `custom_id` with the request.
	Username *string `json:"username,omitempty"`
}

// ConsumerGroup The ConsumerGroup object represents a consumerGroup.
type ConsumerGroup struct {
	// Consumer The Consumer object represents a consumer - or a user - of a service. You can either rely on Kong as the primary datastore, or you can map the consumer list with your database to keep consistency between Kong and your existing primary datastore.
	Consumer  *Consumer `json:"consumer,omitempty"`
	CreatedAt *int      `json:"created_at,omitempty"`
	Group     *string   `json:"group,omitempty"`
	Id        *string   `json:"id,omitempty"`

	// Tags List of tag values
	Tags *Tags `json:"tags,omitempty"`
}

// ConsumerGroupRequest Create / Update Request Entity
type ConsumerGroupRequest struct {
	Group *string `json:"group,omitempty"`
}

// ConsumerGroupResponse Paginated list of ConsumerGroup entities
type ConsumerGroupResponse struct {
	Data   *[]ConsumerGroup `json:"data,omitempty"`
	Next   *string          `json:"next,omitempty"`
	Offset *string          `json:"offset,omitempty"`
}

// FilterChains A filter chain is the database entity representing one or more WebAssembly filters executed for each request to a particular service or route, each one with its configuration.
type FilterChains struct {
	CreatedAt *int `json:"created_at,omitempty"`

	// Enabled Whether the filter chain is applied. Default: true.
	Enabled *bool `json:"enabled,omitempty"`

	// Filters An array of filter definitions. Each filter is an object containing a mandatory name, an optional config, and a boolean enabled setting.
	Filters *[]FilterChainsFiltersInner `json:"filters,omitempty"`

	// Id The unique identifier or the name attribute of the route that should be associated to the newly created filter chain.
	Id *openapi_types.UUID `json:"id,omitempty"`

	// Name The name of the filter chain.
	Name *string `json:"name,omitempty"`

	// Route The route to which this chain is applied. A filter chain must be applied to either a single route or a single service. Default `null`. In form-encoded format, the notation is `route.id=<route id>` or `route.name=<route name>`. In JSON format, use `"route":{"id":"<route id>"}` or `"route":{"name":"<route name>"}`.
	Route *interface{} `json:"route"`

	// Service The service to which this chain is applied. A filter chain must be applied to either a single route or a single service. Default `null`. In form-encoded format, the notation is `service.id=<service id>` or `service.name=<service name>`. In JSON format, use `"service":{"id":"<service id>"}` or `"service":{"name":"<service name>"}`.
	Service   *string   `json:"service,omitempty"`
	Tags      *[]string `json:"tags,omitempty"`
	UpdatedAt *int      `json:"updated_at,omitempty"`
}

// FilterChainsFiltersInner defines model for Filter_chains_filters_inner.
type FilterChainsFiltersInner struct {
	// Config configuration filter headers
	Config *string `json:"config,omitempty"`

	// Enabled Enable the filter
	Enabled *bool `json:"enabled,omitempty"`

	// Name The name of the filter
	Name *string `json:"name,omitempty"`
}

// Key A Key object holds a representation of asymmetric keys in various formats. When Kong or a Kong plugin requires a specific public or private key to perform certain operations, it can use this entity.
type Key struct {
	// CreatedAt Unix epoch when the resource was created.
	CreatedAt *int `json:"created_at,omitempty"`

	// Id The unique identifier or the prefix of the Vault to delete.
	Id *string `json:"id,omitempty"`

	// Jwk A JSON Web Key represented as a string.
	Jwk *string `json:"jwk,omitempty"`

	// Kid A unique identifier for a key.
	Kid *string `json:"kid,omitempty"`

	// Name The name to associate with the given keys.
	Name *string `json:"name,omitempty"`

	// Pem A keypair in PEM format.
	Pem *KeyPem `json:"pem,omitempty"`

	// Set The id (an UUID) of the key-set with which to associate the key.
	Set *KeySet `json:"set,omitempty"`

	// Tags An optional set of strings associated with the Key for grouping and filtering.
	Tags *[]string `json:"tags,omitempty"`

	// UpdatedAt Unix epoch when the resource was last updated.
	UpdatedAt *int `json:"updated_at,omitempty"`
}

// KeyPem A keypair in PEM format.
type KeyPem struct {
	PrivateKey *string `json:"private_key,omitempty"`
	PublicKey  *string `json:"public_key,omitempty"`
}

// KeySet The id (an UUID) of the key-set with which to associate the key.
type KeySet struct {
	Id *string `json:"id,omitempty"`
}

// Plugin A Plugin entity represents a plugin configuration that will be executed during the HTTP request/response lifecycle.
type Plugin struct {
	// Config The configuration properties for the Plugin which can be found on the plugins documentation page in the [Kong Hub](https://docs.konghq.com/hub/).
	Config *map[string]interface{} `json:"config,omitempty"`

	// Consumer If set, the plugin will activate only for requests where the specified has been authenticated. (Note that some plugins can not be restricted to consumers this way.). Leave unset for the plugin to activate regardless of the authenticated Consumer.
	Consumer *PluginConsumer `json:"consumer,omitempty"`

	// CreatedAt Unix epoch when the resource was created.
	CreatedAt *int `json:"created_at,omitempty"`

	// Enabled Whether the plugin is applied.
	Enabled      *bool   `json:"enabled,omitempty"`
	Id           *string `json:"id,omitempty"`
	InstanceName *string `json:"instance_name,omitempty"`

	// Name The name of the Plugin thats going to be added. Currently, the Plugin must be installed in every Kong instance separately.
	Name *string `json:"name,omitempty"`

	// Protocols A list of the request protocols that will trigger this plugin. The default value, as well as the possible values allowed on this field, may change depending on the plugin type. For example, plugins that only work in stream mode will only support `"tcp"` and `"tls"`.
	Protocols *[]string `json:"protocols,omitempty"`

	// Route If set, the plugin will only activate when receiving requests via the specified route. Leave unset for the plugin to activate regardless of the route being used.
	Route *PluginRoute `json:"route,omitempty"`

	// Service If set, the plugin will only activate when receiving requests via one of the routes belonging to the specified service. Leave unset for the plugin to activate regardless of the service being matched.
	Service *PluginService `json:"service,omitempty"`

	// Tags An optional set of strings associated with the Plugin for grouping and filtering.
	Tags *[]string `json:"tags,omitempty"`

	// UpdatedAt Unix epoch when the resource was last updated.
	UpdatedAt *int `json:"updated_at,omitempty"`
}

// PluginConsumer If set, the plugin will activate only for requests where the specified has been authenticated. (Note that some plugins can not be restricted to consumers this way.). Leave unset for the plugin to activate regardless of the authenticated Consumer.
type PluginConsumer struct {
	Id *string `json:"id,omitempty"`
}

// PluginRoute If set, the plugin will only activate when receiving requests via the specified route. Leave unset for the plugin to activate regardless of the route being used.
type PluginRoute struct {
	Id *string `json:"id,omitempty"`
}

// PluginService If set, the plugin will only activate when receiving requests via one of the routes belonging to the specified service. Leave unset for the plugin to activate regardless of the service being matched.
type PluginService struct {
	Id *string `json:"id,omitempty"`
}

// Route Route entities define rules to match client requests. Every request matching a given route will be proxied to its associated service.
type Route struct {
	// CreatedAt Unix epoch when the resource was created.
	CreatedAt *int `json:"created_at,omitempty"`

	// Destinations A list of IP destinations of incoming connections that match this route when using stream routing. Each entry is an object with fields "ip" (optionally in CIDR range notation) and/or "port".
	Destinations *[]map[string]interface{} `json:"destinations,omitempty"`

	// Expression The route expression used for advanced routing scenarios. This field is used to evaluate route matches based on complex criteria beyond the standard routing fields.
	Expression *string `json:"expression,omitempty"`

	// Headers One or more lists of values indexed by header name that will cause this route to match if present in the request. The `Host` header cannot be used with this hosts should be specified using the `hosts` attribute. When `headers` contains only one value and that value starts with the special prefix `~*`, the value is interpreted as a regular expression.
	Headers *map[string]interface{} `json:"headers,omitempty"`

	// Hosts A list of domain names that match this route. Note that the hosts value is case sensitive.
	Hosts *[]string `json:"hosts,omitempty"`

	// HttpsRedirectStatusCode The status code Kong responds with when all properties of a route match except the protocol i.e. if the protocol of the request is `HTTP` instead of `HTTPS`. `Location` header is injected by Kong if the field is set to 301, 302, 307 or 308. This config applies only if the route is configured to only accept the `https` protocol.
	HttpsRedirectStatusCode *int    `json:"https_redirect_status_code,omitempty"`
	Id                      *string `json:"id,omitempty"`

	// Methods A list of HTTP methods that match this route.
	Methods *[]string `json:"methods,omitempty"`

	// Name The name of the route. Route names must be unique, and they are case sensitive. For example, there can be two different routes named "test" and "Test".
	Name *string `json:"name,omitempty"`

	// PathHandling Controls how the service path, route path and requested path are combined when sending a request to the upstream. See above for a detailed description of each behavior.
	PathHandling *string `json:"path_handling,omitempty"`

	// Paths A list of paths that match this route.
	Paths *[]string `json:"paths,omitempty"`

	// PreserveHost When matching a route via one of the `hosts` domain names, use the request `Host` header in the upstream request headers. If set to `false`, the upstream `Host` header will be that of the services `host`.
	PreserveHost *bool `json:"preserve_host,omitempty"`

	// Priority A number used to specify the matching order for expression routes. The higher the `priority`, the sooner a route will be evaluated. This field is ignored unless `expression` field is set. The value must be between 0 and 2^46 - 1.
	Priority *int `json:"priority,omitempty"`

	// Protocols An array of the protocols this route should allow. See the [route Object](#route-object) section for a list of accepted protocols. When set to only `"https"`, HTTP requests are answered with an upgrade error. When set to only `"http"`, HTTPS requests are answered with an error.
	Protocols *[]string `json:"protocols,omitempty"`

	// RegexPriority A number used to choose which route resolves a given request when several routes match it using regexes simultaneously. When two routes match the path and have the same `regex_priority`, the older one (lowest `created_at`) is used. Note that the priority for non-regex routes is different (longer non-regex routes are matched before shorter ones).
	RegexPriority *int `json:"regex_priority,omitempty"`

	// RequestBuffering Whether to enable request body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that receive data with chunked transfer encoding.
	RequestBuffering *bool `json:"request_buffering,omitempty"`

	// ResponseBuffering Whether to enable response body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that send data with chunked transfer encoding.
	ResponseBuffering *bool `json:"response_buffering,omitempty"`

	// Service The service this route is associated to. This is where the route proxies traffic to.
	Service *RouteService `json:"service,omitempty"`

	// Snis A list of SNIs that match this route when using stream routing.
	Snis *[]string `json:"snis,omitempty"`

	// Sources A list of IP sources of incoming connections that match this route when using stream routing. Each entry is an object with fields "ip" (optionally in CIDR range notation) and/or "port".
	Sources *[]map[string]interface{} `json:"sources,omitempty"`

	// StripPath When matching a route via one of the `paths`, strip the matching prefix from the upstream request URL.
	StripPath *bool `json:"strip_path,omitempty"`

	// Tags An optional set of strings associated with the route for grouping and filtering.
	Tags *[]string `json:"tags,omitempty"`

	// UpdatedAt Unix epoch when the resource was last updated.
	UpdatedAt *int `json:"updated_at,omitempty"`
}

// RouteService The service this route is associated to. This is where the route proxies traffic to.
type RouteService struct {
	Id *string `json:"id,omitempty"`
}

// SNI An SNI object represents a many-to-one mapping of hostnames to a certificate. That is, a certificate object can have many hostnames associated with it; when Kong receives an SSL request, it uses the SNI field in the Client Hello to lookup the certificate object based on the SNI associated with the certificate.
type SNI struct {
	// Certificate The id (a UUID) of the certificate with which to associate the SNI hostname. The Certificate must have a valid private key associated with it to be used by the SNI object.
	Certificate *SNICertificate `json:"certificate,omitempty"`

	// CreatedAt Unix epoch when the resource was created.
	CreatedAt *int    `json:"created_at,omitempty"`
	Id        *string `json:"id,omitempty"`

	// Name The SNI name to associate with the given certificate.
	Name *string `json:"name,omitempty"`

	// Tags An optional set of strings associated with the SNIs for grouping and filtering.
	Tags *[]string `json:"tags,omitempty"`
}

// SNICertificate The id (a UUID) of the certificate with which to associate the SNI hostname. The Certificate must have a valid private key associated with it to be used by the SNI object.
type SNICertificate struct {
	Id *string `json:"id,omitempty"`
}

// Service service entities are abstractions of upstream services. The main attribute of a service is its URL which can be set as a single string or by specifying the `protocol`, `host`, `port` and `path` individually.
type Service struct {
	// CaCertificates Array of `CA Certificate` object UUIDs that are used to build the trust store while verifying upstream server's TLS certificate. If set to `null` when Nginx default is respected. If default CA list in Nginx are not specified and TLS verification is enabled, then handshake with upstream server will always fail (because no CA are trusted).
	CaCertificates *[]string `json:"ca_certificates,omitempty"`

	// ClientCertificate Certificate to be used as client certificate while TLS handshaking to the upstream server.
	ClientCertificate *ServiceClientCertificate `json:"client_certificate,omitempty"`

	// ConnectTimeout The timeout in milliseconds for establishing a connection to the upstream server.
	ConnectTimeout *int `json:"connect_timeout,omitempty"`

	// CreatedAt Unix epoch when the resource was created.
	CreatedAt *int `json:"created_at,omitempty"`

	// Enabled Whether the service is active. If set to `false`, the proxy behavior will be as if any routes attached to it do not exist (404).
	Enabled *bool `json:"enabled,omitempty"`

	// Host The host of the upstream server. Note that the host value is case sensitive.
	Host *string `json:"host,omitempty"`
	Id   *string `json:"id,omitempty"`

	// Name The service name.
	Name *string `json:"name,omitempty"`

	// Path The path to be used in requests to the upstream server.
	Path *string `json:"path,omitempty"`

	// Port The upstream server port.
	Port *int `json:"port,omitempty"`

	// Protocol The protocol used to communicate with the upstream.
	Protocol *string `json:"protocol,omitempty"`

	// ReadTimeout The timeout in milliseconds between two successive read operations for transmitting a request to the upstream server.
	ReadTimeout *int `json:"read_timeout,omitempty"`

	// Retries The number of retries to execute upon failure to proxy.
	Retries *int `json:"retries,omitempty"`

	// Tags An optional set of strings associated with the service for grouping and filtering.
	Tags *[]string `json:"tags,omitempty"`

	// TlsVerify Whether to enable verification of upstream server TLS certificate. If set to `null`, then the Nginx default is respected.
	TlsVerify *bool `json:"tls_verify,omitempty"`

	// TlsVerifyDepth Maximum depth of chain while verifying Upstream server's TLS certificate. If set to `null`, then the Nginx default is respected.'
	TlsVerifyDepth *int `json:"tls_verify_depth,omitempty"`

	// UpdatedAt Unix epoch when the resource was last updated.
	UpdatedAt *int `json:"updated_at,omitempty"`

	// Url Helper field to set `protocol`, `host`, `port` and `path` using a URL. This field is write-only and is not returned in responses.
	Url *string `json:"url,omitempty"`

	// WriteTimeout The timeout in milliseconds between two successive write operations for transmitting a request to the upstream server.
	WriteTimeout *int `json:"write_timeout,omitempty"`
}

// ServiceClientCertificate Certificate to be used as client certificate while TLS handshaking to the upstream server.
type ServiceClientCertificate struct {
	Id *string `json:"id,omitempty"`
}

// Tags List of tag values
type Tags = []string

// Target A target is an ip address/hostname with a port that identifies an instance of a backend service. Every upstream can have many targets, and the targets can be dynamically added, modified, or deleted. Changes take effect on the fly. To disable a target, post a new one with `weight=0`; alternatively, use the `DELETE` convenience method to accomplish the same. The current target object definition is the one with the latest `created_at`.
type Target struct {
	// CreatedAt Unix epoch when the resource was created.
	CreatedAt *float32 `json:"created_at,omitempty"`

	// Id The unique identifier or the name of the upstream for which to update the target.
	Id *string `json:"id,omitempty"`

	// Tags An optional set of strings associated with the Target for grouping and filtering.
	Tags *[]string `json:"tags,omitempty"`

	// Target The target address (ip or hostname) and port. If the hostname resolves to an SRV record, the `port` value will be overridden by the value from the DNS record.
	Target *string `json:"target,omitempty"`

	// Upstream The unique identifier or the name of the upstream for which to update the target.
	Upstream *TargetUpstream `json:"upstream,omitempty"`

	// Weight The weight this target gets within the upstream loadbalancer (`0`-`65535`). If the hostname resolves to an SRV record, the `weight` value will be overridden by the value from the DNS record.
	Weight *int `json:"weight,omitempty"`
}

// TargetUpstream The unique identifier or the name of the upstream for which to update the target.
type TargetUpstream struct {
	Id *string `json:"id,omitempty"`
}

// UnauthorizedError defines model for UnauthorizedError.
type UnauthorizedError struct {
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// Upstream The upstream object represents a virtual hostname and can be used to loadbalance incoming requests over multiple services (targets). So for example an upstream named `service.v1.xyz` for a service object whose `host` is `service.v1.xyz`. Requests for this service would be proxied to the targets defined within the upstream. An upstream also includes a health check, which is able to enable and disable targets based on their ability or inability to serve requests. The configuration for the health checker is stored in the upstream object, and applies to all of its targets.
type Upstream struct {
	// Algorithm Which load balancing algorithm to use.
	Algorithm *string `json:"algorithm,omitempty"`

	// ClientCertificate If set, the certificate to be used as client certificate while TLS handshaking to the upstream server.
	ClientCertificate *UpstreamClientCertificate `json:"client_certificate,omitempty"`

	// CreatedAt Unix epoch when the resource was created.
	CreatedAt *int `json:"created_at,omitempty"`

	// HashFallback What to use as hashing input if the primary `hash_on` does not return a hash (eg. header is missing, or no Consumer identified). Not available if `hash_on` is set to `cookie`.
	HashFallback *string `json:"hash_fallback,omitempty"`

	// HashFallbackHeader The header name to take the value from as hash input. Only required when `hash_fallback` is set to `header`.
	HashFallbackHeader *string `json:"hash_fallback_header,omitempty"`

	// HashFallbackQueryArg The name of the query string argument to take the value from as hash input. Only required when `hash_fallback` is set to `query_arg`.
	HashFallbackQueryArg *string `json:"hash_fallback_query_arg,omitempty"`

	// HashFallbackUriCapture The name of the route URI capture to take the value from as hash input. Only required when `hash_fallback` is set to `uri_capture`.
	HashFallbackUriCapture *string `json:"hash_fallback_uri_capture,omitempty"`

	// HashOn What to use as hashing input. Using `none` results in a weighted-round-robin scheme with no hashing.
	HashOn *string `json:"hash_on,omitempty"`

	// HashOnCookie The cookie name to take the value from as hash input. Only required when `hash_on` or `hash_fallback` is set to `cookie`. If the specified cookie is not in the request, Kong will generate a value and set the cookie in the response.
	HashOnCookie *string `json:"hash_on_cookie,omitempty"`

	// HashOnCookiePath The cookie path to set in the response headers. Only required when `hash_on` or `hash_fallback` is set to `cookie`.
	HashOnCookiePath *string `json:"hash_on_cookie_path,omitempty"`

	// HashOnHeader The header name to take the value from as hash input. Only required when `hash_on` is set to `header`.
	HashOnHeader *string `json:"hash_on_header,omitempty"`

	// HashOnQueryArg The name of the query string argument to take the value from as hash input. Only required when `hash_on` is set to `query_arg`.
	HashOnQueryArg *string `json:"hash_on_query_arg,omitempty"`

	// HashOnUriCapture The name of the route URI capture to take the value from as hash input. Only required when `hash_on` is set to `uri_capture`.
	HashOnUriCapture *string               `json:"hash_on_uri_capture,omitempty"`
	Healthchecks     *UpstreamHealthchecks `json:"healthchecks,omitempty"`

	// HostHeader The hostname to be used as `Host` header when proxying requests through Kong.
	HostHeader *string `json:"host_header,omitempty"`
	Id         *string `json:"id,omitempty"`

	// Name This is a hostname, which must be equal to the `host` of a service.
	Name *string `json:"name,omitempty"`

	// Slots The number of slots in the load balancer algorithm. If `algorithm` is set to `round-robin`, this setting determines the maximum number of slots. If `algorithm` is set to `consistent-hashing`, this setting determines the actual number of slots in the algorithm. Accepts an integer in the range `10`-`65536`.
	Slots *int `json:"slots,omitempty"`

	// Tags An optional set of strings associated with the Upstream for grouping and filtering.
	Tags *[]string `json:"tags,omitempty"`

	// UseSrvName If set, the balancer will use SRV hostname(if DNS Answer has SRV record) as the proxy upstream `Host`.
	UseSrvName *bool `json:"use_srv_name,omitempty"`
}

// UpstreamClientCertificate If set, the certificate to be used as client certificate while TLS handshaking to the upstream server.
type UpstreamClientCertificate struct {
	Id *string `json:"id,omitempty"`
}

// UpstreamHealthchecks defines model for Upstream_healthchecks.
type UpstreamHealthchecks struct {
	Active    *UpstreamHealthchecksActive  `json:"active,omitempty"`
	Passive   *UpstreamHealthchecksPassive `json:"passive,omitempty"`
	Threshold *float32                     `json:"threshold,omitempty"`
}

// UpstreamHealthchecksActive defines model for Upstream_healthchecks_active.
type UpstreamHealthchecksActive struct {
	Concurrency            *int                                 `json:"concurrency,omitempty"`
	Headers                *map[string]interface{}              `json:"headers,omitempty"`
	Healthy                *UpstreamHealthchecksActiveHealthy   `json:"healthy,omitempty"`
	HttpPath               *string                              `json:"http_path,omitempty"`
	HttpsSni               *string                              `json:"https_sni,omitempty"`
	HttpsVerifyCertificate *bool                                `json:"https_verify_certificate,omitempty"`
	Timeout                *float32                             `json:"timeout,omitempty"`
	Type                   *string                              `json:"type,omitempty"`
	Unhealthy              *UpstreamHealthchecksActiveUnhealthy `json:"unhealthy,omitempty"`
}

// UpstreamHealthchecksActiveHealthy defines model for Upstream_healthchecks_active_healthy.
type UpstreamHealthchecksActiveHealthy struct {
	HttpStatuses *[]int   `json:"http_statuses,omitempty"`
	Interval     *float32 `json:"interval,omitempty"`
	Successes    *int     `json:"successes,omitempty"`
}

// UpstreamHealthchecksActiveUnhealthy defines model for Upstream_healthchecks_active_unhealthy.
type UpstreamHealthchecksActiveUnhealthy struct {
	HttpFailures *int     `json:"http_failures,omitempty"`
	HttpStatuses *[]int   `json:"http_statuses,omitempty"`
	Interval     *float32 `json:"interval,omitempty"`
	TcpFailures  *int     `json:"tcp_failures,omitempty"`
	Timeouts     *int     `json:"timeouts,omitempty"`
}

// UpstreamHealthchecksPassive defines model for Upstream_healthchecks_passive.
type UpstreamHealthchecksPassive struct {
	Healthy   *UpstreamHealthchecksPassiveHealthy   `json:"healthy,omitempty"`
	Type      *string                               `json:"type,omitempty"`
	Unhealthy *UpstreamHealthchecksPassiveUnhealthy `json:"unhealthy,omitempty"`
}

// UpstreamHealthchecksPassiveHealthy defines model for Upstream_healthchecks_passive_healthy.
type UpstreamHealthchecksPassiveHealthy struct {
	HttpStatuses *[]int `json:"http_statuses,omitempty"`
	Successes    *int   `json:"successes,omitempty"`
}

// UpstreamHealthchecksPassiveUnhealthy defines model for Upstream_healthchecks_passive_unhealthy.
type UpstreamHealthchecksPassiveUnhealthy struct {
	HttpFailures *int   `json:"http_failures,omitempty"`
	HttpStatuses *[]int `json:"http_statuses,omitempty"`
	TcpFailures  *int   `json:"tcp_failures,omitempty"`
	Timeouts     *int   `json:"timeouts,omitempty"`
}

// Vault Vault entities are used to configure different Vault connectors. Examples of Vaults are Environment Variables, HashiCorp Vault and AWS Secrets Manager. Configuring a Vault allows referencing the secrets with other entities. For example a certificate entity can store a reference to a certificate and key, stored in a vault, instead of storing the certificate and key within the entity. This allows a proper separation of secrets and configuration and prevents secret sprawl.
type Vault struct {
	// Config The configuration properties for the Vault which can be found on the [vaults' documentation page](https://docs.konghq.com/gateway/latest/kong-enterprise/secrets-management/advanced-usage/).
	Config *VaultConfig `json:"config,omitempty"`

	// CreatedAt Unix epoch when the resource was created.
	CreatedAt *int `json:"created_at,omitempty"`

	// Description The description of the Vault entity.
	Description *string `json:"description,omitempty"`
	Id          *string `json:"id,omitempty"`

	// Name The name of the Vault thats going to be added. Currently, the Vault implementation must be installed in every Kong instance.
	Name *string `json:"name,omitempty"`

	// Prefix The unique prefix (or identifier) for this Vault configuration. The prefix is used to load the right Vault configuration and implementation when referencing secrets with the other entities.
	Prefix *string `json:"prefix,omitempty"`

	// Tags An optional set of strings associated with the Vault for grouping and filtering.
	Tags *[]string `json:"tags,omitempty"`

	// UpdatedAt Unix epoch when the resource was last updated.
	UpdatedAt *int `json:"updated_at,omitempty"`
}

// VaultConfig The configuration properties for the Vault which can be found on the [vaults' documentation page](https://docs.konghq.com/gateway/latest/kong-enterprise/secrets-management/advanced-usage/).
type VaultConfig struct {
	// Prefix The unique prefix (or identifier) for this Vault configuration. The prefix is used to load the right Vault configuration and implementation when referencing secrets with the other entities.
	Prefix *VaultConfigPrefix `json:"prefix,omitempty"`
}

// VaultConfigPrefix The unique prefix (or identifier) for this Vault configuration. The prefix is used to load the right Vault configuration and implementation when referencing secrets with the other entities.
type VaultConfigPrefix string

// CreateCaCertificateRequest defines model for create_ca_certificate_request.
type CreateCaCertificateRequest struct {
	// Cert PEM-encoded public certificate of the CA.
	Cert string `json:"cert"`

	// CertDigest SHA256 hex digest of the public certificate.
	CertDigest *string `json:"cert_digest,omitempty"`

	// Tags An optional set of strings associated with the Certificate for grouping and filtering.
	Tags *[]string `json:"tags,omitempty"`
}

// CreateCertificateRequest defines model for create_certificate_request.
type CreateCertificateRequest struct {
	// Cert PEM-encoded public certificate chain of the SSL key pair.
	Cert string `json:"cert"`

	// CertAlt PEM-encoded public certificate chain of the alternate SSL key pair.
	CertAlt *string `json:"cert_alt,omitempty"`

	// Key PEM-encoded private key of the SSL key pair.
	Key string `json:"key"`

	// KeyAlt PEM-encoded private key of the alternate SSL key pair.
	KeyAlt *string `json:"key_alt,omitempty"`

	// Passphrase To load an encrypted private key into Kong, specify the passphrase using this attributKong will decrypt the private key and store it in its database. e. Enterprise Only
	Passphrase *string `json:"passphrase,omitempty"`

	// Snis An array of zero or more hostnames to associate with this certificate as SNIs.
	Snis *[]string `json:"snis,omitempty"`

	// Tags An optional set of strings associated with the Certificate for grouping and filtering.
	Tags *[]string `json:"tags,omitempty"`
}

// CreateConsumerRequest defines model for create_consumer_request.
type CreateConsumerRequest struct {
	// CustomId Field for storing an existing unique ID for the Consumer - useful for mapping Kong with users in your existing database. You must send either this field or username with the request.
	CustomId string `json:"custom_id"`

	// Tags An optional set of strings associated with the Consumer for grouping and filtering.
	Tags *[]string `json:"tags,omitempty"`

	// Username The unique username of the Consumer. You must send either this field or custom_id with the request.
	Username string `json:"username"`
}

// CreateKeyRequest defines model for create_key_request.
type CreateKeyRequest struct {
	// Jwk A JSON Web Key represented as a string.
	Jwk *string `json:"jwk,omitempty"`

	// Kid A unique identifier for a key.
	Kid string `json:"kid"`

	// Name The name to associate with the given keys.
	Name *string `json:"name,omitempty"`

	// Pem A keypair in PEM format.
	Pem *CreateKeyRequestPem `json:"pem,omitempty"`

	// Set The id (an UUID) of the key-set with which to associate the key .With form-encoded, the notation is `set.id=<set id>` or `set.name=<set name>`. With JSON, use `"set":{"id":"<set id>"}` or `"set":{"name":"<set name>"}.`
	Set *CreateKeyRequestSet `json:"set,omitempty"`

	// Tags An optional set of strings associated with the Key for grouping and filtering.
	Tags *[]string `json:"tags,omitempty"`
}

// CreateKeyRequestPem A keypair in PEM format.
type CreateKeyRequestPem struct {
	PrivateKey *string `json:"private_key,omitempty"`
	PublicKey  *string `json:"public_key,omitempty"`
}

// CreateKeyRequestSet The id (an UUID) of the key-set with which to associate the key .With form-encoded, the notation is `set.id=<set id>` or `set.name=<set name>`. With JSON, use `"set":{"id":"<set id>"}` or `"set":{"name":"<set name>"}.`
type CreateKeyRequestSet struct {
	// Id 46CA83EE-671C-11ED-BFAB-2FE47512C77A
	Id *string `json:"id,omitempty"`
}

// CreateKeySetRequest defines model for create_key_set_request.
type CreateKeySetRequest struct {
	// Name The name to associate with the given key-set.
	Name *string `json:"name,omitempty"`

	// Tags An optional set of strings associated with the Key for grouping and filtering.
	Tags *[]string `json:"tags,omitempty"`
}

// CreatePluginForConsumerRequest defines model for create_plugin_for_consumer_request.
type CreatePluginForConsumerRequest struct {
	// Config The configuration properties for the Plugin
	Config *map[string]interface{} `json:"config,omitempty"`

	// Consumer If set, the plugin will activate only for requests where the specified has been authenticated. (Note that some plugins can not be restricted to consumers this way.)
	Consumer *string `json:"consumer"`

	// Enabled Whether the plugin is applied. Default: `true`.
	Enabled *bool `json:"enabled,omitempty"`

	// InstanceName An optional custom name to identify an instance of the plugin, for example `basic-auth_example-service`.
	//
	// The instance name shows up in Kong Manager, so it's useful when running the same
	// plugin in multiple contexts, for example, on multiple services. You can also use it to access a specific plugin instance
	// via the Kong Admin API.
	//
	// An instance name must be unique globally for Kong Gateway OSS.
	InstanceName *string `json:"instance_name,omitempty"`

	// Name The name of the Plugin that's going to be added. Currently, the Plugin must be installed in every Kong instance separately.
	Name *string `json:"name,omitempty"`

	// Protocols A list of the request protocols that will trigger this plugin.
	Protocols *[]CreatePluginForConsumerRequestProtocols `json:"protocols,omitempty"`

	// Route If set, the plugin will only activate when receiving requests via the specified route. Leave unset for the plugin to activate regardless of the route being used. Default: `null`. With form-encoded, the notation is `route.id=<route id> or route.name=<route name>`. With JSON, use `"route":{"id":"<route id>"}` or `"route":{"name":"<route name>"}`.
	Route *string `json:"route"`

	// Service If set, the plugin will only activate when receiving requests via one of the routes belonging to the specified service.
	Service *string `json:"service"`

	// Tags An optional set of strings associated with the Plugin for grouping and filtering.
	Tags *[]string `json:"tags,omitempty"`
}

// CreatePluginForConsumerRequestProtocols defines model for CreatePluginForConsumerRequest.Protocols.
type CreatePluginForConsumerRequestProtocols string

// CreateRouteRequest defines model for create_route_request.
type CreateRouteRequest struct {
	// Destinations A list of IP destinations of incoming connections that match this route when using stream routing. Each entry is an object with fields "ip" (optionally in CIDR range notation) and/or "port".
	Destinations *[]CreateRouteRequestDestinationsInner `json:"destinations,omitempty"`

	// Headers One or more lists of values indexed by header name that will cause this route to match if present in the request. The Host header cannot be used with this hosts should be specified using the `hosts` attribute. When headers contains only one value and that value starts with the special prefix` ~*`, the value is interpreted as a regular expression.
	Headers *CreateRouteRequestHeaders `json:"headers,omitempty"`

	// Hosts A list of domain names that match this route. Note that the hosts value is case sensitive. With form-encoded, the notation is `hosts[]=example.com&hosts[]=foo.test`. With JSON, use an Array.
	Hosts *[]string `json:"hosts,omitempty"`

	// HttpsRedirectStatusCode The status code Kong responds with when all properties of a route match except the protocol i.e. if the protocol of the request is `HTTP` instead of `HTTPS`
	// Location header is injected by Kong if the field is set to `301`, `302`, `307` or `308`. Note: This config applies only if the route is configured to only accept the https protocol. Accepted values are: `426`, `301`, `302`, `307`, `308`. Default: `426`.
	HttpsRedirectStatusCode CreateRouteRequestHttpsRedirectStatusCode `json:"https_redirect_status_code"`

	// Methods A list of HTTP methods that match this route.
	Methods *[]string `json:"methods,omitempty"`

	// Name The name of the route. Route names must be unique, and they are case sensitive. For example, there can be two different routes named "test" and "Test".
	Name *string `json:"name,omitempty"`

	// PathHandling Controls how the service path, route path and requested path are combined when sending a request to the upstream. Accepted values are "`v0`", "`v1`".
	PathHandling *CreateRouteRequestPathHandling `json:"path_handling,omitempty"`

	// Paths A list of paths that match this route. With form-encoded, the notation is `paths[]=/foo&paths[]=/bar`. With JSON, use an array. The path can be a regular expression, or a plain text pattern.
	Paths *[]string `json:"paths,omitempty"`

	// PreserveHost When matching a route via one of the `hosts` domain names, use the request `host` header in the upstream request headers. If set to `false`, the upstream Host header will be that of the service's host.
	PreserveHost bool `json:"preserve_host"`

	// Protocols An array of the protocols this route should allow
	Protocols []string `json:"protocols"`

	// RegexPriority A number used to choose which route resolves a given request when several routes match it using regexes simultaneously. When two routes match the path and have the same regex_priority, the older one (lowest `created_at`) is used. Note that the priority for non-regex routes is different (longer non-regex routes are matched before shorter ones).
	RegexPriority *int `json:"regex_priority,omitempty"`

	// RequestBuffering Whether to enable request body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that receive data with chunked transfer encoding. Default: true.
	RequestBuffering bool `json:"request_buffering"`

	// ResponseBuffering Whether to enable response body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that send data with chunked transfer encoding. Default: `true`.
	ResponseBuffering bool `json:"response_buffering"`

	// Service The service this route is associated to. This is where the route proxies traffic to. With form-encoded, the notation is service.id=<service id> or service.name=<service name>. With JSON, use `"service":{"id":"<service id>"}` or `"service":{"name":"<service name>"}`.
	Service *CreateRouteRequestService `json:"service,omitempty"`

	// Snis A list of SNIs that match this route when using stream routing.
	Snis *[]string `json:"snis,omitempty"`

	// Sources A list of IP sources of incoming connections that match this route when using stream routing. Each entry is an object with fields "ip" (optionally in CIDR range notation) and/or "port".
	Sources *[]CreateRouteRequestSourcesInner `json:"sources,omitempty"`

	// StripPath When matching a route via one of the paths, strip the matching prefix from the upstream request URL.
	StripPath *bool `json:"strip_path,omitempty"`

	// Tags An optional set of strings associated with the route for grouping and filtering.
	Tags *[]string `json:"tags,omitempty"`
}

// CreateRouteRequestHttpsRedirectStatusCode The status code Kong responds with when all properties of a route match except the protocol i.e. if the protocol of the request is `HTTP` instead of `HTTPS`
// Location header is injected by Kong if the field is set to `301`, `302`, `307` or `308`. Note: This config applies only if the route is configured to only accept the https protocol. Accepted values are: `426`, `301`, `302`, `307`, `308`. Default: `426`.
type CreateRouteRequestHttpsRedirectStatusCode int

// CreateRouteRequestPathHandling Controls how the service path, route path and requested path are combined when sending a request to the upstream. Accepted values are "`v0`", "`v1`".
type CreateRouteRequestPathHandling string

// CreateRouteRequestDestinationsInner defines model for create_route_request_destinations_inner.
type CreateRouteRequestDestinationsInner struct {
	Ip   *string `json:"ip,omitempty"`
	Port *int    `json:"port,omitempty"`
}

// CreateRouteRequestHeaders One or more lists of values indexed by header name that will cause this route to match if present in the request. The Host header cannot be used with this hosts should be specified using the `hosts` attribute. When headers contains only one value and that value starts with the special prefix` ~*`, the value is interpreted as a regular expression.
type CreateRouteRequestHeaders struct {
	XAnotherHeader *[]string `json:"x-another-header,omitempty"`
	XMyHeader      *[]string `json:"x-my-header,omitempty"`
}

// CreateRouteRequestService The service this route is associated to. This is where the route proxies traffic to. With form-encoded, the notation is service.id=<service id> or service.name=<service name>. With JSON, use `"service":{"id":"<service id>"}` or `"service":{"name":"<service name>"}`.
type CreateRouteRequestService struct {
	Id *string `json:"id,omitempty"`
}

// CreateRouteRequestSourcesInner defines model for create_route_request_sources_inner.
type CreateRouteRequestSourcesInner struct {
	Ip   *string `json:"ip,omitempty"`
	Port *int    `json:"port,omitempty"`
}

// CreateServiceRequest defines model for create_service_request.
type CreateServiceRequest struct {
	// CaCertificates Array of CA Certificate object UUIDs that are used to build the trust store while verifying upstream server's TLS certificate. If set to null when Nginx default is respected.
	// With form-encoded, the notation is `ca_certificates[]=4e3ad2e4-0bc4-4638-8e34-c84a417ba39b&ca_certificates[]=51e77dc2-8f3e-4afa-9d0e-0e3bbbcfd515`. With JSON, use an Array.
	CaCertificates *[]string `json:"ca_certificates,omitempty"`

	// ClientCertificate Certificate to be used as client certificate while TLS handshaking to the upstream server. With form-encoded, the notation is `client_certificate.id=<client_certificate id>`. With JSON, use `"client_certificate":{"id":"<client_certificate id>"}`.
	ClientCertificate *CreateServiceRequestClientCertificate `json:"client_certificate,omitempty"`

	// ConnectTimeout The timeout in milliseconds for establishing a connection to the upstream server.
	ConnectTimeout *int `json:"connect_timeout,omitempty"`

	// Enabled Whether the service is active. If set to `false`, the proxy behavior will be as if any routes attached to it do not exist (404). Default: `true`.
	Enabled bool `json:"enabled"`

	// Host The host of the upstream server. Note that the host value is case sensitive.
	Host string `json:"host"`

	// Name The service name.
	Name *string `json:"name,omitempty"`

	// Path The path to be used in requests to the upstream server.
	Path *string `json:"path,omitempty"`

	// Port The upstream server port. Default: `80`.
	Port int `json:"port"`

	// Protocol The protocol used to communicate with the upstream. Accepted values are: "`grpc`", "`grpcs`", "`http`", "`https`", "`tcp`", "`tls`", "`tls_passthrough`", "`udp`", "`ws`"
	// , "`wss`"
	// . Default: "`http`".
	Protocol CreateServiceRequestProtocol `json:"protocol"`

	// ReadTimeout The timeout in milliseconds between two successive read operations for transmitting a request to the upstream server. Default: `60000`.
	ReadTimeout *int `json:"read_timeout,omitempty"`

	// Retries The number of retries to execute upon failure to proxy. Default:`5`.
	Retries *int `json:"retries,omitempty"`

	// Tags An optional set of strings associated with the service for grouping and filtering.
	Tags *[]string `json:"tags,omitempty"`

	// TlsVerify Whether to enable verification of upstream server TLS certificate. If set to null, then the Nginx default is respected.
	TlsVerify *bool `json:"tls_verify,omitempty"`

	// TlsVerifyDepth Maximum depth of chain while verifying Upstream server's TLS certificate. If set to null, then the Nginx default is respected. Default: null.
	TlsVerifyDepth *string `json:"tls_verify_depth"`

	// WriteTimeout The timeout in milliseconds between two successive write operations for transmitting a request to the upstream server. Default: `60000`.
	WriteTimeout *int `json:"write_timeout,omitempty"`
}

// CreateServiceRequestProtocol The protocol used to communicate with the upstream. Accepted values are: "`grpc`", "`grpcs`", "`http`", "`https`", "`tcp`", "`tls`", "`tls_passthrough`", "`udp`", "`ws`"
// , "`wss`"
// . Default: "`http`".
type CreateServiceRequestProtocol string

// CreateServiceRequestClientCertificate Certificate to be used as client certificate while TLS handshaking to the upstream server. With form-encoded, the notation is `client_certificate.id=<client_certificate id>`. With JSON, use `"client_certificate":{"id":"<client_certificate id>"}`.
type CreateServiceRequestClientCertificate struct {
	Id *string `json:"id,omitempty"`
}

// CreateSniForCertificateRequest defines model for create_sni_for_certificate_request.
type CreateSniForCertificateRequest struct {
	// Certificate The id (a UUID) of the certificate with which to associate the SNI hostname. The Certificate must have a valid private key associated with it to be used by the SNI object. With form-encoded, the notation is `certificate.id=<certificate id>`. With JSON, use `"certificate":{"id":"<certificate id>"}`.
	Certificate CreateSniForCertificateRequestCertificate `json:"certificate"`

	// Name The SNI name to associate with the given certificate.
	Name string `json:"name"`

	// Tags An optional set of strings associated with the SNIs for grouping and filtering.
	Tags *[]string `json:"tags,omitempty"`
}

// CreateSniForCertificateRequestCertificate The id (a UUID) of the certificate with which to associate the SNI hostname. The Certificate must have a valid private key associated with it to be used by the SNI object. With form-encoded, the notation is `certificate.id=<certificate id>`. With JSON, use `"certificate":{"id":"<certificate id>"}`.
type CreateSniForCertificateRequestCertificate struct {
	// Id 91020192-062d-416f-a275-9addeeaffaf2
	Id *string `json:"id,omitempty"`
}

// CreateTargetForUpstreamRequest defines model for create_target_for_upstream_request.
type CreateTargetForUpstreamRequest struct {
	// Tags An optional set of strings associated with the Target for grouping and filtering.
	Tags *[]string `json:"tags,omitempty"`

	// Target The target for the upstream
	Target *string `json:"target,omitempty"`

	// Weight The weight this target gets within the upstream loadbalancer (`0`-`65535`). If the hostname resolves to an SRV record, the `weight` value will be overridden by the value from the DNS record.
	Weight *int `json:"weight,omitempty"`
}

// CreateUpstreamRequest defines model for create_upstream_request.
type CreateUpstreamRequest struct {
	// Algorithm Which load balancing algorithm to use. Accepted values are: `"consistent-hashing"`, `"least-connections"`,` "round-robin"`. Default: `"round-robin"`.
	Algorithm *CreateUpstreamRequestAlgorithm `json:"algorithm,omitempty"`

	// ClientCertificate If set, the certificate to be used as client certificate while TLS handshaking to the upstream server.
	ClientCertificate *CreateUpstreamRequestClientCertificate `json:"client_certificate,omitempty"`

	// HashFallback What to use as hashing input if the primary hash_on does not return a hash (eg. header is missing, or no Consumer identified). Not available if hash_on is set to cookie.
	HashFallback *CreateUpstreamRequestHashFallback `json:"hash_fallback,omitempty"`

	// HashFallbackHeader The header name to take the value from as hash input. Only required when hash_fallback is set to header.
	HashFallbackHeader *string `json:"hash_fallback_header,omitempty"`

	// HashFallbackQueryArg The name of the query string argument to take the value from as hash input. Only required when `hash_fallback` is set to `query_arg`.
	HashFallbackQueryArg *string `json:"hash_fallback_query_arg,omitempty"`

	// HashFallbackUriCapture The name of the route URI capture to take the value from as hash input. Only required when `hash_fallback` is set to `uri_capture`.
	HashFallbackUriCapture *string `json:"hash_fallback_uri_capture,omitempty"`

	// HashOn What to use as hashing input. Using none results in a weighted-round-robin scheme with no hashing
	HashOn *CreateUpstreamRequestHashOn `json:"hash_on,omitempty"`

	// HashOnCookie The cookie name to take the value from as hash input. Only required when `hash_on` or `hash_fallback` is set to `cookie`. If the specified cookie is not in the request, Kong will generate a value and set the cookie in the response.
	HashOnCookie *string `json:"hash_on_cookie,omitempty"`

	// HashOnCookiePath The cookie path to set in the response headers. Only required when `hash_on` or `hash_fallback` is set to `cookie`.
	HashOnCookiePath *string `json:"hash_on_cookie_path,omitempty"`

	// HashOnHeader The header name to take the value from as hash input. Only required when `hash_on` is set to header.
	HashOnHeader *string `json:"hash_on_header,omitempty"`

	// HashOnQueryArg The name of the query string argument to take the value from as hash input. Only required when `hash_on` is set to `query_arg`.
	HashOnQueryArg *string `json:"hash_on_query_arg,omitempty"`

	// HashOnUriCapture The name of the route URI capture to take the value from as hash input. Only required when `hash_on` is set to `uri_capture`.
	HashOnUriCapture *string                            `json:"hash_on_uri_capture,omitempty"`
	Healthchecks     *CreateUpstreamRequestHealthchecks `json:"healthchecks,omitempty"`

	// HostHeader The hostname to be used as Host header when proxying requests through Kong.
	HostHeader *string `json:"host_header,omitempty"`

	// Name This is a hostname, which must be equal to the `host` of a service.
	Name string `json:"name"`

	// Slots The number of slots in the load balancer algorithm. If the algorithm is set to `round-robin`, this setting determines the maximum number of slots. If the algorithm is set to `consistent-hashing`, this setting determines the actual number of slots in the algorithm. Accepts an integer in the range 10-65536.
	Slots *int `json:"slots,omitempty"`

	// Tags An optional set of strings associated with the Upstream for grouping and filtering.
	Tags *[]string `json:"tags,omitempty"`

	// UseSrvName If set, the balancer will use SRV hostname(if DNS Answer has SRV record) as the proxy upstream Host.
	UseSrvName *bool `json:"use_srv_name,omitempty"`
}

// CreateUpstreamRequestAlgorithm Which load balancing algorithm to use. Accepted values are: `"consistent-hashing"`, `"least-connections"`,` "round-robin"`. Default: `"round-robin"`.
type CreateUpstreamRequestAlgorithm string

// CreateUpstreamRequestHashFallback What to use as hashing input if the primary hash_on does not return a hash (eg. header is missing, or no Consumer identified). Not available if hash_on is set to cookie.
type CreateUpstreamRequestHashFallback string

// CreateUpstreamRequestHashOn What to use as hashing input. Using none results in a weighted-round-robin scheme with no hashing
type CreateUpstreamRequestHashOn string

// CreateUpstreamRequestClientCertificate If set, the certificate to be used as client certificate while TLS handshaking to the upstream server.
type CreateUpstreamRequestClientCertificate struct {
	Id *string `json:"id,omitempty"`
}

// CreateUpstreamRequestHealthchecks defines model for create_upstream_request_healthchecks.
type CreateUpstreamRequestHealthchecks struct {
	Active  *CreateUpstreamRequestHealthchecksActive  `json:"active,omitempty"`
	Passive *CreateUpstreamRequestHealthchecksPassive `json:"passive,omitempty"`

	// Threshold The minimum percentage of the upstream's targets' weight that must be available for the whole upstream to be considered healthy.
	Threshold *int `json:"threshold,omitempty"`
}

// CreateUpstreamRequestHealthchecksActive defines model for create_upstream_request_healthchecks_active.
type CreateUpstreamRequestHealthchecksActive struct {
	// Concurrency Number of targets to check concurrently in active health checks.
	Concurrency *int `json:"concurrency,omitempty"`

	// Headers One or more lists of values indexed by header name to use in GET HTTP request to run as a probe on active health checks. Values must be pre-formatted.
	Headers *map[string]interface{}                         `json:"headers,omitempty"`
	Healthy *CreateUpstreamRequestHealthchecksActiveHealthy `json:"healthy,omitempty"`

	// HttpPath Path to use in GET HTTP request to run as a probe on active health checks.
	HttpPath *string `json:"http_path,omitempty"`

	// HttpsSni The hostname to use as an SNI (Server Name Identification) when performing active health checks using HTTPS. This is particularly useful when Targets are configured using IPs, so that the target host's certificate can be verified with the proper SNI.
	HttpsSni               *string `json:"https_sni,omitempty"`
	HttpsVerifyCertificate *bool   `json:"https_verify_certificate,omitempty"`

	// Timeout Socket timeout for active health checks (in seconds).
	Timeout *int `json:"timeout,omitempty"`

	// Type Whether to perform active health checks using HTTP or HTTPS, or just attempt a TCP connection.
	Type      *CreateUpstreamRequestHealthchecksActiveType      `json:"type,omitempty"`
	Unhealthy *CreateUpstreamRequestHealthchecksActiveUnhealthy `json:"unhealthy,omitempty"`
}

// CreateUpstreamRequestHealthchecksActiveType Whether to perform active health checks using HTTP or HTTPS, or just attempt a TCP connection.
type CreateUpstreamRequestHealthchecksActiveType string

// CreateUpstreamRequestHealthchecksActiveHealthy defines model for create_upstream_request_healthchecks_active_healthy.
type CreateUpstreamRequestHealthchecksActiveHealthy struct {
	// HttpStatuses An array of HTTP statuses to consider a success, indicating healthiness, when returned by a probe in active health checks. With form-encoded, the notation is `http_statuses[]=200&http_statuses[]=302`. With JSON, use an array.
	HttpStatuses *[]int `json:"http_statuses,omitempty"`

	// Interval Interval between active health checks for healthy targets (in seconds). A value of zero indicates that active probes for healthy targets should not be performed.
	Interval *int `json:"interval,omitempty"`

	// Successes Number of successes in active probes (as defined by `healthchecks.active.healthy.http_statuses`) to consider a target healthy.
	Successes *int `json:"successes,omitempty"`
}

// CreateUpstreamRequestHealthchecksActiveUnhealthy defines model for create_upstream_request_healthchecks_active_unhealthy.
type CreateUpstreamRequestHealthchecksActiveUnhealthy struct {
	// HttpFailures Number of HTTP failures in active probes (as defined by `healthchecks.active.unhealthy.http_statuses`) to consider a target unhealthy.
	HttpFailures *int `json:"http_failures,omitempty"`

	// HttpStatuses An array of HTTP statuses to consider a failure, indicating unhealthiness, when returned by a probe in active health checks. With form-encoded, the notation is `http_statuses[]=429&http_statuses[]=404`. With JSON, use an array.
	HttpStatuses *[]int `json:"http_statuses,omitempty"`

	// Interval Interval between active health checks for unhealthy targets (in seconds). A value of zero indicates that active probes for unhealthy targets should not be performed.
	Interval *int `json:"interval,omitempty"`

	// TcpFailures Number of TCP failures in active probes to consider a target unhealthy.
	TcpFailures *int `json:"tcp_failures,omitempty"`

	// Timeouts Number of timeouts in active probes to consider a target unhealthy.
	Timeouts *int `json:"timeouts,omitempty"`
}

// CreateUpstreamRequestHealthchecksPassive defines model for create_upstream_request_healthchecks_passive.
type CreateUpstreamRequestHealthchecksPassive struct {
	Healthy *CreateUpstreamRequestHealthchecksPassiveHealthy `json:"healthy,omitempty"`

	// Type Whether to perform passive health checks interpreting HTTP/HTTPS statuses, or just check for TCP connection success. In passive checks, http and https options are equivalent. Accepted values are `tcp`, `http`, `https`, `grpc`, `grpcs`.
	Type      *CreateUpstreamRequestHealthchecksPassiveType      `json:"type,omitempty"`
	Unhealthy *CreateUpstreamRequestHealthchecksPassiveUnhealthy `json:"unhealthy,omitempty"`
}

// CreateUpstreamRequestHealthchecksPassiveType Whether to perform passive health checks interpreting HTTP/HTTPS statuses, or just check for TCP connection success. In passive checks, http and https options are equivalent. Accepted values are `tcp`, `http`, `https`, `grpc`, `grpcs`.
type CreateUpstreamRequestHealthchecksPassiveType string

// CreateUpstreamRequestHealthchecksPassiveHealthy defines model for create_upstream_request_healthchecks_passive_healthy.
type CreateUpstreamRequestHealthchecksPassiveHealthy struct {
	// HttpStatuses An array of HTTP statuses which represent healthiness when produced by proxied traffic, as observed by passive health checks.  With form-encoded, the notation is `http_statuses[]=200&http_statuses[]=201`. With JSON, use an array.
	HttpStatuses *[]CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatuses `json:"http_statuses,omitempty"`

	// Successes Number of successes in proxied traffic (as defined by `healthchecks.passive.healthy.http_statuses`) to consider a target healthy, as observed by passive health checks.
	Successes *int `json:"successes,omitempty"`
}

// CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatuses defines model for CreateUpstreamRequestHealthchecksPassiveHealthy.HttpStatuses.
type CreateUpstreamRequestHealthchecksPassiveHealthyHttpStatuses int

// CreateUpstreamRequestHealthchecksPassiveUnhealthy defines model for create_upstream_request_healthchecks_passive_unhealthy.
type CreateUpstreamRequestHealthchecksPassiveUnhealthy struct {
	// HttpFailures Number of HTTP failures in proxied traffic (as defined by `healthchecks.passive.unhealthy.http_statuses`) to consider a target unhealthy, as observed by passive health checks.
	HttpFailures *int `json:"http_failures,omitempty"`

	// HttpStatuses An array of HTTP statuses which represent unhealthiness when produced by proxied traffic, as observed by passive health checks. With form-encoded, the notation is `http_statuses[]=429&http_statuses[]=500`. With JSON, use an array.
	HttpStatuses *[]CreateUpstreamRequestHealthchecksPassiveUnhealthyHttpStatuses `json:"http_statuses,omitempty"`

	// TcpFailures Number of TCP connection failures to consider a target unhealthy, as observed by passive health checks.
	TcpFailures *int `json:"tcp_failures,omitempty"`

	// Timeouts Number of timeouts in proxied traffic to consider a target unhealthy, as observed by passive health checks.
	Timeouts *int `json:"timeouts,omitempty"`
}

// CreateUpstreamRequestHealthchecksPassiveUnhealthyHttpStatuses defines model for CreateUpstreamRequestHealthchecksPassiveUnhealthy.HttpStatuses.
type CreateUpstreamRequestHealthchecksPassiveUnhealthyHttpStatuses int

// CreateVaultRequest defines model for create_vault_request.
type CreateVaultRequest struct {
	// Config The configuration properties for the Vault which can be found on the vaults' documentation page.
	Config *CreateVaultRequestConfig `json:"config,omitempty"`

	// Description The description of the Vault object.
	Description *string `json:"description,omitempty"`

	// Name The name of the Vault that's going to be added. Currently, the Vault implementation must be installed in every Kong instance.
	Name *string `json:"name,omitempty"`

	// Prefix The unique prefix (or identifier) for this Vault configuration. The prefix is used to load the right Vault configuration and implementation when referencing secrets with the other entities.
	Prefix *string `json:"prefix,omitempty"`

	// Tags An optional set of strings associated with the Vault for grouping and filtering.
	Tags *[]string `json:"tags,omitempty"`
}

// CreateVaultRequestConfig The configuration properties for the Vault which can be found on the vaults' documentation page.
type CreateVaultRequestConfig struct {
	Prefix *string `json:"prefix,omitempty"`
}

// GeInfo200Response defines model for geInfo_200_response.
type GeInfo200Response struct {
	// Configuration A sanitized version of the Kong configuration, excluding sensitive values.
	Configuration *map[string]interface{} `json:"configuration,omitempty"`

	// Edition Indicates whether the Kong instance is the Community or Enterprise edition.
	Edition *string `json:"edition,omitempty"`

	// Hostname The hostname of the Kong node.
	Hostname *string `json:"hostname,omitempty"`

	// LuaVersion The version of Lua used by the Kong instance.
	LuaVersion *string `json:"lua_version,omitempty"`

	// NodeId A unique identifier for the node, in UUID format.
	NodeId *openapi_types.UUID `json:"node_id,omitempty"`

	// Pids Process IDs for the master process and worker processes.
	Pids *GeInfo200ResponsePids `json:"pids,omitempty"`

	// Plugins Information about plugins.
	Plugins *GeInfo200ResponsePlugins `json:"plugins,omitempty"`

	// Tagline A tagline or slogan for the Kong instance.
	Tagline *string `json:"tagline,omitempty"`

	// Timers Information about running and pending timers.
	Timers *GeInfo200ResponseTimers `json:"timers,omitempty"`

	// Version The version number of the Kong instance.
	Version *string `json:"version,omitempty"`
}

// GeInfo200ResponsePids Process IDs for the master process and worker processes.
type GeInfo200ResponsePids struct {
	// Master The PID of the master process.
	Master *int `json:"master,omitempty"`

	// Workers An array of worker process PIDs.
	Workers *[]int `json:"workers,omitempty"`
}

// GeInfo200ResponsePlugins Information about plugins.
type GeInfo200ResponsePlugins struct {
	AvailableOnServer *map[string]GeInfo200ResponsePluginsAvailableOnServerValue `json:"available_on_server,omitempty"`

	// EnabledInCluster A list of distinct plugin names enabled in the cluster.
	EnabledInCluster *[]string `json:"enabled_in_cluster,omitempty"`
}

// GeInfo200ResponsePluginsAvailableOnServerValue defines model for geInfo_200_response_plugins_available_on_server_value.
type GeInfo200ResponsePluginsAvailableOnServerValue struct {
	// Priority The priority of the plugin.
	Priority *int `json:"priority,omitempty"`

	// Version The version of the plugin.
	Version *string `json:"version,omitempty"`
}

// GeInfo200ResponseTimers Information about running and pending timers.
type GeInfo200ResponseTimers struct {
	// Pending The number of pending timers.
	Pending *int `json:"pending,omitempty"`

	// Running The number of running timers.
	Running *int `json:"running,omitempty"`
}

// GetCacheByKey200Response defines model for getCacheByKey_200_response.
type GetCacheByKey200Response struct {
	// Message Cached value or a message.
	Message *string `json:"message,omitempty"`

	// Ttl Time-to-live (TTL) of the cached entry.
	Ttl *int `json:"ttl,omitempty"`
}

// GetCacheByKey404Response defines model for getCacheByKey_404_response.
type GetCacheByKey404Response struct {
	Message *string `json:"message,omitempty"`
}

// GetDataPlaneStatus200ResponseValue defines model for getDataPlaneStatus_200_response_value.
type GetDataPlaneStatus200ResponseValue struct {
	// ConfigHash Hash of the configuration running on the data plane.
	ConfigHash *string `json:"config_hash,omitempty"`

	// Hostname Hostname of the data plane.
	Hostname *string `json:"hostname,omitempty"`

	// Ip The IP address of the data plane.
	Ip *string `json:"ip,omitempty"`

	// LastSeen Unix timestamp of the last interaction between the data plane and control plane.
	LastSeen *int `json:"last_seen,omitempty"`
}

// GetDataPlanes200Response defines model for getDataPlanes_200_response.
type GetDataPlanes200Response struct {
	Data *[]GetDataPlanes200ResponseDataInner `json:"data,omitempty"`
}

// GetDataPlanes200ResponseDataInner defines model for getDataPlanes_200_response_data_inner.
type GetDataPlanes200ResponseDataInner struct {
	CertDetails *GetDataPlanes200ResponseDataInnerCertDetails `json:"cert_details,omitempty"`

	// ConfigHash The hash of the current configuration on the data plane.
	ConfigHash *string `json:"config_hash,omitempty"`

	// Hostname The hostname of the data plane.
	Hostname *string `json:"hostname,omitempty"`

	// Id Unique identifier of the data plane.
	Id *string `json:"id,omitempty"`

	// Ip The IP address of the data plane.
	Ip *string `json:"ip,omitempty"`

	// Labels Metadata labels attached to the data plane.
	Labels *GetDataPlanes200ResponseDataInnerLabels `json:"labels,omitempty"`

	// LastSeen Unix timestamp when the data plane was last seen by the control plane.
	LastSeen *int `json:"last_seen,omitempty"`

	// SyncStatus The sync status of the data plane.
	SyncStatus *string `json:"sync_status,omitempty"`

	// Ttl Time-to-live for the connection.
	Ttl *int `json:"ttl,omitempty"`

	// UpdatedAt Unix timestamp of the last update.
	UpdatedAt *int `json:"updated_at,omitempty"`

	// Version The version of Kong running on the data plane.
	Version *string `json:"version,omitempty"`
}

// GetDataPlanes200ResponseDataInnerCertDetails defines model for getDataPlanes_200_response_data_inner_cert_details.
type GetDataPlanes200ResponseDataInnerCertDetails struct {
	// ExpiryTimestamp Timestamp for when the certificate expires.
	ExpiryTimestamp *int `json:"expiry_timestamp,omitempty"`
}

// GetDataPlanes200ResponseDataInnerLabels Metadata labels attached to the data plane.
type GetDataPlanes200ResponseDataInnerLabels struct {
	// Deployment The deployment name.
	Deployment *string `json:"deployment,omitempty"`

	// Region The region of the data plane.
	Region *string `json:"region,omitempty"`
}

// GetDataPlanes400Response defines model for getDataPlanes_400_response.
type GetDataPlanes400Response struct {
	Message *string `json:"message,omitempty"`
}

// GetDnsStatus200Response defines model for getDnsStatus_200_response.
type GetDnsStatus200Response struct {
	// Stats DNS stats information (specific details depend on the Kong instance).
	Stats *map[string]interface{} `json:"stats,omitempty"`

	// Worker Worker information.
	Worker *GetDnsStatus200ResponseWorker `json:"worker,omitempty"`
}

// GetDnsStatus200ResponseWorker Worker information.
type GetDnsStatus200ResponseWorker struct {
	// Count The total number of workers.
	Count *int `json:"count,omitempty"`

	// Id The worker ID.
	Id *int `json:"id,omitempty"`
}

// GetDnsStatus501Response defines model for getDnsStatus_501_response.
type GetDnsStatus501Response struct {
	// Message Message indicating that the endpoint is not implemented with the legacy DNS client.
	Message *string `json:"message,omitempty"`
}

// GetDebugNodeLogLevel200Response defines model for get_debug_node_log_level_200_response.
type GetDebugNodeLogLevel200Response struct {
	// Message A message containing the current log level of the node.
	Message *string `json:"message,omitempty"`
}

// GetEndpoints200Response defines model for get_endpoints_200_response.
type GetEndpoints200Response struct {
	Data *[]string `json:"data,omitempty"`
}

// GetSchemasEntity200Response defines model for get_schemas_entity_200_response.
type GetSchemasEntity200Response struct {
	// Fields A value of a schema
	Fields *[]GetSchemasEntity200ResponseFieldsInner `json:"fields,omitempty"`
}

// GetSchemasEntity200ResponseFieldsInner defines model for get_schemas_entity_200_response_fields_inner.
type GetSchemasEntity200ResponseFieldsInner struct {
	// Id A value of a schema
	Id *GetSchemasEntity200ResponseFieldsInnerId `json:"id,omitempty"`
}

// GetSchemasEntity200ResponseFieldsInnerId A value of a schema
type GetSchemasEntity200ResponseFieldsInnerId struct {
	// Auto A value of a schema
	Auto *bool `json:"auto,omitempty"`

	// Type A value of a schema
	Type *string `json:"type,omitempty"`

	// Uuid A value of a schema
	Uuid *bool `json:"uuid,omitempty"`
}

// GetSniWithCertificate200Response defines model for get_sni_with_certificate_200_response.
type GetSniWithCertificate200Response struct {
	// Data Array of SNIs
	Data *[]GetSniWithCertificate200ResponseDataInner `json:"data,omitempty"`

	// Next Offset is used to paginate through the API. Provide this value to the next list operation to fetch the next page
	Next *string `json:"next,omitempty"`
}

// GetSniWithCertificate200ResponseDataInner defines model for get_sni_with_certificate_200_response_data_inner.
type GetSniWithCertificate200ResponseDataInner struct {
	// Certificate The id (a UUID) of the certificate with which to associate the SNI hostname. The Certificate must have a valid private key associated with it to be used by the SNI object.
	Certificate *GetSniWithCertificate200ResponseDataInnerCertificate `json:"certificate,omitempty"`

	// CreatedAt Unix epoch when the resource was created.
	CreatedAt *int `json:"created_at,omitempty"`

	// Id The unique identifier or the name attribute of the Certificate whose SNIs are to be retrieved. When using this endpoint, only SNIs associated to the specified Certificate will be listed.
	Id *string `json:"id,omitempty"`

	// Name The SNI name to associate with the given certificate.
	Name *string `json:"name,omitempty"`

	// Tags An optional set of strings associated with the SNIs for grouping and filtering.
	Tags *[]string `json:"tags,omitempty"`
}

// GetSniWithCertificate200ResponseDataInnerCertificate The id (a UUID) of the certificate with which to associate the SNI hostname. The Certificate must have a valid private key associated with it to be used by the SNI object.
type GetSniWithCertificate200ResponseDataInnerCertificate struct {
	// Id The unique identifier or the name attribute of the Certificate whose SNIs
	Id *string `json:"id,omitempty"`
}

// GetStatus200Response defines model for get_status_200_response.
type GetStatus200Response struct {
	// Database Metrics about the database
	Database *GetStatus200ResponseDatabase `json:"database,omitempty"`

	// Memory Metrics about the memory usage.
	Memory *GetStatus200ResponseMemory `json:"memory,omitempty"`

	// Server Metrics about the nginx HTTP/S server
	Server *GetStatus200ResponseServer `json:"server,omitempty"`
}

// GetStatus200ResponseDatabase Metrics about the database
type GetStatus200ResponseDatabase struct {
	// Reachable A boolean value reflecting the state of the database connection. Please note that this flag does not reflect the health of the database itself.
	Reachable *bool `json:"reachable,omitempty"`
}

// GetStatus200ResponseMemory Metrics about the memory usage.
type GetStatus200ResponseMemory struct {
	// LuaSharedDicts An array of information about dictionaries that are shared with all workers in a Kong node, where each array node contains how much memory is dedicated for the specific shared dictionary (capacity) and how much of said memory is in use (allocated_slabs).
	LuaSharedDicts *GetStatus200ResponseMemoryLuaSharedDicts `json:"lua_shared_dicts,omitempty"`

	// WorkersLuaVms An array with all workers of the Kong node, each entry contains a `http_allocated_gc` string and a `pid`.
	WorkersLuaVms *[]GetStatus200ResponseMemoryWorkersLuaVmsInner `json:"workers_lua_vms,omitempty"`
}

// GetStatus200ResponseMemoryLuaSharedDicts An array of information about dictionaries that are shared with all workers in a Kong node, where each array node contains how much memory is dedicated for the specific shared dictionary (capacity) and how much of said memory is in use (allocated_slabs).
type GetStatus200ResponseMemoryLuaSharedDicts struct {
	KongCoreDbCache *GetStatus200ResponseMemoryLuaSharedDictsKongCoreDbCache `json:"kong_core_db_cache,omitempty"`
}

// GetStatus200ResponseMemoryLuaSharedDictsKongCoreDbCache defines model for get_status_200_response_memory_lua_shared_dicts_kong_core_db_cache.
type GetStatus200ResponseMemoryLuaSharedDictsKongCoreDbCache struct {
	// AllocatedSlabs Total allocated memory
	AllocatedSlabs *string `json:"allocated_slabs,omitempty"`

	// Capacity Memory capacity
	Capacity *string `json:"capacity,omitempty"`
}

// GetStatus200ResponseMemoryWorkersLuaVmsInner defines model for get_status_200_response_memory_workers_lua_vms_inner.
type GetStatus200ResponseMemoryWorkersLuaVmsInner struct {
	// HttpAllocatedGc HTTP submodule's Lua virtual machine's memory usage information, as reported by
	HttpAllocatedGc *string `json:"http_allocated_gc,omitempty"`

	// Pid worker's process identification number.
	Pid *int `json:"pid,omitempty"`
}

// GetStatus200ResponseServer Metrics about the nginx HTTP/S server
type GetStatus200ResponseServer struct {
	// ConnectionsAccepted The total number of accepted client connections.
	ConnectionsAccepted *int `json:"connections_accepted,omitempty"`

	// ConnectionsActive The current number of active client connections including Waiting connections.
	ConnectionsActive *int `json:"connections_active,omitempty"`

	// ConnectionsHandled The total number of handled connections. Generally, the parameter value is the same as accepts unless some resource limits have been reached.
	ConnectionsHandled *int `json:"connections_handled,omitempty"`

	// ConnectionsReading The current number of connections where Kong is reading the request header.
	ConnectionsReading *int `json:"connections_reading,omitempty"`

	// ConnectionsWaiting The current number of idle client connections waiting for a request.
	ConnectionsWaiting *int `json:"connections_waiting,omitempty"`

	// ConnectionsWriting The current number of connections where nginx is writing the response back to the client.
	ConnectionsWriting *int `json:"connections_writing,omitempty"`

	// TotalRequests The total number of client requests.
	TotalRequests *int `json:"total_requests,omitempty"`
}

// GetTags200Response defines model for get_tags_200_response.
type GetTags200Response struct {
	Data *[]GetTags200ResponseDataInner `json:"data,omitempty"`

	// Next Pagination information
	Next *string `json:"next,omitempty"`

	// Offset Pagination information
	Offset *string `json:"offset,omitempty"`
}

// GetTags200ResponseDataInner defines model for get_tags_200_response_data_inner.
type GetTags200ResponseDataInner struct {
	// EntityId The unique ID for the entity that is attached to the tag
	EntityId *string `json:"entity_id,omitempty"`

	// EntityName The name of the entity that corresponds to a tag
	EntityName *string `json:"entity_name,omitempty"`

	// Tag The tag
	Tag *string `json:"tag,omitempty"`
}

// GetTimers200Response defines model for get_timers_200_response.
type GetTimers200Response struct {
	// Stats Statistics about the worker
	Stats  *GetTimers200ResponseStats  `json:"stats,omitempty"`
	Worker *GetTimers200ResponseWorker `json:"worker,omitempty"`
}

// GetTimers200ResponseStats Statistics about the worker
type GetTimers200ResponseStats struct {
	// Flamegraph String-encoded timer-related flamegraph data
	Flamegraph *GetTimers200ResponseStatsFlamegraph `json:"flamegraph,omitempty"`

	// Sys List of the number of different type of timers
	Sys *GetTimers200ResponseStatsSys `json:"sys,omitempty"`

	// Timers Timer statistics for the worker
	Timers *GetTimers200ResponseStatsTimers `json:"timers,omitempty"`
}

// GetTimers200ResponseStatsFlamegraph String-encoded timer-related flamegraph data
type GetTimers200ResponseStatsFlamegraph struct {
	// ElapsedTime The elapsed time for the flamegraph
	ElapsedTime *string `json:"elapsed_time,omitempty"`

	// Pending The number of pending timers for the flamegraph
	Pending *string `json:"pending,omitempty"`

	// Running The number of running timers for the flamegraph
	Running *string `json:"running,omitempty"`
}

// GetTimers200ResponseStatsSys List of the number of different type of timers
type GetTimers200ResponseStatsSys struct {
	// Pending The number of pending timers
	Pending *int `json:"pending,omitempty"`

	// Running The number of running timers
	Running *int `json:"running,omitempty"`

	// Runs The total number of runs for the timers
	Runs *int `json:"runs,omitempty"`

	// Total The total number of timers (running + pending + waiting)
	Total *int `json:"total,omitempty"`

	// Waiting The number of unexpired timers
	Waiting *int `json:"waiting,omitempty"`
}

// GetTimers200ResponseStatsTimers Timer statistics for the worker
type GetTimers200ResponseStatsTimers struct {
	// Meta Program callstack of created timers
	Meta *GetTimers200ResponseStatsTimersMeta `json:"meta,omitempty"`
}

// GetTimers200ResponseStatsTimersMeta Program callstack of created timers
type GetTimers200ResponseStatsTimersMeta struct {
	// Name The name of the timer's metadata
	Name *string `json:"name,omitempty"`
}

// GetTimers200ResponseWorker defines model for get_timers_200_response_worker.
type GetTimers200ResponseWorker struct {
	// Count The total number of the Nginx worker processes.
	Count *int `json:"count,omitempty"`

	// Id The ordinal number of the current Nginx worker processes (starting from number 0).
	Id *int `json:"id,omitempty"`
}

// ListCertificate200Response defines model for list_certificate_200_response.
type ListCertificate200Response struct {
	Data *[]Certificate `json:"data,omitempty"`

	// Offset Offset is used to paginate through the API. Provide this value to the next list operation to fetch the next page
	Offset *string `json:"offset,omitempty"`
}

// ListConsumer200Response defines model for list_consumer_200_response.
type ListConsumer200Response struct {
	Data *[]Consumer `json:"data,omitempty"`

	// Offset Offset is used to paginate through the API. Provide this value to the next list operation to fetch the next page
	Offset *string `json:"offset,omitempty"`
}

// ListKey200Response defines model for list_key_200_response.
type ListKey200Response struct {
	Data *[]Key `json:"data,omitempty"`

	// Offset Offset is used to paginate through the API. Provide this value to the next list operation to fetch the next page
	Offset *string `json:"offset,omitempty"`
}

// ListKeySet200Response defines model for list_key_set_200_response.
type ListKeySet200Response struct {
	// CreatedAt Unix epoch when the resource was last created.
	CreatedAt *int    `json:"created_at,omitempty"`
	Id        *string `json:"id,omitempty"`

	// Name The name to associate with the given key-set.
	Name *string `json:"name,omitempty"`

	// Next Offset is used to paginate through the API. Provide this value to the next list operation to fetch the next page
	Next *string `json:"next,omitempty"`

	// Tags The name to associate with the given key-set.
	Tags *[]string `json:"tags,omitempty"`

	// UpdatedAt Unix epoch when the resource was last updated.
	UpdatedAt *int `json:"updated_at,omitempty"`
}

// ListPluginsForConsumer200Response defines model for list_plugins_for_consumer_200_response.
type ListPluginsForConsumer200Response struct {
	// Config The configuration properties for the Plugin
	Config *ListPluginsForConsumer200ResponseConfig `json:"config,omitempty"`

	// Consumer If set, the plugin will activate only for requests where the specified has been authenticated. (Note that some plugins can not be restricted to consumers this way.)
	Consumer *string `json:"consumer"`

	// CreatedAt Unix epoch when the resource was created.
	CreatedAt *int `json:"created_at,omitempty"`

	// Enabled Whether the plugin is applied. Default: `true`.
	Enabled *bool   `json:"enabled,omitempty"`
	Id      *string `json:"id,omitempty"`

	// InstanceName An optional custom name to identify an instance of the plugin, for example `basic-auth_example-service`.
	//
	// The instance name shows up in Kong Manager, so it's useful when running the same
	// plugin in multiple contexts, for example, on multiple services. You can also use it to access a specific plugin instance
	// via the Kong Admin API.
	//
	// An instance name must be unique globally for Kong Gateway OSS.
	InstanceName *string `json:"instance_name,omitempty"`

	// Name The name of the Plugin that's going to be added. Currently, the Plugin must be installed in every Kong instance separately.
	Name *string `json:"name,omitempty"`

	// Protocols A list of the request protocols that will trigger this plugin.
	Protocols *[]ListPluginsForConsumer200ResponseProtocols `json:"protocols,omitempty"`

	// Route If set, the plugin will only activate when receiving requests via the specified route. Leave unset for the plugin to activate regardless of the route being used. With form-encoded, the notation is `route.id=<route id> or route.name=<route name>`. With JSON, use `"route":{"id":"<route id>"}` or `"route":{"name":"<route name>"}`.
	Route *string `json:"route"`

	// Service If set, the plugin will only activate when receiving requests via one of the routes belonging to the specified service.
	Service *string `json:"service"`

	// Tags An optional set of strings associated with the Plugin for grouping and filtering.
	Tags *[]string `json:"tags,omitempty"`
}

// ListPluginsForConsumer200ResponseProtocols defines model for ListPluginsForConsumer200Response.Protocols.
type ListPluginsForConsumer200ResponseProtocols string

// ListPluginsForConsumer200ResponseConfig The configuration properties for the Plugin
type ListPluginsForConsumer200ResponseConfig struct {
	Hour   *int `json:"hour,omitempty"`
	Minute *int `json:"minute,omitempty"`
}

// ListPluginsForRoute200Response defines model for list_plugins_for_route_200_response.
type ListPluginsForRoute200Response struct {
	Data *[]Plugin `json:"data,omitempty"`

	// Offset Offset is used to paginate through the API. Provide this value to the next list operation to fetch the next page
	Offset *string `json:"offset,omitempty"`
}

// ListRoute200Response defines model for list_route_200_response.
type ListRoute200Response struct {
	Data *[]Route `json:"data,omitempty"`

	// Offset Offset is used to paginate through the API. Provide this value to the next list operation to fetch the next page
	Offset *string `json:"offset,omitempty"`
}

// ListTargetsForUpstream200Response defines model for list_targets_for_upstream_200_response.
type ListTargetsForUpstream200Response struct {
	Data *[]Target `json:"data,omitempty"`

	// Offset Offset is used to paginate through the API. Provide this value to the next list operation to fetch the next page
	Offset *string `json:"offset,omitempty"`
}

// ListUpstream200Response defines model for list_upstream_200_response.
type ListUpstream200Response struct {
	Data *[]Upstream `json:"data,omitempty"`

	// Offset Offset is used to paginate through the API. Provide this value to the next list operation to fetch the next page
	Offset *string `json:"offset,omitempty"`
}

// ListVault200Response defines model for list_vault_200_response.
type ListVault200Response struct {
	Data *[]Vault `json:"data,omitempty"`

	// Offset Offset is used to paginate through the API. Provide this value to the next list operation to fetch the next page
	Offset *string `json:"offset,omitempty"`
}

// PostFilterChainsRequest defines model for post_filter_chains_request.
type PostFilterChainsRequest struct {
	// Enabled Whether the filter chain is applied.
	Enabled *bool `json:"enabled,omitempty"`

	// Filters An array of filter definitions that will be executed in order.
	Filters *[]PostFilterChainsRequestFiltersInner `json:"filters,omitempty"`
	Id      *string                                `json:"id,omitempty"`

	// Name The name of the filter chain.
	Name *string `json:"name,omitempty"`

	// Route The route to which this chain is applied. A filter chain must be applied to either a single route or a single service.
	Route *PostFilterChainsRequestRoute `json:"route,omitempty"`

	// Service The service to which this chain is applied. A filter chain must be applied to either a single route or a single service.
	Service *PostFilterChainsRequestService `json:"service,omitempty"`

	// Tags An optional set of strings associated with the Filter Chain for grouping and filtering.
	Tags *[]string `json:"tags,omitempty"`
}

// PostFilterChainsRequestFiltersInner defines model for post_filter_chains_request_filters_inner.
type PostFilterChainsRequestFiltersInner struct {
	// Config The configuration for the filter. Proxy-Wasm does not define a configuration format, so this field is a raw string, intended to contain the configuration in the format expected by the particular filter in use.
	Config *string `json:"config,omitempty"`

	// Enabled Whether the filter is to be applied.
	Enabled *bool `json:"enabled,omitempty"`

	// Name The name of the filter. This name matches the basename of the WebAssembly module file: for a filter file called `my-filter.wasm`, then filter name will be `my-filter`.
	Name *string `json:"name,omitempty"`
}

// PostFilterChainsRequestRoute The route to which this chain is applied. A filter chain must be applied to either a single route or a single service.
type PostFilterChainsRequestRoute struct {
	Id *string `json:"id,omitempty"`
}

// PostFilterChainsRequestService The service to which this chain is applied. A filter chain must be applied to either a single route or a single service.
type PostFilterChainsRequestService struct {
	Id *string `json:"id,omitempty"`
}

// PostSchemasEntityValidate200Response defines model for post_schemas_entity_validate_200_response.
type PostSchemasEntityValidate200Response struct {
	// Message A success message
	Message *string `json:"Message,omitempty"`
}

// PostSchemasPluginsValidate200Response defines model for post_schemas_plugins_validate_200_response.
type PostSchemasPluginsValidate200Response struct {
	// Message A successful message
	Message *string `json:"message,omitempty"`
}

// PostSchemasVaultsValidate200Response defines model for post_schemas_vaults_validate_200_response.
type PostSchemasVaultsValidate200Response struct {
	// Validation Indicates if the schema is valid
	Validation *bool `json:"validation,omitempty"`
}

// PostSchemasVaultsValidateRequest defines model for post_schemas_vaults_validate_request.
type PostSchemasVaultsValidateRequest struct {
	// SchemaData JSON string containing the vault schema data
	SchemaData *string `json:"schemaData,omitempty"`
}

// PutDebugClusterControlPlanesNodesLogLevelLogLevel200Response defines model for put_debug_cluster_control_planes_nodes_log_level_log_level_200_response.
type PutDebugClusterControlPlanesNodesLogLevelLogLevel200Response struct {
	// Message Response message
	Message *string `json:"message,omitempty"`
}

// PutDebugClusterLogLevelLogLevel200Response defines model for put_debug_cluster_log_level_log_level_200_response.
type PutDebugClusterLogLevelLogLevel200Response struct {
	// Message A message containing information about the log level
	Message *string `json:"message,omitempty"`
}

// PutDebugNodeLogLevelLogLevel200Response defines model for put_debug_node_log_level_log_level_200_response.
type PutDebugNodeLogLevelLogLevel200Response struct {
	// Message A message confirming the log level change
	Message *string `json:"message,omitempty"`
}

// UpsertConsumer200Response defines model for upsert_consumer_200_response.
type UpsertConsumer200Response struct {
	Data *[]UpsertConsumer200ResponseDataInner `json:"data,omitempty"`

	// Next Pagination information
	Next *string `json:"next,omitempty"`
}

// UpsertConsumer200ResponseDataInner defines model for upsert_consumer_200_response_data_inner.
type UpsertConsumer200ResponseDataInner struct {
	// CreatedAt Unix epoch when the resource was created.
	CreatedAt *int `json:"created_at,omitempty"`

	// CustomId Field for storing an existing unique ID for the Consumer - useful for mapping Kong with users in your existing database.
	CustomId *string `json:"custom_id,omitempty"`

	// Id The unique identifier or the name attribute of the consumer.
	Id *string `json:"id,omitempty"`

	// Tags An optional set of strings associated with the Consumer for grouping and filtering.
	Tags *[]string `json:"tags,omitempty"`

	// Username The unique username of the consumer. You must send either this field or` custom_i`d with the request.
	Username *string `json:"username,omitempty"`
}

// CACertRequest defines model for CA-cert-request.
type CACertRequest = CreateCaCertificateRequest

// CertRequest defines model for cert-request.
type CertRequest = CreateCertificateRequest

// ConsumerRequest defines model for consumer-request.
type ConsumerRequest = CreateConsumerRequest

// CreateSni defines model for create-sni.
type CreateSni = CreateSniForCertificateRequest

// FilterChainsRequest defines model for filter-chains-request.
type FilterChainsRequest = PostFilterChainsRequest

// KeySetRequest defines model for key-set-request.
type KeySetRequest = CreateKeySetRequest

// KeysRequest defines model for keys-request.
type KeysRequest = CreateKeyRequest

// PluginRequest defines model for plugin-request.
type PluginRequest = CreatePluginForConsumerRequest

// RouteRequest defines model for route-request.
type RouteRequest = CreateRouteRequest

// ServiceRequest defines model for service-request.
type ServiceRequest = CreateServiceRequest

// TargetRequest defines model for target-request.
type TargetRequest = CreateTargetForUpstreamRequest

// UpstreamRequest defines model for upstream-request.
type UpstreamRequest = CreateUpstreamRequest

// VaultRequest defines model for vault-request.
type VaultRequest = CreateVaultRequest

// ListCaCertificateParams defines parameters for ListCaCertificate.
type ListCaCertificateParams struct {
	// Size Number of resources to be returned.
	Size *int `form:"size,omitempty" json:"size,omitempty"`

	// Offset Offset from which to return the next set of resources. Use the value of the 'offset' field from the response of a list operation as input here to paginate through all the resources
	Offset *string `form:"offset,omitempty" json:"offset,omitempty"`

	// Tags A list of tags to filter the list of resources on. Multiple tags can be concatenated using ','' to mean AND or using ''/'' to mean OR.'
	Tags *string `form:"tags,omitempty" json:"tags,omitempty"`
}

// ListCertificateParams defines parameters for ListCertificate.
type ListCertificateParams struct {
	// Size Number of resources to be returned.
	Size *int `form:"size,omitempty" json:"size,omitempty"`

	// Offset Offset from which to return the next set of resources. Use the value of the 'offset' field from the response of a list operation as input here to paginate through all the resources
	Offset *string `form:"offset,omitempty" json:"offset,omitempty"`

	// Tags A list of tags to filter the list of resources on. Multiple tags can be concatenated using ','' to mean AND or using ''/'' to mean OR.'
	Tags *string `form:"tags,omitempty" json:"tags,omitempty"`
}

// GetSniWithCertificateParams defines parameters for GetSniWithCertificate.
type GetSniWithCertificateParams struct {
	// Size Number of resources to be returned.
	Size *int `form:"size,omitempty" json:"size,omitempty"`

	// Offset Offset from which to return the next set of resources. Use the value of the 'offset' field from the response of a list operation as input here to paginate through all the resources
	Offset *string `form:"offset,omitempty" json:"offset,omitempty"`

	// Tags A list of tags to filter the list of resources on. Multiple tags can be concatenated using ','' to mean AND or using ''/'' to mean OR.'
	Tags *string `form:"tags,omitempty" json:"tags,omitempty"`
}

// GetSniWithCertificateParamsCertificateNameOrId defines parameters for GetSniWithCertificate.
type GetSniWithCertificateParamsCertificateNameOrId string

// CreateSniForCertificateParamsCertificateNameOrId defines parameters for CreateSniForCertificate.
type CreateSniForCertificateParamsCertificateNameOrId string

// ListConsumerParams defines parameters for ListConsumer.
type ListConsumerParams struct {
	// Size Number of resources to be returned.
	Size *int `form:"size,omitempty" json:"size,omitempty"`

	// Offset Offset from which to return the next set of resources. Use the value of the 'offset' field from the response of a list operation as input here to paginate through all the resources
	Offset *string `form:"offset,omitempty" json:"offset,omitempty"`

	// Tags A list of tags to filter the list of resources on. Multiple tags can be concatenated using ','' to mean AND or using ''/'' to mean OR.'
	Tags *string `form:"tags,omitempty" json:"tags,omitempty"`
}

// ListPluginsForConsumerParams defines parameters for ListPluginsForConsumer.
type ListPluginsForConsumerParams struct {
	// Size Number of resources to be returned.
	Size *int `form:"size,omitempty" json:"size,omitempty"`

	// Offset Offset from which to return the next set of resources. Use the value of the 'offset' field from the response of a list operation as input here to paginate through all the resources
	Offset *string `form:"offset,omitempty" json:"offset,omitempty"`

	// Tags A list of tags to filter the list of resources on. Multiple tags can be concatenated using ','' to mean AND or using ''/'' to mean OR.'
	Tags *string `form:"tags,omitempty" json:"tags,omitempty"`
}

// PutDebugClusterControlPlanesNodesLogLevelLogLevelParamsLogLevel defines parameters for PutDebugClusterControlPlanesNodesLogLevelLogLevel.
type PutDebugClusterControlPlanesNodesLogLevelLogLevelParamsLogLevel string

// PutDebugClusterLogLevelLogLevelParamsLogLevel defines parameters for PutDebugClusterLogLevelLogLevel.
type PutDebugClusterLogLevelLogLevelParamsLogLevel string

// PutDebugNodeLogLevelLogLevelParamsLogLevel defines parameters for PutDebugNodeLogLevelLogLevel.
type PutDebugNodeLogLevelLogLevelParamsLogLevel string

// ListKeySetParams defines parameters for ListKeySet.
type ListKeySetParams struct {
	// Size Number of resources to be returned.
	Size *int `form:"size,omitempty" json:"size,omitempty"`

	// Offset Offset from which to return the next set of resources. Use the value of the 'offset' field from the response of a list operation as input here to paginate through all the resources
	Offset *string `form:"offset,omitempty" json:"offset,omitempty"`

	// Tags A list of tags to filter the list of resources on. Multiple tags can be concatenated using ','' to mean AND or using ''/'' to mean OR.'
	Tags *string `form:"tags,omitempty" json:"tags,omitempty"`
}

// ListKeyParams defines parameters for ListKey.
type ListKeyParams struct {
	// Size Number of resources to be returned.
	Size *int `form:"size,omitempty" json:"size,omitempty"`

	// Offset Offset from which to return the next set of resources. Use the value of the 'offset' field from the response of a list operation as input here to paginate through all the resources
	Offset *string `form:"offset,omitempty" json:"offset,omitempty"`

	// Tags A list of tags to filter the list of resources on. Multiple tags can be concatenated using ','' to mean AND or using ''/'' to mean OR.'
	Tags *string `form:"tags,omitempty" json:"tags,omitempty"`
}

// ListPluginParams defines parameters for ListPlugin.
type ListPluginParams struct {
	// Size Number of resources to be returned.
	Size *int `form:"size,omitempty" json:"size,omitempty"`

	// Offset Offset from which to return the next set of resources. Use the value of the 'offset' field from the response of a list operation as input here to paginate through all the resources
	Offset *string `form:"offset,omitempty" json:"offset,omitempty"`

	// Tags A list of tags to filter the list of resources on. Multiple tags can be concatenated using ','' to mean AND or using ''/'' to mean OR.'
	Tags *string `form:"tags,omitempty" json:"tags,omitempty"`
}

// ListRouteParams defines parameters for ListRoute.
type ListRouteParams struct {
	// Size Number of resources to be returned.
	Size *int `form:"size,omitempty" json:"size,omitempty"`

	// Offset Offset from which to return the next set of resources. Use the value of the 'offset' field from the response of a list operation as input here to paginate through all the resources
	Offset *string `form:"offset,omitempty" json:"offset,omitempty"`

	// Tags A list of tags to filter the list of resources on. Multiple tags can be concatenated using ','' to mean AND or using ''/'' to mean OR.'
	Tags *string `form:"tags,omitempty" json:"tags,omitempty"`
}

// ListPluginsForRouteParams defines parameters for ListPluginsForRoute.
type ListPluginsForRouteParams struct {
	// Size Number of resources to be returned.
	Size *int `form:"size,omitempty" json:"size,omitempty"`

	// Offset Offset from which to return the next set of resources. Use the value of the 'offset' field from the response of a list operation as input here to paginate through all the resources
	Offset *string `form:"offset,omitempty" json:"offset,omitempty"`

	// Tags A list of tags to filter the list of resources on. Multiple tags can be concatenated using ','' to mean AND or using ''/'' to mean OR.'
	Tags *string `form:"tags,omitempty" json:"tags,omitempty"`
}

// ListServiceParams defines parameters for ListService.
type ListServiceParams struct {
	// Size Number of resources to be returned.
	Size *int `form:"size,omitempty" json:"size,omitempty"`

	// Offset Offset from which to return the next set of resources. Use the value of the 'offset' field from the response of a list operation as input here to paginate through all the resources
	Offset *string `form:"offset,omitempty" json:"offset,omitempty"`

	// Tags A list of tags to filter the list of resources on. Multiple tags can be concatenated using ','' to mean AND or using ''/'' to mean OR.'
	Tags *string `form:"tags,omitempty" json:"tags,omitempty"`
}

// ListRoutesForServiceParams defines parameters for ListRoutesForService.
type ListRoutesForServiceParams struct {
	// Size Number of resources to be returned.
	Size *int `form:"size,omitempty" json:"size,omitempty"`

	// Offset Offset from which to return the next set of resources. Use the value of the 'offset' field from the response of a list operation as input here to paginate through all the resources
	Offset *string `form:"offset,omitempty" json:"offset,omitempty"`

	// Tags A list of tags to filter the list of resources on. Multiple tags can be concatenated using ','' to mean AND or using ''/'' to mean OR.'
	Tags *string `form:"tags,omitempty" json:"tags,omitempty"`
}

// GetPluginsForServiceParams defines parameters for GetPluginsForService.
type GetPluginsForServiceParams struct {
	// Size Number of resources to be returned.
	Size *int `form:"size,omitempty" json:"size,omitempty"`

	// Offset Offset from which to return the next set of resources. Use the value of the 'offset' field from the response of a list operation as input here to paginate through all the resources
	Offset *string `form:"offset,omitempty" json:"offset,omitempty"`

	// Tags A list of tags to filter the list of resources on. Multiple tags can be concatenated using ','' to mean AND or using ''/'' to mean OR.'
	Tags *string `form:"tags,omitempty" json:"tags,omitempty"`
}

// ListSniParams defines parameters for ListSni.
type ListSniParams struct {
	// Size Number of resources to be returned.
	Size *int `form:"size,omitempty" json:"size,omitempty"`

	// Offset Offset from which to return the next set of resources. Use the value of the 'offset' field from the response of a list operation as input here to paginate through all the resources
	Offset *string `form:"offset,omitempty" json:"offset,omitempty"`

	// Tags A list of tags to filter the list of resources on. Multiple tags can be concatenated using ','' to mean AND or using ''/'' to mean OR.'
	Tags *string `form:"tags,omitempty" json:"tags,omitempty"`
}

// ListUpstreamParams defines parameters for ListUpstream.
type ListUpstreamParams struct {
	// Size Number of resources to be returned.
	Size *int `form:"size,omitempty" json:"size,omitempty"`

	// Offset Offset from which to return the next set of resources. Use the value of the 'offset' field from the response of a list operation as input here to paginate through all the resources
	Offset *string `form:"offset,omitempty" json:"offset,omitempty"`

	// Tags A list of tags to filter the list of resources on. Multiple tags can be concatenated using ','' to mean AND or using ''/'' to mean OR.'
	Tags *string `form:"tags,omitempty" json:"tags,omitempty"`
}

// ListTargetsForUpstreamParams defines parameters for ListTargetsForUpstream.
type ListTargetsForUpstreamParams struct {
	// Size Number of resources to be returned.
	Size *int `form:"size,omitempty" json:"size,omitempty"`

	// Offset Offset from which to return the next set of resources. Use the value of the 'offset' field from the response of a list operation as input here to paginate through all the resources
	Offset *string `form:"offset,omitempty" json:"offset,omitempty"`

	// Tags A list of tags to filter the list of resources on. Multiple tags can be concatenated using ','' to mean AND or using ''/'' to mean OR.'
	Tags *string `form:"tags,omitempty" json:"tags,omitempty"`
}

// ListVaultParams defines parameters for ListVault.
type ListVaultParams struct {
	// Size Number of resources to be returned.
	Size *int `form:"size,omitempty" json:"size,omitempty"`

	// Offset Offset from which to return the next set of resources. Use the value of the 'offset' field from the response of a list operation as input here to paginate through all the resources
	Offset *string `form:"offset,omitempty" json:"offset,omitempty"`

	// Tags A list of tags to filter the list of resources on. Multiple tags can be concatenated using ','' to mean AND or using ''/'' to mean OR.'
	Tags *string `form:"tags,omitempty" json:"tags,omitempty"`
}

// CreateCaCertificateJSONRequestBody defines body for CreateCaCertificate for application/json ContentType.
type CreateCaCertificateJSONRequestBody = CreateCaCertificateRequest

// UpdateCaCertificateJSONRequestBody defines body for UpdateCaCertificate for application/json ContentType.
type UpdateCaCertificateJSONRequestBody = CreateCaCertificateRequest

// UpdatetCaCertificateJSONRequestBody defines body for UpdatetCaCertificate for application/json ContentType.
type UpdatetCaCertificateJSONRequestBody = CreateCaCertificateRequest

// CreateCertificateJSONRequestBody defines body for CreateCertificate for application/json ContentType.
type CreateCertificateJSONRequestBody = CreateCertificateRequest

// UpdateCertificateJSONRequestBody defines body for UpdateCertificate for application/json ContentType.
type UpdateCertificateJSONRequestBody = CreateCertificateRequest

// UpdateCertificatePutJSONRequestBody defines body for UpdateCertificatePut for application/json ContentType.
type UpdateCertificatePutJSONRequestBody = CreateCertificateRequest

// UpdateSniForCertificateJSONRequestBody defines body for UpdateSniForCertificate for application/json ContentType.
type UpdateSniForCertificateJSONRequestBody = CreateSniForCertificateRequest

// UpsertSniForCertificateJSONRequestBody defines body for UpsertSniForCertificate for application/json ContentType.
type UpsertSniForCertificateJSONRequestBody = CreateSniForCertificateRequest

// CreateSniForCertificateJSONRequestBody defines body for CreateSniForCertificate for application/json ContentType.
type CreateSniForCertificateJSONRequestBody = CreateSniForCertificateRequest

// CreateConsumerJSONRequestBody defines body for CreateConsumer for application/json ContentType.
type CreateConsumerJSONRequestBody = CreateConsumerRequest

// AddConsumerToGroupJSONRequestBody defines body for AddConsumerToGroup for application/json ContentType.
type AddConsumerToGroupJSONRequestBody = ConsumerGroupRequest

// UpdateConsumerJSONRequestBody defines body for UpdateConsumer for application/json ContentType.
type UpdateConsumerJSONRequestBody = CreateConsumerRequest

// UpsertConsumerJSONRequestBody defines body for UpsertConsumer for application/json ContentType.
type UpsertConsumerJSONRequestBody = CreateConsumerRequest

// CreatePluginForConsumerJSONRequestBody defines body for CreatePluginForConsumer for application/json ContentType.
type CreatePluginForConsumerJSONRequestBody = CreatePluginForConsumerRequest

// UpdatePluginForConsumerJSONRequestBody defines body for UpdatePluginForConsumer for application/json ContentType.
type UpdatePluginForConsumerJSONRequestBody = CreatePluginForConsumerRequest

// UpsertPluginForConsumerJSONRequestBody defines body for UpsertPluginForConsumer for application/json ContentType.
type UpsertPluginForConsumerJSONRequestBody = CreatePluginForConsumerRequest

// PostFilterChainsJSONRequestBody defines body for PostFilterChains for application/json ContentType.
type PostFilterChainsJSONRequestBody = PostFilterChainsRequest

// PatchFilterChainsFilterChainIdJSONRequestBody defines body for PatchFilterChainsFilterChainId for application/json ContentType.
type PatchFilterChainsFilterChainIdJSONRequestBody = PostFilterChainsRequest

// PutFilterChainsFilterChainIdJSONRequestBody defines body for PutFilterChainsFilterChainId for application/json ContentType.
type PutFilterChainsFilterChainIdJSONRequestBody = PostFilterChainsRequest

// CreateKeySetJSONRequestBody defines body for CreateKeySet for application/json ContentType.
type CreateKeySetJSONRequestBody = CreateKeySetRequest

// UpdateKeySetJSONRequestBody defines body for UpdateKeySet for application/json ContentType.
type UpdateKeySetJSONRequestBody = CreateKeySetRequest

// UpsertKeySetJSONRequestBody defines body for UpsertKeySet for application/json ContentType.
type UpsertKeySetJSONRequestBody = CreateKeySetRequest

// CreateKeyJSONRequestBody defines body for CreateKey for application/json ContentType.
type CreateKeyJSONRequestBody = CreateKeyRequest

// UpdateKeyJSONRequestBody defines body for UpdateKey for application/json ContentType.
type UpdateKeyJSONRequestBody = CreateKeyRequest

// UpsertKeyJSONRequestBody defines body for UpsertKey for application/json ContentType.
type UpsertKeyJSONRequestBody = CreateKeyRequest

// CreatePluginJSONRequestBody defines body for CreatePlugin for application/json ContentType.
type CreatePluginJSONRequestBody = CreatePluginForConsumerRequest

// UpdatePluginJSONRequestBody defines body for UpdatePlugin for application/json ContentType.
type UpdatePluginJSONRequestBody = CreatePluginForConsumerRequest

// UpsertPluginJSONRequestBody defines body for UpsertPlugin for application/json ContentType.
type UpsertPluginJSONRequestBody = CreatePluginForConsumerRequest

// CreateRouteJSONRequestBody defines body for CreateRoute for application/json ContentType.
type CreateRouteJSONRequestBody = CreateRouteRequest

// UpdateRouteJSONRequestBody defines body for UpdateRoute for application/json ContentType.
type UpdateRouteJSONRequestBody = CreateRouteRequest

// UpsertRouteJSONRequestBody defines body for UpsertRoute for application/json ContentType.
type UpsertRouteJSONRequestBody = CreateRouteRequest

// PatchRoutesRouteIdOrNameFilterChainsJSONRequestBody defines body for PatchRoutesRouteIdOrNameFilterChains for application/json ContentType.
type PatchRoutesRouteIdOrNameFilterChainsJSONRequestBody = PostFilterChainsRequest

// GetRoutesRouteNameOrIdFilterChainsJSONRequestBody defines body for GetRoutesRouteNameOrIdFilterChains for application/json ContentType.
type GetRoutesRouteNameOrIdFilterChainsJSONRequestBody = PostFilterChainsRequest

// PutRoutesRouteIdOrNameFilterChainsFilterChainIdJSONRequestBody defines body for PutRoutesRouteIdOrNameFilterChainsFilterChainId for application/json ContentType.
type PutRoutesRouteIdOrNameFilterChainsFilterChainIdJSONRequestBody = PostFilterChainsRequest

// CreatePluginForRouteJSONRequestBody defines body for CreatePluginForRoute for application/json ContentType.
type CreatePluginForRouteJSONRequestBody = CreatePluginForConsumerRequest

// UpdatePluginForRouteJSONRequestBody defines body for UpdatePluginForRoute for application/json ContentType.
type UpdatePluginForRouteJSONRequestBody = CreatePluginForConsumerRequest

// UpsertPluginForRouteJSONRequestBody defines body for UpsertPluginForRoute for application/json ContentType.
type UpsertPluginForRouteJSONRequestBody = CreatePluginForConsumerRequest

// PostSchemasVaultsValidateJSONRequestBody defines body for PostSchemasVaultsValidate for application/json ContentType.
type PostSchemasVaultsValidateJSONRequestBody = PostSchemasVaultsValidateRequest

// CreateServiceJSONRequestBody defines body for CreateService for application/json ContentType.
type CreateServiceJSONRequestBody = CreateServiceRequest

// UpdateServiceJSONRequestBody defines body for UpdateService for application/json ContentType.
type UpdateServiceJSONRequestBody = CreateServiceRequest

// UpsertServiceJSONRequestBody defines body for UpsertService for application/json ContentType.
type UpsertServiceJSONRequestBody = CreateServiceRequest

// GetServicesServiceIdOrNameFilterChainsJSONRequestBody defines body for GetServicesServiceIdOrNameFilterChains for application/json ContentType.
type GetServicesServiceIdOrNameFilterChainsJSONRequestBody = PostFilterChainsRequest

// UpdatePluginForAServiceJSONRequestBody defines body for UpdatePluginForAService for application/json ContentType.
type UpdatePluginForAServiceJSONRequestBody = CreatePluginForConsumerRequest

// UpsertPluginForAServiceJSONRequestBody defines body for UpsertPluginForAService for application/json ContentType.
type UpsertPluginForAServiceJSONRequestBody = CreatePluginForConsumerRequest

// CreateRouteForServiceJSONRequestBody defines body for CreateRouteForService for application/json ContentType.
type CreateRouteForServiceJSONRequestBody = CreateRouteRequest

// UpdateRouteForServiceJSONRequestBody defines body for UpdateRouteForService for application/json ContentType.
type UpdateRouteForServiceJSONRequestBody = CreateRouteRequest

// UpsertRouteForServiceJSONRequestBody defines body for UpsertRouteForService for application/json ContentType.
type UpsertRouteForServiceJSONRequestBody = CreateRouteRequest

// CreatePluginForServiceJSONRequestBody defines body for CreatePluginForService for application/json ContentType.
type CreatePluginForServiceJSONRequestBody = CreatePluginForConsumerRequest

// CreateSniJSONRequestBody defines body for CreateSni for application/json ContentType.
type CreateSniJSONRequestBody = CreateSniForCertificateRequest

// UpdateSniJSONRequestBody defines body for UpdateSni for application/json ContentType.
type UpdateSniJSONRequestBody = CreateSniForCertificateRequest

// UpsertSniJSONRequestBody defines body for UpsertSni for application/json ContentType.
type UpsertSniJSONRequestBody = CreateSniForCertificateRequest

// CreateUpstreamJSONRequestBody defines body for CreateUpstream for application/json ContentType.
type CreateUpstreamJSONRequestBody = CreateUpstreamRequest

// UpdateUpstreamJSONRequestBody defines body for UpdateUpstream for application/json ContentType.
type UpdateUpstreamJSONRequestBody = CreateUpstreamRequest

// UpsertUpstreamJSONRequestBody defines body for UpsertUpstream for application/json ContentType.
type UpsertUpstreamJSONRequestBody = CreateUpstreamRequest

// CreateTargetForUpstreamJSONRequestBody defines body for CreateTargetForUpstream for application/json ContentType.
type CreateTargetForUpstreamJSONRequestBody = CreateTargetForUpstreamRequest

// UpdateTargetForUpstreamJSONRequestBody defines body for UpdateTargetForUpstream for application/json ContentType.
type UpdateTargetForUpstreamJSONRequestBody = CreateTargetForUpstreamRequest

// UpsertTargetForUpstreamJSONRequestBody defines body for UpsertTargetForUpstream for application/json ContentType.
type UpsertTargetForUpstreamJSONRequestBody = CreateTargetForUpstreamRequest

// CreateVaultJSONRequestBody defines body for CreateVault for application/json ContentType.
type CreateVaultJSONRequestBody = CreateVaultRequest

// UpdateVaultJSONRequestBody defines body for UpdateVault for application/json ContentType.
type UpdateVaultJSONRequestBody = CreateVaultRequest

// UpsertVaultJSONRequestBody defines body for UpsertVault for application/json ContentType.
type UpsertVaultJSONRequestBody = CreateVaultRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GeInfo request
	GeInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCaCertificate request
	ListCaCertificate(ctx context.Context, params *ListCaCertificateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCaCertificateWithBody request with any body
	CreateCaCertificateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCaCertificate(ctx context.Context, body CreateCaCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCaCertificate request
	DeleteCaCertificate(ctx context.Context, caCertificateId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCaCertificate request
	GetCaCertificate(ctx context.Context, caCertificateId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCaCertificateWithBody request with any body
	UpdateCaCertificateWithBody(ctx context.Context, caCertificateId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCaCertificate(ctx context.Context, caCertificateId string, body UpdateCaCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatetCaCertificateWithBody request with any body
	UpdatetCaCertificateWithBody(ctx context.Context, caCertificateId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatetCaCertificate(ctx context.Context, caCertificateId string, body UpdatetCaCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PurgeAllCache request
	PurgeAllCache(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCacheByKey request
	DeleteCacheByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCacheByKey request
	GetCacheByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCertificate request
	ListCertificate(ctx context.Context, params *ListCertificateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCertificateWithBody request with any body
	CreateCertificateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCertificate(ctx context.Context, body CreateCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCertificate request
	DeleteCertificate(ctx context.Context, certificateId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCertificate request
	GetCertificate(ctx context.Context, certificateId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCertificateWithBody request with any body
	UpdateCertificateWithBody(ctx context.Context, certificateId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCertificate(ctx context.Context, certificateId string, body UpdateCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCertificatePutWithBody request with any body
	UpdateCertificatePutWithBody(ctx context.Context, certificateId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCertificatePut(ctx context.Context, certificateId string, body UpdateCertificatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSniForCertificate request
	DeleteSniForCertificate(ctx context.Context, certificateId string, sniNameOrId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FetchSniWithCertificate request
	FetchSniWithCertificate(ctx context.Context, certificateId string, sniNameOrId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSniForCertificateWithBody request with any body
	UpdateSniForCertificateWithBody(ctx context.Context, certificateId string, sniNameOrId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSniForCertificate(ctx context.Context, certificateId string, sniNameOrId string, body UpdateSniForCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpsertSniForCertificateWithBody request with any body
	UpsertSniForCertificateWithBody(ctx context.Context, certificateId string, sniNameOrId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpsertSniForCertificate(ctx context.Context, certificateId string, sniNameOrId string, body UpsertSniForCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSniWithCertificate request
	GetSniWithCertificate(ctx context.Context, certificateNameOrId GetSniWithCertificateParamsCertificateNameOrId, params *GetSniWithCertificateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSniForCertificateWithBody request with any body
	CreateSniForCertificateWithBody(ctx context.Context, certificateNameOrId CreateSniForCertificateParamsCertificateNameOrId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSniForCertificate(ctx context.Context, certificateNameOrId CreateSniForCertificateParamsCertificateNameOrId, body CreateSniForCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataPlanes request
	GetDataPlanes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataPlaneStatus request
	GetDataPlaneStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListConsumer request
	ListConsumer(ctx context.Context, params *ListConsumerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateConsumerWithBody request with any body
	CreateConsumerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateConsumer(ctx context.Context, body CreateConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroupOfConsumer request
	DeleteGroupOfConsumer(ctx context.Context, consumerNameOrId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ViewGroupConsumer request
	ViewGroupConsumer(ctx context.Context, consumerNameOrId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddConsumerToGroupWithBody request with any body
	AddConsumerToGroupWithBody(ctx context.Context, consumerNameOrId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddConsumerToGroup(ctx context.Context, consumerNameOrId string, body AddConsumerToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteConsumer request
	DeleteConsumer(ctx context.Context, consumerUsernameOrId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConsumer request
	GetConsumer(ctx context.Context, consumerUsernameOrId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateConsumerWithBody request with any body
	UpdateConsumerWithBody(ctx context.Context, consumerUsernameOrId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateConsumer(ctx context.Context, consumerUsernameOrId string, body UpdateConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpsertConsumerWithBody request with any body
	UpsertConsumerWithBody(ctx context.Context, consumerUsernameOrId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpsertConsumer(ctx context.Context, consumerUsernameOrId string, body UpsertConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPluginsForConsumer request
	ListPluginsForConsumer(ctx context.Context, consumerUsernameOrId string, params *ListPluginsForConsumerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePluginForConsumerWithBody request with any body
	CreatePluginForConsumerWithBody(ctx context.Context, consumerUsernameOrId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePluginForConsumer(ctx context.Context, consumerUsernameOrId string, body CreatePluginForConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePluginForConsumer request
	DeletePluginForConsumer(ctx context.Context, consumerUsernameOrId string, pluginId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FetchPluginForConsumer request
	FetchPluginForConsumer(ctx context.Context, consumerUsernameOrId string, pluginId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePluginForConsumerWithBody request with any body
	UpdatePluginForConsumerWithBody(ctx context.Context, consumerUsernameOrId string, pluginId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePluginForConsumer(ctx context.Context, consumerUsernameOrId string, pluginId string, body UpdatePluginForConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpsertPluginForConsumerWithBody request with any body
	UpsertPluginForConsumerWithBody(ctx context.Context, consumerUsernameOrId string, pluginId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpsertPluginForConsumer(ctx context.Context, consumerUsernameOrId string, pluginId string, body UpsertPluginForConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutDebugClusterControlPlanesNodesLogLevelLogLevel request
	PutDebugClusterControlPlanesNodesLogLevelLogLevel(ctx context.Context, logLevel PutDebugClusterControlPlanesNodesLogLevelLogLevelParamsLogLevel, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutDebugClusterLogLevelLogLevel request
	PutDebugClusterLogLevelLogLevel(ctx context.Context, logLevel PutDebugClusterLogLevelLogLevelParamsLogLevel, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDebugNodeLogLevel request
	GetDebugNodeLogLevel(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutDebugNodeLogLevelLogLevel request
	PutDebugNodeLogLevelLogLevel(ctx context.Context, logLevel PutDebugNodeLogLevelLogLevelParamsLogLevel, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEndpoints request
	GetEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFilterChains request
	GetFilterChains(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostFilterChainsWithBody request with any body
	PostFilterChainsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostFilterChains(ctx context.Context, body PostFilterChainsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFilterChainsFilterChainId request
	DeleteFilterChainsFilterChainId(ctx context.Context, filterChainId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFilterChainsFilterChainId request
	GetFilterChainsFilterChainId(ctx context.Context, filterChainId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchFilterChainsFilterChainIdWithBody request with any body
	PatchFilterChainsFilterChainIdWithBody(ctx context.Context, filterChainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchFilterChainsFilterChainId(ctx context.Context, filterChainId string, body PatchFilterChainsFilterChainIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutFilterChainsFilterChainIdWithBody request with any body
	PutFilterChainsFilterChainIdWithBody(ctx context.Context, filterChainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutFilterChainsFilterChainId(ctx context.Context, filterChainId string, body PutFilterChainsFilterChainIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListKeySet request
	ListKeySet(ctx context.Context, params *ListKeySetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateKeySetWithBody request with any body
	CreateKeySetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateKeySet(ctx context.Context, body CreateKeySetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteKeySet request
	DeleteKeySet(ctx context.Context, keySetIdOrName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeySet request
	GetKeySet(ctx context.Context, keySetIdOrName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateKeySetWithBody request with any body
	UpdateKeySetWithBody(ctx context.Context, keySetIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateKeySet(ctx context.Context, keySetIdOrName string, body UpdateKeySetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpsertKeySetWithBody request with any body
	UpsertKeySetWithBody(ctx context.Context, keySetIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpsertKeySet(ctx context.Context, keySetIdOrName string, body UpsertKeySetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListKey request
	ListKey(ctx context.Context, params *ListKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateKeyWithBody request with any body
	CreateKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateKey(ctx context.Context, body CreateKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteKey request
	DeleteKey(ctx context.Context, keyIdOrName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKey request
	GetKey(ctx context.Context, keyIdOrName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateKeyWithBody request with any body
	UpdateKeyWithBody(ctx context.Context, keyIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateKey(ctx context.Context, keyIdOrName string, body UpdateKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpsertKeyWithBody request with any body
	UpsertKeyWithBody(ctx context.Context, keyIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpsertKey(ctx context.Context, keyIdOrName string, body UpsertKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPlugin request
	ListPlugin(ctx context.Context, params *ListPluginParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePluginWithBody request with any body
	CreatePluginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePlugin(ctx context.Context, body CreatePluginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePlugin request
	DeletePlugin(ctx context.Context, pluginId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlugin request
	GetPlugin(ctx context.Context, pluginId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePluginWithBody request with any body
	UpdatePluginWithBody(ctx context.Context, pluginId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePlugin(ctx context.Context, pluginId string, body UpdatePluginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpsertPluginWithBody request with any body
	UpsertPluginWithBody(ctx context.Context, pluginId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpsertPlugin(ctx context.Context, pluginId string, body UpsertPluginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRoute request
	ListRoute(ctx context.Context, params *ListRouteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRouteWithBody request with any body
	CreateRouteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRoute(ctx context.Context, body CreateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRoute request
	DeleteRoute(ctx context.Context, routeIdOrName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRoute request
	GetRoute(ctx context.Context, routeIdOrName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRouteWithBody request with any body
	UpdateRouteWithBody(ctx context.Context, routeIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRoute(ctx context.Context, routeIdOrName string, body UpdateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpsertRouteWithBody request with any body
	UpsertRouteWithBody(ctx context.Context, routeIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpsertRoute(ctx context.Context, routeIdOrName string, body UpsertRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRoutesRouteIdOrNameFilterChains request
	GetRoutesRouteIdOrNameFilterChains(ctx context.Context, routeIdOrName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchRoutesRouteIdOrNameFilterChainsWithBody request with any body
	PatchRoutesRouteIdOrNameFilterChainsWithBody(ctx context.Context, routeIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchRoutesRouteIdOrNameFilterChains(ctx context.Context, routeIdOrName string, body PatchRoutesRouteIdOrNameFilterChainsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRoutesRouteNameOrIdFilterChainsWithBody request with any body
	GetRoutesRouteNameOrIdFilterChainsWithBody(ctx context.Context, routeIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetRoutesRouteNameOrIdFilterChains(ctx context.Context, routeIdOrName string, body GetRoutesRouteNameOrIdFilterChainsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRoutesRouteIdOrNameFilterChainsFilterChainId request
	GetRoutesRouteIdOrNameFilterChainsFilterChainId(ctx context.Context, routeIdOrName string, filterChainId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutRoutesRouteIdOrNameFilterChainsFilterChainIdWithBody request with any body
	PutRoutesRouteIdOrNameFilterChainsFilterChainIdWithBody(ctx context.Context, routeIdOrName string, filterChainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutRoutesRouteIdOrNameFilterChainsFilterChainId(ctx context.Context, routeIdOrName string, filterChainId string, body PutRoutesRouteIdOrNameFilterChainsFilterChainIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPluginsForRoute request
	ListPluginsForRoute(ctx context.Context, routeIdOrName string, params *ListPluginsForRouteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePluginForRouteWithBody request with any body
	CreatePluginForRouteWithBody(ctx context.Context, routeIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePluginForRoute(ctx context.Context, routeIdOrName string, body CreatePluginForRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePluginForRoute request
	DeletePluginForRoute(ctx context.Context, routeIdOrName string, pluginId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FetchPluginForRoute request
	FetchPluginForRoute(ctx context.Context, routeIdOrName string, pluginId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePluginForRouteWithBody request with any body
	UpdatePluginForRouteWithBody(ctx context.Context, routeIdOrName string, pluginId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePluginForRoute(ctx context.Context, routeIdOrName string, pluginId string, body UpdatePluginForRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpsertPluginForRouteWithBody request with any body
	UpsertPluginForRouteWithBody(ctx context.Context, routeIdOrName string, pluginId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpsertPluginForRoute(ctx context.Context, routeIdOrName string, pluginId string, body UpsertPluginForRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRoutesRouteIdOrNameFilterChainId request
	GetRoutesRouteIdOrNameFilterChainId(ctx context.Context, routeIdOrName string, filterChainId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchemasFiltersFilterName request
	GetSchemasFiltersFilterName(ctx context.Context, filterName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSchemasPluginsValidate request
	PostSchemasPluginsValidate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchemasPluginsPluginName request
	GetSchemasPluginsPluginName(ctx context.Context, pluginName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchemasVaultsVaultName request
	GetSchemasVaultsVaultName(ctx context.Context, vaultName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSchemasVaultsValidateWithBody request with any body
	PostSchemasVaultsValidateWithBody(ctx context.Context, vaultName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSchemasVaultsValidate(ctx context.Context, vaultName string, body PostSchemasVaultsValidateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchemasEntity request
	GetSchemasEntity(ctx context.Context, entity string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSchemasEntityValidate request
	PostSchemasEntityValidate(ctx context.Context, entity string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListService request
	ListService(ctx context.Context, params *ListServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServiceWithBody request with any body
	CreateServiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateService(ctx context.Context, body CreateServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteService request
	DeleteService(ctx context.Context, serviceIdOrName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetService request
	GetService(ctx context.Context, serviceIdOrName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateServiceWithBody request with any body
	UpdateServiceWithBody(ctx context.Context, serviceIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateService(ctx context.Context, serviceIdOrName string, body UpdateServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpsertServiceWithBody request with any body
	UpsertServiceWithBody(ctx context.Context, serviceIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpsertService(ctx context.Context, serviceIdOrName string, body UpsertServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServiceIdOrNameFilterChains request
	GetServiceIdOrNameFilterChains(ctx context.Context, serviceIdOrName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServicesServiceIdOrNameFilterChainsWithBody request with any body
	GetServicesServiceIdOrNameFilterChainsWithBody(ctx context.Context, serviceIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetServicesServiceIdOrNameFilterChains(ctx context.Context, serviceIdOrName string, body GetServicesServiceIdOrNameFilterChainsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServicesServiceIdOrNameFilterChainsFilterChainId request
	DeleteServicesServiceIdOrNameFilterChainsFilterChainId(ctx context.Context, serviceIdOrName string, filterChainId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePluginForAService request
	DeletePluginForAService(ctx context.Context, serviceIdOrName string, pluginId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FetchPluginWithAService request
	FetchPluginWithAService(ctx context.Context, serviceIdOrName string, pluginId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePluginForAServiceWithBody request with any body
	UpdatePluginForAServiceWithBody(ctx context.Context, serviceIdOrName string, pluginId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePluginForAService(ctx context.Context, serviceIdOrName string, pluginId string, body UpdatePluginForAServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpsertPluginForAServiceWithBody request with any body
	UpsertPluginForAServiceWithBody(ctx context.Context, serviceIdOrName string, pluginId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpsertPluginForAService(ctx context.Context, serviceIdOrName string, pluginId string, body UpsertPluginForAServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRoutesForService request
	ListRoutesForService(ctx context.Context, serviceIdOrName string, params *ListRoutesForServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRouteForServiceWithBody request with any body
	CreateRouteForServiceWithBody(ctx context.Context, serviceIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRouteForService(ctx context.Context, serviceIdOrName string, body CreateRouteForServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRouteForService request
	DeleteRouteForService(ctx context.Context, serviceIdOrName string, routeIdOrName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FetchRouteForService request
	FetchRouteForService(ctx context.Context, serviceIdOrName string, routeIdOrName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRouteForServiceWithBody request with any body
	UpdateRouteForServiceWithBody(ctx context.Context, serviceIdOrName string, routeIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRouteForService(ctx context.Context, serviceIdOrName string, routeIdOrName string, body UpdateRouteForServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpsertRouteForServiceWithBody request with any body
	UpsertRouteForServiceWithBody(ctx context.Context, serviceIdOrName string, routeIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpsertRouteForService(ctx context.Context, serviceIdOrName string, routeIdOrName string, body UpsertRouteForServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPluginsForService request
	GetPluginsForService(ctx context.Context, serviceIdOrName string, params *GetPluginsForServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePluginForServiceWithBody request with any body
	CreatePluginForServiceWithBody(ctx context.Context, serviceIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePluginForService(ctx context.Context, serviceIdOrName string, body CreatePluginForServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSni request
	ListSni(ctx context.Context, params *ListSniParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSniWithBody request with any body
	CreateSniWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSni(ctx context.Context, body CreateSniJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSni request
	DeleteSni(ctx context.Context, sniNameOrId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSni request
	GetSni(ctx context.Context, sniNameOrId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSniWithBody request with any body
	UpdateSniWithBody(ctx context.Context, sniNameOrId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSni(ctx context.Context, sniNameOrId string, body UpdateSniJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpsertSniWithBody request with any body
	UpsertSniWithBody(ctx context.Context, sniNameOrId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpsertSni(ctx context.Context, sniNameOrId string, body UpsertSniJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStatus request
	GetStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDnsStatus request
	GetDnsStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTags request
	GetTags(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTagsTags request
	GetTagsTags(ctx context.Context, tags string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTimers request
	GetTimers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUpstream request
	ListUpstream(ctx context.Context, params *ListUpstreamParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUpstreamWithBody request with any body
	CreateUpstreamWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUpstream(ctx context.Context, body CreateUpstreamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUpstream request
	DeleteUpstream(ctx context.Context, upstreamIdOrName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUpstream request
	GetUpstream(ctx context.Context, upstreamIdOrName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUpstreamWithBody request with any body
	UpdateUpstreamWithBody(ctx context.Context, upstreamIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUpstream(ctx context.Context, upstreamIdOrName string, body UpdateUpstreamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpsertUpstreamWithBody request with any body
	UpsertUpstreamWithBody(ctx context.Context, upstreamIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpsertUpstream(ctx context.Context, upstreamIdOrName string, body UpsertUpstreamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTargetsForUpstream request
	ListTargetsForUpstream(ctx context.Context, upstreamIdOrName string, params *ListTargetsForUpstreamParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTargetForUpstreamWithBody request with any body
	CreateTargetForUpstreamWithBody(ctx context.Context, upstreamIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTargetForUpstream(ctx context.Context, upstreamIdOrName string, body CreateTargetForUpstreamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUpstreamTarget request
	DeleteUpstreamTarget(ctx context.Context, upstreamIdOrName string, targetIdOrTarget string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FetchTargetForUpstream request
	FetchTargetForUpstream(ctx context.Context, upstreamIdOrName string, targetIdOrTarget string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTargetForUpstreamWithBody request with any body
	UpdateTargetForUpstreamWithBody(ctx context.Context, upstreamIdOrName string, targetIdOrTarget string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTargetForUpstream(ctx context.Context, upstreamIdOrName string, targetIdOrTarget string, body UpdateTargetForUpstreamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpsertTargetForUpstreamWithBody request with any body
	UpsertTargetForUpstreamWithBody(ctx context.Context, upstreamIdOrName string, targetIdOrTarget string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpsertTargetForUpstream(ctx context.Context, upstreamIdOrName string, targetIdOrTarget string, body UpsertTargetForUpstreamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVault request
	ListVault(ctx context.Context, params *ListVaultParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVaultWithBody request with any body
	CreateVaultWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVault(ctx context.Context, body CreateVaultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVault request
	DeleteVault(ctx context.Context, vaultIdOrPrefix string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVault request
	GetVault(ctx context.Context, vaultIdOrPrefix string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVaultWithBody request with any body
	UpdateVaultWithBody(ctx context.Context, vaultIdOrPrefix string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVault(ctx context.Context, vaultIdOrPrefix string, body UpdateVaultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpsertVaultWithBody request with any body
	UpsertVaultWithBody(ctx context.Context, vaultIdOrPrefix string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpsertVault(ctx context.Context, vaultIdOrPrefix string, body UpsertVaultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HeadEndpoints request
	HeadEndpoints(ctx context.Context, endpoint string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OptionsEndpoint request
	OptionsEndpoint(ctx context.Context, endpoint string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GeInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGeInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCaCertificate(ctx context.Context, params *ListCaCertificateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCaCertificateRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCaCertificateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCaCertificateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCaCertificate(ctx context.Context, body CreateCaCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCaCertificateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCaCertificate(ctx context.Context, caCertificateId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCaCertificateRequest(c.Server, caCertificateId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCaCertificate(ctx context.Context, caCertificateId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCaCertificateRequest(c.Server, caCertificateId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCaCertificateWithBody(ctx context.Context, caCertificateId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCaCertificateRequestWithBody(c.Server, caCertificateId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCaCertificate(ctx context.Context, caCertificateId string, body UpdateCaCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCaCertificateRequest(c.Server, caCertificateId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatetCaCertificateWithBody(ctx context.Context, caCertificateId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatetCaCertificateRequestWithBody(c.Server, caCertificateId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatetCaCertificate(ctx context.Context, caCertificateId string, body UpdatetCaCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatetCaCertificateRequest(c.Server, caCertificateId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PurgeAllCache(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPurgeAllCacheRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCacheByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCacheByKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCacheByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCacheByKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCertificate(ctx context.Context, params *ListCertificateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCertificateRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCertificateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCertificateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCertificate(ctx context.Context, body CreateCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCertificateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCertificate(ctx context.Context, certificateId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCertificateRequest(c.Server, certificateId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCertificate(ctx context.Context, certificateId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCertificateRequest(c.Server, certificateId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCertificateWithBody(ctx context.Context, certificateId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCertificateRequestWithBody(c.Server, certificateId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCertificate(ctx context.Context, certificateId string, body UpdateCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCertificateRequest(c.Server, certificateId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCertificatePutWithBody(ctx context.Context, certificateId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCertificatePutRequestWithBody(c.Server, certificateId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCertificatePut(ctx context.Context, certificateId string, body UpdateCertificatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCertificatePutRequest(c.Server, certificateId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSniForCertificate(ctx context.Context, certificateId string, sniNameOrId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSniForCertificateRequest(c.Server, certificateId, sniNameOrId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FetchSniWithCertificate(ctx context.Context, certificateId string, sniNameOrId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFetchSniWithCertificateRequest(c.Server, certificateId, sniNameOrId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSniForCertificateWithBody(ctx context.Context, certificateId string, sniNameOrId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSniForCertificateRequestWithBody(c.Server, certificateId, sniNameOrId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSniForCertificate(ctx context.Context, certificateId string, sniNameOrId string, body UpdateSniForCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSniForCertificateRequest(c.Server, certificateId, sniNameOrId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertSniForCertificateWithBody(ctx context.Context, certificateId string, sniNameOrId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertSniForCertificateRequestWithBody(c.Server, certificateId, sniNameOrId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertSniForCertificate(ctx context.Context, certificateId string, sniNameOrId string, body UpsertSniForCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertSniForCertificateRequest(c.Server, certificateId, sniNameOrId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSniWithCertificate(ctx context.Context, certificateNameOrId GetSniWithCertificateParamsCertificateNameOrId, params *GetSniWithCertificateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSniWithCertificateRequest(c.Server, certificateNameOrId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSniForCertificateWithBody(ctx context.Context, certificateNameOrId CreateSniForCertificateParamsCertificateNameOrId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSniForCertificateRequestWithBody(c.Server, certificateNameOrId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSniForCertificate(ctx context.Context, certificateNameOrId CreateSniForCertificateParamsCertificateNameOrId, body CreateSniForCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSniForCertificateRequest(c.Server, certificateNameOrId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataPlanes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataPlanesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataPlaneStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataPlaneStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListConsumer(ctx context.Context, params *ListConsumerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListConsumerRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateConsumerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateConsumerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateConsumer(ctx context.Context, body CreateConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateConsumerRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroupOfConsumer(ctx context.Context, consumerNameOrId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupOfConsumerRequest(c.Server, consumerNameOrId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ViewGroupConsumer(ctx context.Context, consumerNameOrId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewViewGroupConsumerRequest(c.Server, consumerNameOrId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddConsumerToGroupWithBody(ctx context.Context, consumerNameOrId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddConsumerToGroupRequestWithBody(c.Server, consumerNameOrId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddConsumerToGroup(ctx context.Context, consumerNameOrId string, body AddConsumerToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddConsumerToGroupRequest(c.Server, consumerNameOrId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteConsumer(ctx context.Context, consumerUsernameOrId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteConsumerRequest(c.Server, consumerUsernameOrId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConsumer(ctx context.Context, consumerUsernameOrId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConsumerRequest(c.Server, consumerUsernameOrId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConsumerWithBody(ctx context.Context, consumerUsernameOrId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConsumerRequestWithBody(c.Server, consumerUsernameOrId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConsumer(ctx context.Context, consumerUsernameOrId string, body UpdateConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConsumerRequest(c.Server, consumerUsernameOrId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertConsumerWithBody(ctx context.Context, consumerUsernameOrId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertConsumerRequestWithBody(c.Server, consumerUsernameOrId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertConsumer(ctx context.Context, consumerUsernameOrId string, body UpsertConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertConsumerRequest(c.Server, consumerUsernameOrId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPluginsForConsumer(ctx context.Context, consumerUsernameOrId string, params *ListPluginsForConsumerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPluginsForConsumerRequest(c.Server, consumerUsernameOrId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePluginForConsumerWithBody(ctx context.Context, consumerUsernameOrId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePluginForConsumerRequestWithBody(c.Server, consumerUsernameOrId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePluginForConsumer(ctx context.Context, consumerUsernameOrId string, body CreatePluginForConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePluginForConsumerRequest(c.Server, consumerUsernameOrId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePluginForConsumer(ctx context.Context, consumerUsernameOrId string, pluginId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePluginForConsumerRequest(c.Server, consumerUsernameOrId, pluginId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FetchPluginForConsumer(ctx context.Context, consumerUsernameOrId string, pluginId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFetchPluginForConsumerRequest(c.Server, consumerUsernameOrId, pluginId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePluginForConsumerWithBody(ctx context.Context, consumerUsernameOrId string, pluginId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePluginForConsumerRequestWithBody(c.Server, consumerUsernameOrId, pluginId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePluginForConsumer(ctx context.Context, consumerUsernameOrId string, pluginId string, body UpdatePluginForConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePluginForConsumerRequest(c.Server, consumerUsernameOrId, pluginId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertPluginForConsumerWithBody(ctx context.Context, consumerUsernameOrId string, pluginId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertPluginForConsumerRequestWithBody(c.Server, consumerUsernameOrId, pluginId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertPluginForConsumer(ctx context.Context, consumerUsernameOrId string, pluginId string, body UpsertPluginForConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertPluginForConsumerRequest(c.Server, consumerUsernameOrId, pluginId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutDebugClusterControlPlanesNodesLogLevelLogLevel(ctx context.Context, logLevel PutDebugClusterControlPlanesNodesLogLevelLogLevelParamsLogLevel, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutDebugClusterControlPlanesNodesLogLevelLogLevelRequest(c.Server, logLevel)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutDebugClusterLogLevelLogLevel(ctx context.Context, logLevel PutDebugClusterLogLevelLogLevelParamsLogLevel, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutDebugClusterLogLevelLogLevelRequest(c.Server, logLevel)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDebugNodeLogLevel(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDebugNodeLogLevelRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutDebugNodeLogLevelLogLevel(ctx context.Context, logLevel PutDebugNodeLogLevelLogLevelParamsLogLevel, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutDebugNodeLogLevelLogLevelRequest(c.Server, logLevel)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEndpointsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFilterChains(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFilterChainsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFilterChainsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFilterChainsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFilterChains(ctx context.Context, body PostFilterChainsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFilterChainsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFilterChainsFilterChainId(ctx context.Context, filterChainId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFilterChainsFilterChainIdRequest(c.Server, filterChainId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFilterChainsFilterChainId(ctx context.Context, filterChainId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFilterChainsFilterChainIdRequest(c.Server, filterChainId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchFilterChainsFilterChainIdWithBody(ctx context.Context, filterChainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchFilterChainsFilterChainIdRequestWithBody(c.Server, filterChainId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchFilterChainsFilterChainId(ctx context.Context, filterChainId string, body PatchFilterChainsFilterChainIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchFilterChainsFilterChainIdRequest(c.Server, filterChainId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutFilterChainsFilterChainIdWithBody(ctx context.Context, filterChainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutFilterChainsFilterChainIdRequestWithBody(c.Server, filterChainId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutFilterChainsFilterChainId(ctx context.Context, filterChainId string, body PutFilterChainsFilterChainIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutFilterChainsFilterChainIdRequest(c.Server, filterChainId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListKeySet(ctx context.Context, params *ListKeySetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListKeySetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeySetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeySetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeySet(ctx context.Context, body CreateKeySetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeySetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteKeySet(ctx context.Context, keySetIdOrName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteKeySetRequest(c.Server, keySetIdOrName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeySet(ctx context.Context, keySetIdOrName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeySetRequest(c.Server, keySetIdOrName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateKeySetWithBody(ctx context.Context, keySetIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateKeySetRequestWithBody(c.Server, keySetIdOrName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateKeySet(ctx context.Context, keySetIdOrName string, body UpdateKeySetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateKeySetRequest(c.Server, keySetIdOrName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertKeySetWithBody(ctx context.Context, keySetIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertKeySetRequestWithBody(c.Server, keySetIdOrName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertKeySet(ctx context.Context, keySetIdOrName string, body UpsertKeySetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertKeySetRequest(c.Server, keySetIdOrName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListKey(ctx context.Context, params *ListKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListKeyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKey(ctx context.Context, body CreateKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteKey(ctx context.Context, keyIdOrName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteKeyRequest(c.Server, keyIdOrName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKey(ctx context.Context, keyIdOrName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeyRequest(c.Server, keyIdOrName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateKeyWithBody(ctx context.Context, keyIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateKeyRequestWithBody(c.Server, keyIdOrName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateKey(ctx context.Context, keyIdOrName string, body UpdateKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateKeyRequest(c.Server, keyIdOrName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertKeyWithBody(ctx context.Context, keyIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertKeyRequestWithBody(c.Server, keyIdOrName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertKey(ctx context.Context, keyIdOrName string, body UpsertKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertKeyRequest(c.Server, keyIdOrName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPlugin(ctx context.Context, params *ListPluginParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPluginRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePluginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePluginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlugin(ctx context.Context, body CreatePluginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePluginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePlugin(ctx context.Context, pluginId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePluginRequest(c.Server, pluginId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlugin(ctx context.Context, pluginId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPluginRequest(c.Server, pluginId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePluginWithBody(ctx context.Context, pluginId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePluginRequestWithBody(c.Server, pluginId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePlugin(ctx context.Context, pluginId string, body UpdatePluginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePluginRequest(c.Server, pluginId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertPluginWithBody(ctx context.Context, pluginId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertPluginRequestWithBody(c.Server, pluginId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertPlugin(ctx context.Context, pluginId string, body UpsertPluginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertPluginRequest(c.Server, pluginId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRoute(ctx context.Context, params *ListRouteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRouteRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRouteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRouteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRoute(ctx context.Context, body CreateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRouteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRoute(ctx context.Context, routeIdOrName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRouteRequest(c.Server, routeIdOrName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRoute(ctx context.Context, routeIdOrName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRouteRequest(c.Server, routeIdOrName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRouteWithBody(ctx context.Context, routeIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRouteRequestWithBody(c.Server, routeIdOrName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRoute(ctx context.Context, routeIdOrName string, body UpdateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRouteRequest(c.Server, routeIdOrName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertRouteWithBody(ctx context.Context, routeIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertRouteRequestWithBody(c.Server, routeIdOrName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertRoute(ctx context.Context, routeIdOrName string, body UpsertRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertRouteRequest(c.Server, routeIdOrName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRoutesRouteIdOrNameFilterChains(ctx context.Context, routeIdOrName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoutesRouteIdOrNameFilterChainsRequest(c.Server, routeIdOrName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchRoutesRouteIdOrNameFilterChainsWithBody(ctx context.Context, routeIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchRoutesRouteIdOrNameFilterChainsRequestWithBody(c.Server, routeIdOrName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchRoutesRouteIdOrNameFilterChains(ctx context.Context, routeIdOrName string, body PatchRoutesRouteIdOrNameFilterChainsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchRoutesRouteIdOrNameFilterChainsRequest(c.Server, routeIdOrName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRoutesRouteNameOrIdFilterChainsWithBody(ctx context.Context, routeIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoutesRouteNameOrIdFilterChainsRequestWithBody(c.Server, routeIdOrName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRoutesRouteNameOrIdFilterChains(ctx context.Context, routeIdOrName string, body GetRoutesRouteNameOrIdFilterChainsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoutesRouteNameOrIdFilterChainsRequest(c.Server, routeIdOrName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRoutesRouteIdOrNameFilterChainsFilterChainId(ctx context.Context, routeIdOrName string, filterChainId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoutesRouteIdOrNameFilterChainsFilterChainIdRequest(c.Server, routeIdOrName, filterChainId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutRoutesRouteIdOrNameFilterChainsFilterChainIdWithBody(ctx context.Context, routeIdOrName string, filterChainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutRoutesRouteIdOrNameFilterChainsFilterChainIdRequestWithBody(c.Server, routeIdOrName, filterChainId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutRoutesRouteIdOrNameFilterChainsFilterChainId(ctx context.Context, routeIdOrName string, filterChainId string, body PutRoutesRouteIdOrNameFilterChainsFilterChainIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutRoutesRouteIdOrNameFilterChainsFilterChainIdRequest(c.Server, routeIdOrName, filterChainId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPluginsForRoute(ctx context.Context, routeIdOrName string, params *ListPluginsForRouteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPluginsForRouteRequest(c.Server, routeIdOrName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePluginForRouteWithBody(ctx context.Context, routeIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePluginForRouteRequestWithBody(c.Server, routeIdOrName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePluginForRoute(ctx context.Context, routeIdOrName string, body CreatePluginForRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePluginForRouteRequest(c.Server, routeIdOrName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePluginForRoute(ctx context.Context, routeIdOrName string, pluginId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePluginForRouteRequest(c.Server, routeIdOrName, pluginId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FetchPluginForRoute(ctx context.Context, routeIdOrName string, pluginId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFetchPluginForRouteRequest(c.Server, routeIdOrName, pluginId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePluginForRouteWithBody(ctx context.Context, routeIdOrName string, pluginId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePluginForRouteRequestWithBody(c.Server, routeIdOrName, pluginId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePluginForRoute(ctx context.Context, routeIdOrName string, pluginId string, body UpdatePluginForRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePluginForRouteRequest(c.Server, routeIdOrName, pluginId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertPluginForRouteWithBody(ctx context.Context, routeIdOrName string, pluginId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertPluginForRouteRequestWithBody(c.Server, routeIdOrName, pluginId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertPluginForRoute(ctx context.Context, routeIdOrName string, pluginId string, body UpsertPluginForRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertPluginForRouteRequest(c.Server, routeIdOrName, pluginId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRoutesRouteIdOrNameFilterChainId(ctx context.Context, routeIdOrName string, filterChainId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoutesRouteIdOrNameFilterChainIdRequest(c.Server, routeIdOrName, filterChainId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchemasFiltersFilterName(ctx context.Context, filterName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchemasFiltersFilterNameRequest(c.Server, filterName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSchemasPluginsValidate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSchemasPluginsValidateRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchemasPluginsPluginName(ctx context.Context, pluginName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchemasPluginsPluginNameRequest(c.Server, pluginName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchemasVaultsVaultName(ctx context.Context, vaultName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchemasVaultsVaultNameRequest(c.Server, vaultName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSchemasVaultsValidateWithBody(ctx context.Context, vaultName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSchemasVaultsValidateRequestWithBody(c.Server, vaultName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSchemasVaultsValidate(ctx context.Context, vaultName string, body PostSchemasVaultsValidateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSchemasVaultsValidateRequest(c.Server, vaultName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchemasEntity(ctx context.Context, entity string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchemasEntityRequest(c.Server, entity)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSchemasEntityValidate(ctx context.Context, entity string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSchemasEntityValidateRequest(c.Server, entity)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListService(ctx context.Context, params *ListServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListServiceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateService(ctx context.Context, body CreateServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteService(ctx context.Context, serviceIdOrName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServiceRequest(c.Server, serviceIdOrName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetService(ctx context.Context, serviceIdOrName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceRequest(c.Server, serviceIdOrName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceWithBody(ctx context.Context, serviceIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceRequestWithBody(c.Server, serviceIdOrName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateService(ctx context.Context, serviceIdOrName string, body UpdateServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceRequest(c.Server, serviceIdOrName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertServiceWithBody(ctx context.Context, serviceIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertServiceRequestWithBody(c.Server, serviceIdOrName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertService(ctx context.Context, serviceIdOrName string, body UpsertServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertServiceRequest(c.Server, serviceIdOrName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServiceIdOrNameFilterChains(ctx context.Context, serviceIdOrName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceIdOrNameFilterChainsRequest(c.Server, serviceIdOrName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServicesServiceIdOrNameFilterChainsWithBody(ctx context.Context, serviceIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServicesServiceIdOrNameFilterChainsRequestWithBody(c.Server, serviceIdOrName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServicesServiceIdOrNameFilterChains(ctx context.Context, serviceIdOrName string, body GetServicesServiceIdOrNameFilterChainsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServicesServiceIdOrNameFilterChainsRequest(c.Server, serviceIdOrName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServicesServiceIdOrNameFilterChainsFilterChainId(ctx context.Context, serviceIdOrName string, filterChainId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServicesServiceIdOrNameFilterChainsFilterChainIdRequest(c.Server, serviceIdOrName, filterChainId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePluginForAService(ctx context.Context, serviceIdOrName string, pluginId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePluginForAServiceRequest(c.Server, serviceIdOrName, pluginId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FetchPluginWithAService(ctx context.Context, serviceIdOrName string, pluginId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFetchPluginWithAServiceRequest(c.Server, serviceIdOrName, pluginId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePluginForAServiceWithBody(ctx context.Context, serviceIdOrName string, pluginId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePluginForAServiceRequestWithBody(c.Server, serviceIdOrName, pluginId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePluginForAService(ctx context.Context, serviceIdOrName string, pluginId string, body UpdatePluginForAServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePluginForAServiceRequest(c.Server, serviceIdOrName, pluginId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertPluginForAServiceWithBody(ctx context.Context, serviceIdOrName string, pluginId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertPluginForAServiceRequestWithBody(c.Server, serviceIdOrName, pluginId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertPluginForAService(ctx context.Context, serviceIdOrName string, pluginId string, body UpsertPluginForAServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertPluginForAServiceRequest(c.Server, serviceIdOrName, pluginId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRoutesForService(ctx context.Context, serviceIdOrName string, params *ListRoutesForServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRoutesForServiceRequest(c.Server, serviceIdOrName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRouteForServiceWithBody(ctx context.Context, serviceIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRouteForServiceRequestWithBody(c.Server, serviceIdOrName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRouteForService(ctx context.Context, serviceIdOrName string, body CreateRouteForServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRouteForServiceRequest(c.Server, serviceIdOrName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRouteForService(ctx context.Context, serviceIdOrName string, routeIdOrName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRouteForServiceRequest(c.Server, serviceIdOrName, routeIdOrName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FetchRouteForService(ctx context.Context, serviceIdOrName string, routeIdOrName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFetchRouteForServiceRequest(c.Server, serviceIdOrName, routeIdOrName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRouteForServiceWithBody(ctx context.Context, serviceIdOrName string, routeIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRouteForServiceRequestWithBody(c.Server, serviceIdOrName, routeIdOrName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRouteForService(ctx context.Context, serviceIdOrName string, routeIdOrName string, body UpdateRouteForServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRouteForServiceRequest(c.Server, serviceIdOrName, routeIdOrName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertRouteForServiceWithBody(ctx context.Context, serviceIdOrName string, routeIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertRouteForServiceRequestWithBody(c.Server, serviceIdOrName, routeIdOrName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertRouteForService(ctx context.Context, serviceIdOrName string, routeIdOrName string, body UpsertRouteForServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertRouteForServiceRequest(c.Server, serviceIdOrName, routeIdOrName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPluginsForService(ctx context.Context, serviceIdOrName string, params *GetPluginsForServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPluginsForServiceRequest(c.Server, serviceIdOrName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePluginForServiceWithBody(ctx context.Context, serviceIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePluginForServiceRequestWithBody(c.Server, serviceIdOrName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePluginForService(ctx context.Context, serviceIdOrName string, body CreatePluginForServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePluginForServiceRequest(c.Server, serviceIdOrName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSni(ctx context.Context, params *ListSniParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSniRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSniWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSniRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSni(ctx context.Context, body CreateSniJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSniRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSni(ctx context.Context, sniNameOrId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSniRequest(c.Server, sniNameOrId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSni(ctx context.Context, sniNameOrId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSniRequest(c.Server, sniNameOrId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSniWithBody(ctx context.Context, sniNameOrId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSniRequestWithBody(c.Server, sniNameOrId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSni(ctx context.Context, sniNameOrId string, body UpdateSniJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSniRequest(c.Server, sniNameOrId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertSniWithBody(ctx context.Context, sniNameOrId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertSniRequestWithBody(c.Server, sniNameOrId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertSni(ctx context.Context, sniNameOrId string, body UpsertSniJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertSniRequest(c.Server, sniNameOrId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDnsStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDnsStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTags(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTagsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTagsTags(ctx context.Context, tags string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTagsTagsRequest(c.Server, tags)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTimers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTimersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUpstream(ctx context.Context, params *ListUpstreamParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUpstreamRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUpstreamWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUpstreamRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUpstream(ctx context.Context, body CreateUpstreamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUpstreamRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUpstream(ctx context.Context, upstreamIdOrName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUpstreamRequest(c.Server, upstreamIdOrName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUpstream(ctx context.Context, upstreamIdOrName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUpstreamRequest(c.Server, upstreamIdOrName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUpstreamWithBody(ctx context.Context, upstreamIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUpstreamRequestWithBody(c.Server, upstreamIdOrName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUpstream(ctx context.Context, upstreamIdOrName string, body UpdateUpstreamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUpstreamRequest(c.Server, upstreamIdOrName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertUpstreamWithBody(ctx context.Context, upstreamIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertUpstreamRequestWithBody(c.Server, upstreamIdOrName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertUpstream(ctx context.Context, upstreamIdOrName string, body UpsertUpstreamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertUpstreamRequest(c.Server, upstreamIdOrName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTargetsForUpstream(ctx context.Context, upstreamIdOrName string, params *ListTargetsForUpstreamParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTargetsForUpstreamRequest(c.Server, upstreamIdOrName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTargetForUpstreamWithBody(ctx context.Context, upstreamIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTargetForUpstreamRequestWithBody(c.Server, upstreamIdOrName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTargetForUpstream(ctx context.Context, upstreamIdOrName string, body CreateTargetForUpstreamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTargetForUpstreamRequest(c.Server, upstreamIdOrName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUpstreamTarget(ctx context.Context, upstreamIdOrName string, targetIdOrTarget string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUpstreamTargetRequest(c.Server, upstreamIdOrName, targetIdOrTarget)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FetchTargetForUpstream(ctx context.Context, upstreamIdOrName string, targetIdOrTarget string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFetchTargetForUpstreamRequest(c.Server, upstreamIdOrName, targetIdOrTarget)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTargetForUpstreamWithBody(ctx context.Context, upstreamIdOrName string, targetIdOrTarget string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTargetForUpstreamRequestWithBody(c.Server, upstreamIdOrName, targetIdOrTarget, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTargetForUpstream(ctx context.Context, upstreamIdOrName string, targetIdOrTarget string, body UpdateTargetForUpstreamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTargetForUpstreamRequest(c.Server, upstreamIdOrName, targetIdOrTarget, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertTargetForUpstreamWithBody(ctx context.Context, upstreamIdOrName string, targetIdOrTarget string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertTargetForUpstreamRequestWithBody(c.Server, upstreamIdOrName, targetIdOrTarget, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertTargetForUpstream(ctx context.Context, upstreamIdOrName string, targetIdOrTarget string, body UpsertTargetForUpstreamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertTargetForUpstreamRequest(c.Server, upstreamIdOrName, targetIdOrTarget, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVault(ctx context.Context, params *ListVaultParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVaultRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVaultWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVaultRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVault(ctx context.Context, body CreateVaultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVaultRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVault(ctx context.Context, vaultIdOrPrefix string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVaultRequest(c.Server, vaultIdOrPrefix)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVault(ctx context.Context, vaultIdOrPrefix string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVaultRequest(c.Server, vaultIdOrPrefix)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVaultWithBody(ctx context.Context, vaultIdOrPrefix string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVaultRequestWithBody(c.Server, vaultIdOrPrefix, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVault(ctx context.Context, vaultIdOrPrefix string, body UpdateVaultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVaultRequest(c.Server, vaultIdOrPrefix, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertVaultWithBody(ctx context.Context, vaultIdOrPrefix string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertVaultRequestWithBody(c.Server, vaultIdOrPrefix, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertVault(ctx context.Context, vaultIdOrPrefix string, body UpsertVaultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertVaultRequest(c.Server, vaultIdOrPrefix, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeadEndpoints(ctx context.Context, endpoint string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeadEndpointsRequest(c.Server, endpoint)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OptionsEndpoint(ctx context.Context, endpoint string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOptionsEndpointRequest(c.Server, endpoint)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGeInfoRequest generates requests for GeInfo
func NewGeInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCaCertificateRequest generates requests for ListCaCertificate
func NewListCaCertificateRequest(server string, params *ListCaCertificateParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ca_certificates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Size != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCaCertificateRequest calls the generic CreateCaCertificate builder with application/json body
func NewCreateCaCertificateRequest(server string, body CreateCaCertificateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCaCertificateRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateCaCertificateRequestWithBody generates requests for CreateCaCertificate with any type of body
func NewCreateCaCertificateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ca_certificates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCaCertificateRequest generates requests for DeleteCaCertificate
func NewDeleteCaCertificateRequest(server string, caCertificateId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ca_certificate_id", runtime.ParamLocationPath, caCertificateId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ca_certificates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCaCertificateRequest generates requests for GetCaCertificate
func NewGetCaCertificateRequest(server string, caCertificateId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ca_certificate_id", runtime.ParamLocationPath, caCertificateId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ca_certificates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCaCertificateRequest calls the generic UpdateCaCertificate builder with application/json body
func NewUpdateCaCertificateRequest(server string, caCertificateId string, body UpdateCaCertificateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCaCertificateRequestWithBody(server, caCertificateId, "application/json", bodyReader)
}

// NewUpdateCaCertificateRequestWithBody generates requests for UpdateCaCertificate with any type of body
func NewUpdateCaCertificateRequestWithBody(server string, caCertificateId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ca_certificate_id", runtime.ParamLocationPath, caCertificateId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ca_certificates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdatetCaCertificateRequest calls the generic UpdatetCaCertificate builder with application/json body
func NewUpdatetCaCertificateRequest(server string, caCertificateId string, body UpdatetCaCertificateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatetCaCertificateRequestWithBody(server, caCertificateId, "application/json", bodyReader)
}

// NewUpdatetCaCertificateRequestWithBody generates requests for UpdatetCaCertificate with any type of body
func NewUpdatetCaCertificateRequestWithBody(server string, caCertificateId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ca_certificate_id", runtime.ParamLocationPath, caCertificateId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ca_certificates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPurgeAllCacheRequest generates requests for PurgeAllCache
func NewPurgeAllCacheRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cache")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteCacheByKeyRequest generates requests for DeleteCacheByKey
func NewDeleteCacheByKeyRequest(server string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cache/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCacheByKeyRequest generates requests for GetCacheByKey
func NewGetCacheByKeyRequest(server string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cache/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCertificateRequest generates requests for ListCertificate
func NewListCertificateRequest(server string, params *ListCertificateParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/certificates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Size != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCertificateRequest calls the generic CreateCertificate builder with application/json body
func NewCreateCertificateRequest(server string, body CreateCertificateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCertificateRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateCertificateRequestWithBody generates requests for CreateCertificate with any type of body
func NewCreateCertificateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/certificates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCertificateRequest generates requests for DeleteCertificate
func NewDeleteCertificateRequest(server string, certificateId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "certificate_id", runtime.ParamLocationPath, certificateId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/certificates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCertificateRequest generates requests for GetCertificate
func NewGetCertificateRequest(server string, certificateId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "certificate_id", runtime.ParamLocationPath, certificateId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/certificates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCertificateRequest calls the generic UpdateCertificate builder with application/json body
func NewUpdateCertificateRequest(server string, certificateId string, body UpdateCertificateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCertificateRequestWithBody(server, certificateId, "application/json", bodyReader)
}

// NewUpdateCertificateRequestWithBody generates requests for UpdateCertificate with any type of body
func NewUpdateCertificateRequestWithBody(server string, certificateId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "certificate_id", runtime.ParamLocationPath, certificateId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/certificates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateCertificatePutRequest calls the generic UpdateCertificatePut builder with application/json body
func NewUpdateCertificatePutRequest(server string, certificateId string, body UpdateCertificatePutJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCertificatePutRequestWithBody(server, certificateId, "application/json", bodyReader)
}

// NewUpdateCertificatePutRequestWithBody generates requests for UpdateCertificatePut with any type of body
func NewUpdateCertificatePutRequestWithBody(server string, certificateId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "certificate_id", runtime.ParamLocationPath, certificateId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/certificates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSniForCertificateRequest generates requests for DeleteSniForCertificate
func NewDeleteSniForCertificateRequest(server string, certificateId string, sniNameOrId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "certificate_id", runtime.ParamLocationPath, certificateId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sni_name_or_id", runtime.ParamLocationPath, sniNameOrId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/certificates/%s/snis/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFetchSniWithCertificateRequest generates requests for FetchSniWithCertificate
func NewFetchSniWithCertificateRequest(server string, certificateId string, sniNameOrId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "certificate_id", runtime.ParamLocationPath, certificateId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sni_name_or_id", runtime.ParamLocationPath, sniNameOrId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/certificates/%s/snis/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSniForCertificateRequest calls the generic UpdateSniForCertificate builder with application/json body
func NewUpdateSniForCertificateRequest(server string, certificateId string, sniNameOrId string, body UpdateSniForCertificateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSniForCertificateRequestWithBody(server, certificateId, sniNameOrId, "application/json", bodyReader)
}

// NewUpdateSniForCertificateRequestWithBody generates requests for UpdateSniForCertificate with any type of body
func NewUpdateSniForCertificateRequestWithBody(server string, certificateId string, sniNameOrId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "certificate_id", runtime.ParamLocationPath, certificateId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sni_name_or_id", runtime.ParamLocationPath, sniNameOrId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/certificates/%s/snis/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpsertSniForCertificateRequest calls the generic UpsertSniForCertificate builder with application/json body
func NewUpsertSniForCertificateRequest(server string, certificateId string, sniNameOrId string, body UpsertSniForCertificateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpsertSniForCertificateRequestWithBody(server, certificateId, sniNameOrId, "application/json", bodyReader)
}

// NewUpsertSniForCertificateRequestWithBody generates requests for UpsertSniForCertificate with any type of body
func NewUpsertSniForCertificateRequestWithBody(server string, certificateId string, sniNameOrId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "certificate_id", runtime.ParamLocationPath, certificateId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sni_name_or_id", runtime.ParamLocationPath, sniNameOrId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/certificates/%s/snis/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSniWithCertificateRequest generates requests for GetSniWithCertificate
func NewGetSniWithCertificateRequest(server string, certificateNameOrId GetSniWithCertificateParamsCertificateNameOrId, params *GetSniWithCertificateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "certificate_name_or_id", runtime.ParamLocationPath, certificateNameOrId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/certificates/%s/snis", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Size != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSniForCertificateRequest calls the generic CreateSniForCertificate builder with application/json body
func NewCreateSniForCertificateRequest(server string, certificateNameOrId CreateSniForCertificateParamsCertificateNameOrId, body CreateSniForCertificateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSniForCertificateRequestWithBody(server, certificateNameOrId, "application/json", bodyReader)
}

// NewCreateSniForCertificateRequestWithBody generates requests for CreateSniForCertificate with any type of body
func NewCreateSniForCertificateRequestWithBody(server string, certificateNameOrId CreateSniForCertificateParamsCertificateNameOrId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "certificate_name_or_id", runtime.ParamLocationPath, certificateNameOrId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/certificates/%s/snis", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDataPlanesRequest generates requests for GetDataPlanes
func NewGetDataPlanesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clustering/data-planes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDataPlaneStatusRequest generates requests for GetDataPlaneStatus
func NewGetDataPlaneStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clustering/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListConsumerRequest generates requests for ListConsumer
func NewListConsumerRequest(server string, params *ListConsumerParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/consumers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Size != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateConsumerRequest calls the generic CreateConsumer builder with application/json body
func NewCreateConsumerRequest(server string, body CreateConsumerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateConsumerRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateConsumerRequestWithBody generates requests for CreateConsumer with any type of body
func NewCreateConsumerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/consumers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGroupOfConsumerRequest generates requests for DeleteGroupOfConsumer
func NewDeleteGroupOfConsumerRequest(server string, consumerNameOrId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "consumer_name_or_id", runtime.ParamLocationPath, consumerNameOrId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/consumers/%s/acls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewViewGroupConsumerRequest generates requests for ViewGroupConsumer
func NewViewGroupConsumerRequest(server string, consumerNameOrId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "consumer_name_or_id", runtime.ParamLocationPath, consumerNameOrId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/consumers/%s/acls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddConsumerToGroupRequest calls the generic AddConsumerToGroup builder with application/json body
func NewAddConsumerToGroupRequest(server string, consumerNameOrId string, body AddConsumerToGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddConsumerToGroupRequestWithBody(server, consumerNameOrId, "application/json", bodyReader)
}

// NewAddConsumerToGroupRequestWithBody generates requests for AddConsumerToGroup with any type of body
func NewAddConsumerToGroupRequestWithBody(server string, consumerNameOrId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "consumer_name_or_id", runtime.ParamLocationPath, consumerNameOrId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/consumers/%s/acls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteConsumerRequest generates requests for DeleteConsumer
func NewDeleteConsumerRequest(server string, consumerUsernameOrId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "consumer_username_or_id", runtime.ParamLocationPath, consumerUsernameOrId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/consumers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConsumerRequest generates requests for GetConsumer
func NewGetConsumerRequest(server string, consumerUsernameOrId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "consumer_username_or_id", runtime.ParamLocationPath, consumerUsernameOrId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/consumers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateConsumerRequest calls the generic UpdateConsumer builder with application/json body
func NewUpdateConsumerRequest(server string, consumerUsernameOrId string, body UpdateConsumerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateConsumerRequestWithBody(server, consumerUsernameOrId, "application/json", bodyReader)
}

// NewUpdateConsumerRequestWithBody generates requests for UpdateConsumer with any type of body
func NewUpdateConsumerRequestWithBody(server string, consumerUsernameOrId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "consumer_username_or_id", runtime.ParamLocationPath, consumerUsernameOrId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/consumers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpsertConsumerRequest calls the generic UpsertConsumer builder with application/json body
func NewUpsertConsumerRequest(server string, consumerUsernameOrId string, body UpsertConsumerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpsertConsumerRequestWithBody(server, consumerUsernameOrId, "application/json", bodyReader)
}

// NewUpsertConsumerRequestWithBody generates requests for UpsertConsumer with any type of body
func NewUpsertConsumerRequestWithBody(server string, consumerUsernameOrId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "consumer_username_or_id", runtime.ParamLocationPath, consumerUsernameOrId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/consumers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPluginsForConsumerRequest generates requests for ListPluginsForConsumer
func NewListPluginsForConsumerRequest(server string, consumerUsernameOrId string, params *ListPluginsForConsumerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "consumer_username_or_id", runtime.ParamLocationPath, consumerUsernameOrId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/consumers/%s/plugins", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Size != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePluginForConsumerRequest calls the generic CreatePluginForConsumer builder with application/json body
func NewCreatePluginForConsumerRequest(server string, consumerUsernameOrId string, body CreatePluginForConsumerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePluginForConsumerRequestWithBody(server, consumerUsernameOrId, "application/json", bodyReader)
}

// NewCreatePluginForConsumerRequestWithBody generates requests for CreatePluginForConsumer with any type of body
func NewCreatePluginForConsumerRequestWithBody(server string, consumerUsernameOrId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "consumer_username_or_id", runtime.ParamLocationPath, consumerUsernameOrId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/consumers/%s/plugins", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePluginForConsumerRequest generates requests for DeletePluginForConsumer
func NewDeletePluginForConsumerRequest(server string, consumerUsernameOrId string, pluginId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "consumer_username_or_id", runtime.ParamLocationPath, consumerUsernameOrId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_id", runtime.ParamLocationPath, pluginId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/consumers/%s/plugins/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFetchPluginForConsumerRequest generates requests for FetchPluginForConsumer
func NewFetchPluginForConsumerRequest(server string, consumerUsernameOrId string, pluginId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "consumer_username_or_id", runtime.ParamLocationPath, consumerUsernameOrId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_id", runtime.ParamLocationPath, pluginId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/consumers/%s/plugins/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePluginForConsumerRequest calls the generic UpdatePluginForConsumer builder with application/json body
func NewUpdatePluginForConsumerRequest(server string, consumerUsernameOrId string, pluginId string, body UpdatePluginForConsumerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePluginForConsumerRequestWithBody(server, consumerUsernameOrId, pluginId, "application/json", bodyReader)
}

// NewUpdatePluginForConsumerRequestWithBody generates requests for UpdatePluginForConsumer with any type of body
func NewUpdatePluginForConsumerRequestWithBody(server string, consumerUsernameOrId string, pluginId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "consumer_username_or_id", runtime.ParamLocationPath, consumerUsernameOrId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_id", runtime.ParamLocationPath, pluginId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/consumers/%s/plugins/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpsertPluginForConsumerRequest calls the generic UpsertPluginForConsumer builder with application/json body
func NewUpsertPluginForConsumerRequest(server string, consumerUsernameOrId string, pluginId string, body UpsertPluginForConsumerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpsertPluginForConsumerRequestWithBody(server, consumerUsernameOrId, pluginId, "application/json", bodyReader)
}

// NewUpsertPluginForConsumerRequestWithBody generates requests for UpsertPluginForConsumer with any type of body
func NewUpsertPluginForConsumerRequestWithBody(server string, consumerUsernameOrId string, pluginId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "consumer_username_or_id", runtime.ParamLocationPath, consumerUsernameOrId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_id", runtime.ParamLocationPath, pluginId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/consumers/%s/plugins/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutDebugClusterControlPlanesNodesLogLevelLogLevelRequest generates requests for PutDebugClusterControlPlanesNodesLogLevelLogLevel
func NewPutDebugClusterControlPlanesNodesLogLevelLogLevelRequest(server string, logLevel PutDebugClusterControlPlanesNodesLogLevelLogLevelParamsLogLevel) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "log_level", runtime.ParamLocationPath, logLevel)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/debug/cluster/control-planes-nodes/log-level/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutDebugClusterLogLevelLogLevelRequest generates requests for PutDebugClusterLogLevelLogLevel
func NewPutDebugClusterLogLevelLogLevelRequest(server string, logLevel PutDebugClusterLogLevelLogLevelParamsLogLevel) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "log_level", runtime.ParamLocationPath, logLevel)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/debug/cluster/log-level/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDebugNodeLogLevelRequest generates requests for GetDebugNodeLogLevel
func NewGetDebugNodeLogLevelRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/debug/node/log-level")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutDebugNodeLogLevelLogLevelRequest generates requests for PutDebugNodeLogLevelLogLevel
func NewPutDebugNodeLogLevelLogLevelRequest(server string, logLevel PutDebugNodeLogLevelLogLevelParamsLogLevel) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "log_level", runtime.ParamLocationPath, logLevel)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/debug/node/log-level/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEndpointsRequest generates requests for GetEndpoints
func NewGetEndpointsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/endpoints")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFilterChainsRequest generates requests for GetFilterChains
func NewGetFilterChainsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filter-chains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostFilterChainsRequest calls the generic PostFilterChains builder with application/json body
func NewPostFilterChainsRequest(server string, body PostFilterChainsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostFilterChainsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostFilterChainsRequestWithBody generates requests for PostFilterChains with any type of body
func NewPostFilterChainsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filter-chains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFilterChainsFilterChainIdRequest generates requests for DeleteFilterChainsFilterChainId
func NewDeleteFilterChainsFilterChainIdRequest(server string, filterChainId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "filter_chain_id", runtime.ParamLocationPath, filterChainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filter-chains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFilterChainsFilterChainIdRequest generates requests for GetFilterChainsFilterChainId
func NewGetFilterChainsFilterChainIdRequest(server string, filterChainId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "filter_chain_id", runtime.ParamLocationPath, filterChainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filter-chains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchFilterChainsFilterChainIdRequest calls the generic PatchFilterChainsFilterChainId builder with application/json body
func NewPatchFilterChainsFilterChainIdRequest(server string, filterChainId string, body PatchFilterChainsFilterChainIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchFilterChainsFilterChainIdRequestWithBody(server, filterChainId, "application/json", bodyReader)
}

// NewPatchFilterChainsFilterChainIdRequestWithBody generates requests for PatchFilterChainsFilterChainId with any type of body
func NewPatchFilterChainsFilterChainIdRequestWithBody(server string, filterChainId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "filter_chain_id", runtime.ParamLocationPath, filterChainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filter-chains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutFilterChainsFilterChainIdRequest calls the generic PutFilterChainsFilterChainId builder with application/json body
func NewPutFilterChainsFilterChainIdRequest(server string, filterChainId string, body PutFilterChainsFilterChainIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutFilterChainsFilterChainIdRequestWithBody(server, filterChainId, "application/json", bodyReader)
}

// NewPutFilterChainsFilterChainIdRequestWithBody generates requests for PutFilterChainsFilterChainId with any type of body
func NewPutFilterChainsFilterChainIdRequestWithBody(server string, filterChainId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "filter_chain_id", runtime.ParamLocationPath, filterChainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filter-chains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListKeySetRequest generates requests for ListKeySet
func NewListKeySetRequest(server string, params *ListKeySetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/key-sets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Size != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateKeySetRequest calls the generic CreateKeySet builder with application/json body
func NewCreateKeySetRequest(server string, body CreateKeySetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateKeySetRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateKeySetRequestWithBody generates requests for CreateKeySet with any type of body
func NewCreateKeySetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/key-sets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteKeySetRequest generates requests for DeleteKeySet
func NewDeleteKeySetRequest(server string, keySetIdOrName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key-set_id_or_name", runtime.ParamLocationPath, keySetIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/key-sets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeySetRequest generates requests for GetKeySet
func NewGetKeySetRequest(server string, keySetIdOrName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key-set_id_or_name", runtime.ParamLocationPath, keySetIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/key-sets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateKeySetRequest calls the generic UpdateKeySet builder with application/json body
func NewUpdateKeySetRequest(server string, keySetIdOrName string, body UpdateKeySetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateKeySetRequestWithBody(server, keySetIdOrName, "application/json", bodyReader)
}

// NewUpdateKeySetRequestWithBody generates requests for UpdateKeySet with any type of body
func NewUpdateKeySetRequestWithBody(server string, keySetIdOrName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key-set_id_or_name", runtime.ParamLocationPath, keySetIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/key-sets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpsertKeySetRequest calls the generic UpsertKeySet builder with application/json body
func NewUpsertKeySetRequest(server string, keySetIdOrName string, body UpsertKeySetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpsertKeySetRequestWithBody(server, keySetIdOrName, "application/json", bodyReader)
}

// NewUpsertKeySetRequestWithBody generates requests for UpsertKeySet with any type of body
func NewUpsertKeySetRequestWithBody(server string, keySetIdOrName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key-set_id_or_name", runtime.ParamLocationPath, keySetIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/key-sets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListKeyRequest generates requests for ListKey
func NewListKeyRequest(server string, params *ListKeyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Size != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateKeyRequest calls the generic CreateKey builder with application/json body
func NewCreateKeyRequest(server string, body CreateKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateKeyRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateKeyRequestWithBody generates requests for CreateKey with any type of body
func NewCreateKeyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteKeyRequest generates requests for DeleteKey
func NewDeleteKeyRequest(server string, keyIdOrName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key_id_or_name", runtime.ParamLocationPath, keyIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeyRequest generates requests for GetKey
func NewGetKeyRequest(server string, keyIdOrName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key_id_or_name", runtime.ParamLocationPath, keyIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateKeyRequest calls the generic UpdateKey builder with application/json body
func NewUpdateKeyRequest(server string, keyIdOrName string, body UpdateKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateKeyRequestWithBody(server, keyIdOrName, "application/json", bodyReader)
}

// NewUpdateKeyRequestWithBody generates requests for UpdateKey with any type of body
func NewUpdateKeyRequestWithBody(server string, keyIdOrName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key_id_or_name", runtime.ParamLocationPath, keyIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpsertKeyRequest calls the generic UpsertKey builder with application/json body
func NewUpsertKeyRequest(server string, keyIdOrName string, body UpsertKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpsertKeyRequestWithBody(server, keyIdOrName, "application/json", bodyReader)
}

// NewUpsertKeyRequestWithBody generates requests for UpsertKey with any type of body
func NewUpsertKeyRequestWithBody(server string, keyIdOrName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key_id_or_name", runtime.ParamLocationPath, keyIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPluginRequest generates requests for ListPlugin
func NewListPluginRequest(server string, params *ListPluginParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Size != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePluginRequest calls the generic CreatePlugin builder with application/json body
func NewCreatePluginRequest(server string, body CreatePluginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePluginRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePluginRequestWithBody generates requests for CreatePlugin with any type of body
func NewCreatePluginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePluginRequest generates requests for DeletePlugin
func NewDeletePluginRequest(server string, pluginId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "plugin_id", runtime.ParamLocationPath, pluginId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPluginRequest generates requests for GetPlugin
func NewGetPluginRequest(server string, pluginId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "plugin_id", runtime.ParamLocationPath, pluginId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePluginRequest calls the generic UpdatePlugin builder with application/json body
func NewUpdatePluginRequest(server string, pluginId string, body UpdatePluginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePluginRequestWithBody(server, pluginId, "application/json", bodyReader)
}

// NewUpdatePluginRequestWithBody generates requests for UpdatePlugin with any type of body
func NewUpdatePluginRequestWithBody(server string, pluginId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "plugin_id", runtime.ParamLocationPath, pluginId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpsertPluginRequest calls the generic UpsertPlugin builder with application/json body
func NewUpsertPluginRequest(server string, pluginId string, body UpsertPluginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpsertPluginRequestWithBody(server, pluginId, "application/json", bodyReader)
}

// NewUpsertPluginRequestWithBody generates requests for UpsertPlugin with any type of body
func NewUpsertPluginRequestWithBody(server string, pluginId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "plugin_id", runtime.ParamLocationPath, pluginId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListRouteRequest generates requests for ListRoute
func NewListRouteRequest(server string, params *ListRouteParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Size != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRouteRequest calls the generic CreateRoute builder with application/json body
func NewCreateRouteRequest(server string, body CreateRouteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRouteRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateRouteRequestWithBody generates requests for CreateRoute with any type of body
func NewCreateRouteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRouteRequest generates requests for DeleteRoute
func NewDeleteRouteRequest(server string, routeIdOrName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "route_id_or_name", runtime.ParamLocationPath, routeIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRouteRequest generates requests for GetRoute
func NewGetRouteRequest(server string, routeIdOrName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "route_id_or_name", runtime.ParamLocationPath, routeIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRouteRequest calls the generic UpdateRoute builder with application/json body
func NewUpdateRouteRequest(server string, routeIdOrName string, body UpdateRouteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRouteRequestWithBody(server, routeIdOrName, "application/json", bodyReader)
}

// NewUpdateRouteRequestWithBody generates requests for UpdateRoute with any type of body
func NewUpdateRouteRequestWithBody(server string, routeIdOrName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "route_id_or_name", runtime.ParamLocationPath, routeIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpsertRouteRequest calls the generic UpsertRoute builder with application/json body
func NewUpsertRouteRequest(server string, routeIdOrName string, body UpsertRouteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpsertRouteRequestWithBody(server, routeIdOrName, "application/json", bodyReader)
}

// NewUpsertRouteRequestWithBody generates requests for UpsertRoute with any type of body
func NewUpsertRouteRequestWithBody(server string, routeIdOrName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "route_id_or_name", runtime.ParamLocationPath, routeIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRoutesRouteIdOrNameFilterChainsRequest generates requests for GetRoutesRouteIdOrNameFilterChains
func NewGetRoutesRouteIdOrNameFilterChainsRequest(server string, routeIdOrName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "route_id_or_name", runtime.ParamLocationPath, routeIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routes/%s/filter-chains", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchRoutesRouteIdOrNameFilterChainsRequest calls the generic PatchRoutesRouteIdOrNameFilterChains builder with application/json body
func NewPatchRoutesRouteIdOrNameFilterChainsRequest(server string, routeIdOrName string, body PatchRoutesRouteIdOrNameFilterChainsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchRoutesRouteIdOrNameFilterChainsRequestWithBody(server, routeIdOrName, "application/json", bodyReader)
}

// NewPatchRoutesRouteIdOrNameFilterChainsRequestWithBody generates requests for PatchRoutesRouteIdOrNameFilterChains with any type of body
func NewPatchRoutesRouteIdOrNameFilterChainsRequestWithBody(server string, routeIdOrName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "route_id_or_name", runtime.ParamLocationPath, routeIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routes/%s/filter-chains", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRoutesRouteNameOrIdFilterChainsRequest calls the generic GetRoutesRouteNameOrIdFilterChains builder with application/json body
func NewGetRoutesRouteNameOrIdFilterChainsRequest(server string, routeIdOrName string, body GetRoutesRouteNameOrIdFilterChainsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetRoutesRouteNameOrIdFilterChainsRequestWithBody(server, routeIdOrName, "application/json", bodyReader)
}

// NewGetRoutesRouteNameOrIdFilterChainsRequestWithBody generates requests for GetRoutesRouteNameOrIdFilterChains with any type of body
func NewGetRoutesRouteNameOrIdFilterChainsRequestWithBody(server string, routeIdOrName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "route_id_or_name", runtime.ParamLocationPath, routeIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routes/%s/filter-chains", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRoutesRouteIdOrNameFilterChainsFilterChainIdRequest generates requests for GetRoutesRouteIdOrNameFilterChainsFilterChainId
func NewGetRoutesRouteIdOrNameFilterChainsFilterChainIdRequest(server string, routeIdOrName string, filterChainId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "route_id_or_name", runtime.ParamLocationPath, routeIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "filter_chain_id", runtime.ParamLocationPath, filterChainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routes/%s/filter-chains/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutRoutesRouteIdOrNameFilterChainsFilterChainIdRequest calls the generic PutRoutesRouteIdOrNameFilterChainsFilterChainId builder with application/json body
func NewPutRoutesRouteIdOrNameFilterChainsFilterChainIdRequest(server string, routeIdOrName string, filterChainId string, body PutRoutesRouteIdOrNameFilterChainsFilterChainIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutRoutesRouteIdOrNameFilterChainsFilterChainIdRequestWithBody(server, routeIdOrName, filterChainId, "application/json", bodyReader)
}

// NewPutRoutesRouteIdOrNameFilterChainsFilterChainIdRequestWithBody generates requests for PutRoutesRouteIdOrNameFilterChainsFilterChainId with any type of body
func NewPutRoutesRouteIdOrNameFilterChainsFilterChainIdRequestWithBody(server string, routeIdOrName string, filterChainId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "route_id_or_name", runtime.ParamLocationPath, routeIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "filter_chain_id", runtime.ParamLocationPath, filterChainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routes/%s/filter-chains/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPluginsForRouteRequest generates requests for ListPluginsForRoute
func NewListPluginsForRouteRequest(server string, routeIdOrName string, params *ListPluginsForRouteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "route_id_or_name", runtime.ParamLocationPath, routeIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routes/%s/plugins", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Size != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePluginForRouteRequest calls the generic CreatePluginForRoute builder with application/json body
func NewCreatePluginForRouteRequest(server string, routeIdOrName string, body CreatePluginForRouteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePluginForRouteRequestWithBody(server, routeIdOrName, "application/json", bodyReader)
}

// NewCreatePluginForRouteRequestWithBody generates requests for CreatePluginForRoute with any type of body
func NewCreatePluginForRouteRequestWithBody(server string, routeIdOrName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "route_id_or_name", runtime.ParamLocationPath, routeIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routes/%s/plugins", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePluginForRouteRequest generates requests for DeletePluginForRoute
func NewDeletePluginForRouteRequest(server string, routeIdOrName string, pluginId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "route_id_or_name", runtime.ParamLocationPath, routeIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_id", runtime.ParamLocationPath, pluginId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routes/%s/plugins/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFetchPluginForRouteRequest generates requests for FetchPluginForRoute
func NewFetchPluginForRouteRequest(server string, routeIdOrName string, pluginId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "route_id_or_name", runtime.ParamLocationPath, routeIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_id", runtime.ParamLocationPath, pluginId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routes/%s/plugins/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePluginForRouteRequest calls the generic UpdatePluginForRoute builder with application/json body
func NewUpdatePluginForRouteRequest(server string, routeIdOrName string, pluginId string, body UpdatePluginForRouteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePluginForRouteRequestWithBody(server, routeIdOrName, pluginId, "application/json", bodyReader)
}

// NewUpdatePluginForRouteRequestWithBody generates requests for UpdatePluginForRoute with any type of body
func NewUpdatePluginForRouteRequestWithBody(server string, routeIdOrName string, pluginId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "route_id_or_name", runtime.ParamLocationPath, routeIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_id", runtime.ParamLocationPath, pluginId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routes/%s/plugins/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpsertPluginForRouteRequest calls the generic UpsertPluginForRoute builder with application/json body
func NewUpsertPluginForRouteRequest(server string, routeIdOrName string, pluginId string, body UpsertPluginForRouteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpsertPluginForRouteRequestWithBody(server, routeIdOrName, pluginId, "application/json", bodyReader)
}

// NewUpsertPluginForRouteRequestWithBody generates requests for UpsertPluginForRoute with any type of body
func NewUpsertPluginForRouteRequestWithBody(server string, routeIdOrName string, pluginId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "route_id_or_name", runtime.ParamLocationPath, routeIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_id", runtime.ParamLocationPath, pluginId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routes/%s/plugins/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRoutesRouteIdOrNameFilterChainIdRequest generates requests for GetRoutesRouteIdOrNameFilterChainId
func NewGetRoutesRouteIdOrNameFilterChainIdRequest(server string, routeIdOrName string, filterChainId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "route_id_or_name", runtime.ParamLocationPath, routeIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "filter_chain_id", runtime.ParamLocationPath, filterChainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routes/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSchemasFiltersFilterNameRequest generates requests for GetSchemasFiltersFilterName
func NewGetSchemasFiltersFilterNameRequest(server string, filterName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "filter_name", runtime.ParamLocationPath, filterName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas/filters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSchemasPluginsValidateRequest generates requests for PostSchemasPluginsValidate
func NewPostSchemasPluginsValidateRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas/plugins/validate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSchemasPluginsPluginNameRequest generates requests for GetSchemasPluginsPluginName
func NewGetSchemasPluginsPluginNameRequest(server string, pluginName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas/plugins/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSchemasVaultsVaultNameRequest generates requests for GetSchemasVaultsVaultName
func NewGetSchemasVaultsVaultNameRequest(server string, vaultName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vault_name", runtime.ParamLocationPath, vaultName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas/vaults/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSchemasVaultsValidateRequest calls the generic PostSchemasVaultsValidate builder with application/json body
func NewPostSchemasVaultsValidateRequest(server string, vaultName string, body PostSchemasVaultsValidateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSchemasVaultsValidateRequestWithBody(server, vaultName, "application/json", bodyReader)
}

// NewPostSchemasVaultsValidateRequestWithBody generates requests for PostSchemasVaultsValidate with any type of body
func NewPostSchemasVaultsValidateRequestWithBody(server string, vaultName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vault_name", runtime.ParamLocationPath, vaultName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas/vaults/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSchemasEntityRequest generates requests for GetSchemasEntity
func NewGetSchemasEntityRequest(server string, entity string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "entity", runtime.ParamLocationPath, entity)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSchemasEntityValidateRequest generates requests for PostSchemasEntityValidate
func NewPostSchemasEntityValidateRequest(server string, entity string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "entity", runtime.ParamLocationPath, entity)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas/%s/validate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListServiceRequest generates requests for ListService
func NewListServiceRequest(server string, params *ListServiceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Size != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServiceRequest calls the generic CreateService builder with application/json body
func NewCreateServiceRequest(server string, body CreateServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServiceRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateServiceRequestWithBody generates requests for CreateService with any type of body
func NewCreateServiceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServiceRequest generates requests for DeleteService
func NewDeleteServiceRequest(server string, serviceIdOrName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "service_id_or_name", runtime.ParamLocationPath, serviceIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServiceRequest generates requests for GetService
func NewGetServiceRequest(server string, serviceIdOrName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "service_id_or_name", runtime.ParamLocationPath, serviceIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateServiceRequest calls the generic UpdateService builder with application/json body
func NewUpdateServiceRequest(server string, serviceIdOrName string, body UpdateServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateServiceRequestWithBody(server, serviceIdOrName, "application/json", bodyReader)
}

// NewUpdateServiceRequestWithBody generates requests for UpdateService with any type of body
func NewUpdateServiceRequestWithBody(server string, serviceIdOrName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "service_id_or_name", runtime.ParamLocationPath, serviceIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpsertServiceRequest calls the generic UpsertService builder with application/json body
func NewUpsertServiceRequest(server string, serviceIdOrName string, body UpsertServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpsertServiceRequestWithBody(server, serviceIdOrName, "application/json", bodyReader)
}

// NewUpsertServiceRequestWithBody generates requests for UpsertService with any type of body
func NewUpsertServiceRequestWithBody(server string, serviceIdOrName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "service_id_or_name", runtime.ParamLocationPath, serviceIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetServiceIdOrNameFilterChainsRequest generates requests for GetServiceIdOrNameFilterChains
func NewGetServiceIdOrNameFilterChainsRequest(server string, serviceIdOrName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "service_id_or_name", runtime.ParamLocationPath, serviceIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s/filter-chains", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServicesServiceIdOrNameFilterChainsRequest calls the generic GetServicesServiceIdOrNameFilterChains builder with application/json body
func NewGetServicesServiceIdOrNameFilterChainsRequest(server string, serviceIdOrName string, body GetServicesServiceIdOrNameFilterChainsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetServicesServiceIdOrNameFilterChainsRequestWithBody(server, serviceIdOrName, "application/json", bodyReader)
}

// NewGetServicesServiceIdOrNameFilterChainsRequestWithBody generates requests for GetServicesServiceIdOrNameFilterChains with any type of body
func NewGetServicesServiceIdOrNameFilterChainsRequestWithBody(server string, serviceIdOrName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "service_id_or_name", runtime.ParamLocationPath, serviceIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s/filter-chains", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServicesServiceIdOrNameFilterChainsFilterChainIdRequest generates requests for DeleteServicesServiceIdOrNameFilterChainsFilterChainId
func NewDeleteServicesServiceIdOrNameFilterChainsFilterChainIdRequest(server string, serviceIdOrName string, filterChainId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "service_id_or_name", runtime.ParamLocationPath, serviceIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "filter_chain_id", runtime.ParamLocationPath, filterChainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s/filter-chains/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePluginForAServiceRequest generates requests for DeletePluginForAService
func NewDeletePluginForAServiceRequest(server string, serviceIdOrName string, pluginId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "service_id_or_name", runtime.ParamLocationPath, serviceIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_id", runtime.ParamLocationPath, pluginId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s/plugins/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFetchPluginWithAServiceRequest generates requests for FetchPluginWithAService
func NewFetchPluginWithAServiceRequest(server string, serviceIdOrName string, pluginId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "service_id_or_name", runtime.ParamLocationPath, serviceIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_id", runtime.ParamLocationPath, pluginId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s/plugins/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePluginForAServiceRequest calls the generic UpdatePluginForAService builder with application/json body
func NewUpdatePluginForAServiceRequest(server string, serviceIdOrName string, pluginId string, body UpdatePluginForAServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePluginForAServiceRequestWithBody(server, serviceIdOrName, pluginId, "application/json", bodyReader)
}

// NewUpdatePluginForAServiceRequestWithBody generates requests for UpdatePluginForAService with any type of body
func NewUpdatePluginForAServiceRequestWithBody(server string, serviceIdOrName string, pluginId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "service_id_or_name", runtime.ParamLocationPath, serviceIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_id", runtime.ParamLocationPath, pluginId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s/plugins/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpsertPluginForAServiceRequest calls the generic UpsertPluginForAService builder with application/json body
func NewUpsertPluginForAServiceRequest(server string, serviceIdOrName string, pluginId string, body UpsertPluginForAServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpsertPluginForAServiceRequestWithBody(server, serviceIdOrName, pluginId, "application/json", bodyReader)
}

// NewUpsertPluginForAServiceRequestWithBody generates requests for UpsertPluginForAService with any type of body
func NewUpsertPluginForAServiceRequestWithBody(server string, serviceIdOrName string, pluginId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "service_id_or_name", runtime.ParamLocationPath, serviceIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_id", runtime.ParamLocationPath, pluginId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s/plugins/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListRoutesForServiceRequest generates requests for ListRoutesForService
func NewListRoutesForServiceRequest(server string, serviceIdOrName string, params *ListRoutesForServiceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "service_id_or_name", runtime.ParamLocationPath, serviceIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s/routes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Size != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRouteForServiceRequest calls the generic CreateRouteForService builder with application/json body
func NewCreateRouteForServiceRequest(server string, serviceIdOrName string, body CreateRouteForServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRouteForServiceRequestWithBody(server, serviceIdOrName, "application/json", bodyReader)
}

// NewCreateRouteForServiceRequestWithBody generates requests for CreateRouteForService with any type of body
func NewCreateRouteForServiceRequestWithBody(server string, serviceIdOrName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "service_id_or_name", runtime.ParamLocationPath, serviceIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s/routes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRouteForServiceRequest generates requests for DeleteRouteForService
func NewDeleteRouteForServiceRequest(server string, serviceIdOrName string, routeIdOrName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "service_id_or_name", runtime.ParamLocationPath, serviceIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "route_id_or_name", runtime.ParamLocationPath, routeIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s/routes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFetchRouteForServiceRequest generates requests for FetchRouteForService
func NewFetchRouteForServiceRequest(server string, serviceIdOrName string, routeIdOrName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "service_id_or_name", runtime.ParamLocationPath, serviceIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "route_id_or_name", runtime.ParamLocationPath, routeIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s/routes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRouteForServiceRequest calls the generic UpdateRouteForService builder with application/json body
func NewUpdateRouteForServiceRequest(server string, serviceIdOrName string, routeIdOrName string, body UpdateRouteForServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRouteForServiceRequestWithBody(server, serviceIdOrName, routeIdOrName, "application/json", bodyReader)
}

// NewUpdateRouteForServiceRequestWithBody generates requests for UpdateRouteForService with any type of body
func NewUpdateRouteForServiceRequestWithBody(server string, serviceIdOrName string, routeIdOrName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "service_id_or_name", runtime.ParamLocationPath, serviceIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "route_id_or_name", runtime.ParamLocationPath, routeIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s/routes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpsertRouteForServiceRequest calls the generic UpsertRouteForService builder with application/json body
func NewUpsertRouteForServiceRequest(server string, serviceIdOrName string, routeIdOrName string, body UpsertRouteForServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpsertRouteForServiceRequestWithBody(server, serviceIdOrName, routeIdOrName, "application/json", bodyReader)
}

// NewUpsertRouteForServiceRequestWithBody generates requests for UpsertRouteForService with any type of body
func NewUpsertRouteForServiceRequestWithBody(server string, serviceIdOrName string, routeIdOrName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "service_id_or_name", runtime.ParamLocationPath, serviceIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "route_id_or_name", runtime.ParamLocationPath, routeIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s/routes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPluginsForServiceRequest generates requests for GetPluginsForService
func NewGetPluginsForServiceRequest(server string, serviceIdOrName string, params *GetPluginsForServiceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "service_id_or_name", runtime.ParamLocationPath, serviceIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%splugins", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Size != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePluginForServiceRequest calls the generic CreatePluginForService builder with application/json body
func NewCreatePluginForServiceRequest(server string, serviceIdOrName string, body CreatePluginForServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePluginForServiceRequestWithBody(server, serviceIdOrName, "application/json", bodyReader)
}

// NewCreatePluginForServiceRequestWithBody generates requests for CreatePluginForService with any type of body
func NewCreatePluginForServiceRequestWithBody(server string, serviceIdOrName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "service_id_or_name", runtime.ParamLocationPath, serviceIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%splugins", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSniRequest generates requests for ListSni
func NewListSniRequest(server string, params *ListSniParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/snis")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Size != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSniRequest calls the generic CreateSni builder with application/json body
func NewCreateSniRequest(server string, body CreateSniJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSniRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSniRequestWithBody generates requests for CreateSni with any type of body
func NewCreateSniRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/snis")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSniRequest generates requests for DeleteSni
func NewDeleteSniRequest(server string, sniNameOrId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sni_name_or_id", runtime.ParamLocationPath, sniNameOrId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/snis/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSniRequest generates requests for GetSni
func NewGetSniRequest(server string, sniNameOrId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sni_name_or_id", runtime.ParamLocationPath, sniNameOrId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/snis/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSniRequest calls the generic UpdateSni builder with application/json body
func NewUpdateSniRequest(server string, sniNameOrId string, body UpdateSniJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSniRequestWithBody(server, sniNameOrId, "application/json", bodyReader)
}

// NewUpdateSniRequestWithBody generates requests for UpdateSni with any type of body
func NewUpdateSniRequestWithBody(server string, sniNameOrId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sni_name_or_id", runtime.ParamLocationPath, sniNameOrId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/snis/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpsertSniRequest calls the generic UpsertSni builder with application/json body
func NewUpsertSniRequest(server string, sniNameOrId string, body UpsertSniJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpsertSniRequestWithBody(server, sniNameOrId, "application/json", bodyReader)
}

// NewUpsertSniRequestWithBody generates requests for UpsertSni with any type of body
func NewUpsertSniRequestWithBody(server string, sniNameOrId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sni_name_or_id", runtime.ParamLocationPath, sniNameOrId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/snis/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetStatusRequest generates requests for GetStatus
func NewGetStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDnsStatusRequest generates requests for GetDnsStatus
func NewGetDnsStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/status/dns")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTagsRequest generates requests for GetTags
func NewGetTagsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTagsTagsRequest generates requests for GetTagsTags
func NewGetTagsTagsRequest(server string, tags string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tags", runtime.ParamLocationPath, tags)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTimersRequest generates requests for GetTimers
func NewGetTimersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUpstreamRequest generates requests for ListUpstream
func NewListUpstreamRequest(server string, params *ListUpstreamParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/upstreams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Size != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUpstreamRequest calls the generic CreateUpstream builder with application/json body
func NewCreateUpstreamRequest(server string, body CreateUpstreamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUpstreamRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateUpstreamRequestWithBody generates requests for CreateUpstream with any type of body
func NewCreateUpstreamRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/upstreams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUpstreamRequest generates requests for DeleteUpstream
func NewDeleteUpstreamRequest(server string, upstreamIdOrName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "upstream_id_or_name", runtime.ParamLocationPath, upstreamIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/upstreams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUpstreamRequest generates requests for GetUpstream
func NewGetUpstreamRequest(server string, upstreamIdOrName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "upstream_id_or_name", runtime.ParamLocationPath, upstreamIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/upstreams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUpstreamRequest calls the generic UpdateUpstream builder with application/json body
func NewUpdateUpstreamRequest(server string, upstreamIdOrName string, body UpdateUpstreamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUpstreamRequestWithBody(server, upstreamIdOrName, "application/json", bodyReader)
}

// NewUpdateUpstreamRequestWithBody generates requests for UpdateUpstream with any type of body
func NewUpdateUpstreamRequestWithBody(server string, upstreamIdOrName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "upstream_id_or_name", runtime.ParamLocationPath, upstreamIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/upstreams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpsertUpstreamRequest calls the generic UpsertUpstream builder with application/json body
func NewUpsertUpstreamRequest(server string, upstreamIdOrName string, body UpsertUpstreamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpsertUpstreamRequestWithBody(server, upstreamIdOrName, "application/json", bodyReader)
}

// NewUpsertUpstreamRequestWithBody generates requests for UpsertUpstream with any type of body
func NewUpsertUpstreamRequestWithBody(server string, upstreamIdOrName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "upstream_id_or_name", runtime.ParamLocationPath, upstreamIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/upstreams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListTargetsForUpstreamRequest generates requests for ListTargetsForUpstream
func NewListTargetsForUpstreamRequest(server string, upstreamIdOrName string, params *ListTargetsForUpstreamParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "upstream_id_or_name", runtime.ParamLocationPath, upstreamIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/upstreams/%s/targets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Size != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTargetForUpstreamRequest calls the generic CreateTargetForUpstream builder with application/json body
func NewCreateTargetForUpstreamRequest(server string, upstreamIdOrName string, body CreateTargetForUpstreamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTargetForUpstreamRequestWithBody(server, upstreamIdOrName, "application/json", bodyReader)
}

// NewCreateTargetForUpstreamRequestWithBody generates requests for CreateTargetForUpstream with any type of body
func NewCreateTargetForUpstreamRequestWithBody(server string, upstreamIdOrName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "upstream_id_or_name", runtime.ParamLocationPath, upstreamIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/upstreams/%s/targets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUpstreamTargetRequest generates requests for DeleteUpstreamTarget
func NewDeleteUpstreamTargetRequest(server string, upstreamIdOrName string, targetIdOrTarget string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "upstream_id_or_name", runtime.ParamLocationPath, upstreamIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "target_id_or_target", runtime.ParamLocationPath, targetIdOrTarget)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/upstreams/%s/targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFetchTargetForUpstreamRequest generates requests for FetchTargetForUpstream
func NewFetchTargetForUpstreamRequest(server string, upstreamIdOrName string, targetIdOrTarget string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "upstream_id_or_name", runtime.ParamLocationPath, upstreamIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "target_id_or_target", runtime.ParamLocationPath, targetIdOrTarget)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/upstreams/%s/targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTargetForUpstreamRequest calls the generic UpdateTargetForUpstream builder with application/json body
func NewUpdateTargetForUpstreamRequest(server string, upstreamIdOrName string, targetIdOrTarget string, body UpdateTargetForUpstreamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTargetForUpstreamRequestWithBody(server, upstreamIdOrName, targetIdOrTarget, "application/json", bodyReader)
}

// NewUpdateTargetForUpstreamRequestWithBody generates requests for UpdateTargetForUpstream with any type of body
func NewUpdateTargetForUpstreamRequestWithBody(server string, upstreamIdOrName string, targetIdOrTarget string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "upstream_id_or_name", runtime.ParamLocationPath, upstreamIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "target_id_or_target", runtime.ParamLocationPath, targetIdOrTarget)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/upstreams/%s/targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpsertTargetForUpstreamRequest calls the generic UpsertTargetForUpstream builder with application/json body
func NewUpsertTargetForUpstreamRequest(server string, upstreamIdOrName string, targetIdOrTarget string, body UpsertTargetForUpstreamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpsertTargetForUpstreamRequestWithBody(server, upstreamIdOrName, targetIdOrTarget, "application/json", bodyReader)
}

// NewUpsertTargetForUpstreamRequestWithBody generates requests for UpsertTargetForUpstream with any type of body
func NewUpsertTargetForUpstreamRequestWithBody(server string, upstreamIdOrName string, targetIdOrTarget string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "upstream_id_or_name", runtime.ParamLocationPath, upstreamIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "target_id_or_target", runtime.ParamLocationPath, targetIdOrTarget)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/upstreams/%s/targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListVaultRequest generates requests for ListVault
func NewListVaultRequest(server string, params *ListVaultParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vaults")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Size != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVaultRequest calls the generic CreateVault builder with application/json body
func NewCreateVaultRequest(server string, body CreateVaultJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVaultRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateVaultRequestWithBody generates requests for CreateVault with any type of body
func NewCreateVaultRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vaults")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVaultRequest generates requests for DeleteVault
func NewDeleteVaultRequest(server string, vaultIdOrPrefix string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vault_id_or_prefix", runtime.ParamLocationPath, vaultIdOrPrefix)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vaults/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVaultRequest generates requests for GetVault
func NewGetVaultRequest(server string, vaultIdOrPrefix string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vault_id_or_prefix", runtime.ParamLocationPath, vaultIdOrPrefix)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vaults/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVaultRequest calls the generic UpdateVault builder with application/json body
func NewUpdateVaultRequest(server string, vaultIdOrPrefix string, body UpdateVaultJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVaultRequestWithBody(server, vaultIdOrPrefix, "application/json", bodyReader)
}

// NewUpdateVaultRequestWithBody generates requests for UpdateVault with any type of body
func NewUpdateVaultRequestWithBody(server string, vaultIdOrPrefix string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vault_id_or_prefix", runtime.ParamLocationPath, vaultIdOrPrefix)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vaults/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpsertVaultRequest calls the generic UpsertVault builder with application/json body
func NewUpsertVaultRequest(server string, vaultIdOrPrefix string, body UpsertVaultJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpsertVaultRequestWithBody(server, vaultIdOrPrefix, "application/json", bodyReader)
}

// NewUpsertVaultRequestWithBody generates requests for UpsertVault with any type of body
func NewUpsertVaultRequestWithBody(server string, vaultIdOrPrefix string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vault_id_or_prefix", runtime.ParamLocationPath, vaultIdOrPrefix)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vaults/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewHeadEndpointsRequest generates requests for HeadEndpoints
func NewHeadEndpointsRequest(server string, endpoint string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "endpoint", runtime.ParamLocationPath, endpoint)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOptionsEndpointRequest generates requests for OptionsEndpoint
func NewOptionsEndpointRequest(server string, endpoint string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "endpoint", runtime.ParamLocationPath, endpoint)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("OPTIONS", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GeInfoWithResponse request
	GeInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GeInfoResponse, error)

	// ListCaCertificateWithResponse request
	ListCaCertificateWithResponse(ctx context.Context, params *ListCaCertificateParams, reqEditors ...RequestEditorFn) (*ListCaCertificateResponse, error)

	// CreateCaCertificateWithBodyWithResponse request with any body
	CreateCaCertificateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCaCertificateResponse, error)

	CreateCaCertificateWithResponse(ctx context.Context, body CreateCaCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCaCertificateResponse, error)

	// DeleteCaCertificateWithResponse request
	DeleteCaCertificateWithResponse(ctx context.Context, caCertificateId string, reqEditors ...RequestEditorFn) (*DeleteCaCertificateResponse, error)

	// GetCaCertificateWithResponse request
	GetCaCertificateWithResponse(ctx context.Context, caCertificateId string, reqEditors ...RequestEditorFn) (*GetCaCertificateResponse, error)

	// UpdateCaCertificateWithBodyWithResponse request with any body
	UpdateCaCertificateWithBodyWithResponse(ctx context.Context, caCertificateId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCaCertificateResponse, error)

	UpdateCaCertificateWithResponse(ctx context.Context, caCertificateId string, body UpdateCaCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCaCertificateResponse, error)

	// UpdatetCaCertificateWithBodyWithResponse request with any body
	UpdatetCaCertificateWithBodyWithResponse(ctx context.Context, caCertificateId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatetCaCertificateResponse, error)

	UpdatetCaCertificateWithResponse(ctx context.Context, caCertificateId string, body UpdatetCaCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatetCaCertificateResponse, error)

	// PurgeAllCacheWithResponse request
	PurgeAllCacheWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PurgeAllCacheResponse, error)

	// DeleteCacheByKeyWithResponse request
	DeleteCacheByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*DeleteCacheByKeyResponse, error)

	// GetCacheByKeyWithResponse request
	GetCacheByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetCacheByKeyResponse, error)

	// ListCertificateWithResponse request
	ListCertificateWithResponse(ctx context.Context, params *ListCertificateParams, reqEditors ...RequestEditorFn) (*ListCertificateResponse, error)

	// CreateCertificateWithBodyWithResponse request with any body
	CreateCertificateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCertificateResponse, error)

	CreateCertificateWithResponse(ctx context.Context, body CreateCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCertificateResponse, error)

	// DeleteCertificateWithResponse request
	DeleteCertificateWithResponse(ctx context.Context, certificateId string, reqEditors ...RequestEditorFn) (*DeleteCertificateResponse, error)

	// GetCertificateWithResponse request
	GetCertificateWithResponse(ctx context.Context, certificateId string, reqEditors ...RequestEditorFn) (*GetCertificateResponse, error)

	// UpdateCertificateWithBodyWithResponse request with any body
	UpdateCertificateWithBodyWithResponse(ctx context.Context, certificateId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCertificateResponse, error)

	UpdateCertificateWithResponse(ctx context.Context, certificateId string, body UpdateCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCertificateResponse, error)

	// UpdateCertificatePutWithBodyWithResponse request with any body
	UpdateCertificatePutWithBodyWithResponse(ctx context.Context, certificateId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCertificatePutResponse, error)

	UpdateCertificatePutWithResponse(ctx context.Context, certificateId string, body UpdateCertificatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCertificatePutResponse, error)

	// DeleteSniForCertificateWithResponse request
	DeleteSniForCertificateWithResponse(ctx context.Context, certificateId string, sniNameOrId string, reqEditors ...RequestEditorFn) (*DeleteSniForCertificateResponse, error)

	// FetchSniWithCertificateWithResponse request
	FetchSniWithCertificateWithResponse(ctx context.Context, certificateId string, sniNameOrId string, reqEditors ...RequestEditorFn) (*FetchSniWithCertificateResponse, error)

	// UpdateSniForCertificateWithBodyWithResponse request with any body
	UpdateSniForCertificateWithBodyWithResponse(ctx context.Context, certificateId string, sniNameOrId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSniForCertificateResponse, error)

	UpdateSniForCertificateWithResponse(ctx context.Context, certificateId string, sniNameOrId string, body UpdateSniForCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSniForCertificateResponse, error)

	// UpsertSniForCertificateWithBodyWithResponse request with any body
	UpsertSniForCertificateWithBodyWithResponse(ctx context.Context, certificateId string, sniNameOrId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertSniForCertificateResponse, error)

	UpsertSniForCertificateWithResponse(ctx context.Context, certificateId string, sniNameOrId string, body UpsertSniForCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertSniForCertificateResponse, error)

	// GetSniWithCertificateWithResponse request
	GetSniWithCertificateWithResponse(ctx context.Context, certificateNameOrId GetSniWithCertificateParamsCertificateNameOrId, params *GetSniWithCertificateParams, reqEditors ...RequestEditorFn) (*GetSniWithCertificateResponse, error)

	// CreateSniForCertificateWithBodyWithResponse request with any body
	CreateSniForCertificateWithBodyWithResponse(ctx context.Context, certificateNameOrId CreateSniForCertificateParamsCertificateNameOrId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSniForCertificateResponse, error)

	CreateSniForCertificateWithResponse(ctx context.Context, certificateNameOrId CreateSniForCertificateParamsCertificateNameOrId, body CreateSniForCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSniForCertificateResponse, error)

	// GetDataPlanesWithResponse request
	GetDataPlanesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDataPlanesResponse, error)

	// GetDataPlaneStatusWithResponse request
	GetDataPlaneStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDataPlaneStatusResponse, error)

	// ListConsumerWithResponse request
	ListConsumerWithResponse(ctx context.Context, params *ListConsumerParams, reqEditors ...RequestEditorFn) (*ListConsumerResponse, error)

	// CreateConsumerWithBodyWithResponse request with any body
	CreateConsumerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateConsumerResponse, error)

	CreateConsumerWithResponse(ctx context.Context, body CreateConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateConsumerResponse, error)

	// DeleteGroupOfConsumerWithResponse request
	DeleteGroupOfConsumerWithResponse(ctx context.Context, consumerNameOrId string, reqEditors ...RequestEditorFn) (*DeleteGroupOfConsumerResponse, error)

	// ViewGroupConsumerWithResponse request
	ViewGroupConsumerWithResponse(ctx context.Context, consumerNameOrId string, reqEditors ...RequestEditorFn) (*ViewGroupConsumerResponse, error)

	// AddConsumerToGroupWithBodyWithResponse request with any body
	AddConsumerToGroupWithBodyWithResponse(ctx context.Context, consumerNameOrId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddConsumerToGroupResponse, error)

	AddConsumerToGroupWithResponse(ctx context.Context, consumerNameOrId string, body AddConsumerToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AddConsumerToGroupResponse, error)

	// DeleteConsumerWithResponse request
	DeleteConsumerWithResponse(ctx context.Context, consumerUsernameOrId string, reqEditors ...RequestEditorFn) (*DeleteConsumerResponse, error)

	// GetConsumerWithResponse request
	GetConsumerWithResponse(ctx context.Context, consumerUsernameOrId string, reqEditors ...RequestEditorFn) (*GetConsumerResponse, error)

	// UpdateConsumerWithBodyWithResponse request with any body
	UpdateConsumerWithBodyWithResponse(ctx context.Context, consumerUsernameOrId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConsumerResponse, error)

	UpdateConsumerWithResponse(ctx context.Context, consumerUsernameOrId string, body UpdateConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConsumerResponse, error)

	// UpsertConsumerWithBodyWithResponse request with any body
	UpsertConsumerWithBodyWithResponse(ctx context.Context, consumerUsernameOrId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertConsumerResponse, error)

	UpsertConsumerWithResponse(ctx context.Context, consumerUsernameOrId string, body UpsertConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertConsumerResponse, error)

	// ListPluginsForConsumerWithResponse request
	ListPluginsForConsumerWithResponse(ctx context.Context, consumerUsernameOrId string, params *ListPluginsForConsumerParams, reqEditors ...RequestEditorFn) (*ListPluginsForConsumerResponse, error)

	// CreatePluginForConsumerWithBodyWithResponse request with any body
	CreatePluginForConsumerWithBodyWithResponse(ctx context.Context, consumerUsernameOrId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePluginForConsumerResponse, error)

	CreatePluginForConsumerWithResponse(ctx context.Context, consumerUsernameOrId string, body CreatePluginForConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePluginForConsumerResponse, error)

	// DeletePluginForConsumerWithResponse request
	DeletePluginForConsumerWithResponse(ctx context.Context, consumerUsernameOrId string, pluginId string, reqEditors ...RequestEditorFn) (*DeletePluginForConsumerResponse, error)

	// FetchPluginForConsumerWithResponse request
	FetchPluginForConsumerWithResponse(ctx context.Context, consumerUsernameOrId string, pluginId string, reqEditors ...RequestEditorFn) (*FetchPluginForConsumerResponse, error)

	// UpdatePluginForConsumerWithBodyWithResponse request with any body
	UpdatePluginForConsumerWithBodyWithResponse(ctx context.Context, consumerUsernameOrId string, pluginId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePluginForConsumerResponse, error)

	UpdatePluginForConsumerWithResponse(ctx context.Context, consumerUsernameOrId string, pluginId string, body UpdatePluginForConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePluginForConsumerResponse, error)

	// UpsertPluginForConsumerWithBodyWithResponse request with any body
	UpsertPluginForConsumerWithBodyWithResponse(ctx context.Context, consumerUsernameOrId string, pluginId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertPluginForConsumerResponse, error)

	UpsertPluginForConsumerWithResponse(ctx context.Context, consumerUsernameOrId string, pluginId string, body UpsertPluginForConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertPluginForConsumerResponse, error)

	// PutDebugClusterControlPlanesNodesLogLevelLogLevelWithResponse request
	PutDebugClusterControlPlanesNodesLogLevelLogLevelWithResponse(ctx context.Context, logLevel PutDebugClusterControlPlanesNodesLogLevelLogLevelParamsLogLevel, reqEditors ...RequestEditorFn) (*PutDebugClusterControlPlanesNodesLogLevelLogLevelResponse, error)

	// PutDebugClusterLogLevelLogLevelWithResponse request
	PutDebugClusterLogLevelLogLevelWithResponse(ctx context.Context, logLevel PutDebugClusterLogLevelLogLevelParamsLogLevel, reqEditors ...RequestEditorFn) (*PutDebugClusterLogLevelLogLevelResponse, error)

	// GetDebugNodeLogLevelWithResponse request
	GetDebugNodeLogLevelWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDebugNodeLogLevelResponse, error)

	// PutDebugNodeLogLevelLogLevelWithResponse request
	PutDebugNodeLogLevelLogLevelWithResponse(ctx context.Context, logLevel PutDebugNodeLogLevelLogLevelParamsLogLevel, reqEditors ...RequestEditorFn) (*PutDebugNodeLogLevelLogLevelResponse, error)

	// GetEndpointsWithResponse request
	GetEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEndpointsResponse, error)

	// GetFilterChainsWithResponse request
	GetFilterChainsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFilterChainsResponse, error)

	// PostFilterChainsWithBodyWithResponse request with any body
	PostFilterChainsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFilterChainsResponse, error)

	PostFilterChainsWithResponse(ctx context.Context, body PostFilterChainsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFilterChainsResponse, error)

	// DeleteFilterChainsFilterChainIdWithResponse request
	DeleteFilterChainsFilterChainIdWithResponse(ctx context.Context, filterChainId string, reqEditors ...RequestEditorFn) (*DeleteFilterChainsFilterChainIdResponse, error)

	// GetFilterChainsFilterChainIdWithResponse request
	GetFilterChainsFilterChainIdWithResponse(ctx context.Context, filterChainId string, reqEditors ...RequestEditorFn) (*GetFilterChainsFilterChainIdResponse, error)

	// PatchFilterChainsFilterChainIdWithBodyWithResponse request with any body
	PatchFilterChainsFilterChainIdWithBodyWithResponse(ctx context.Context, filterChainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchFilterChainsFilterChainIdResponse, error)

	PatchFilterChainsFilterChainIdWithResponse(ctx context.Context, filterChainId string, body PatchFilterChainsFilterChainIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchFilterChainsFilterChainIdResponse, error)

	// PutFilterChainsFilterChainIdWithBodyWithResponse request with any body
	PutFilterChainsFilterChainIdWithBodyWithResponse(ctx context.Context, filterChainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutFilterChainsFilterChainIdResponse, error)

	PutFilterChainsFilterChainIdWithResponse(ctx context.Context, filterChainId string, body PutFilterChainsFilterChainIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutFilterChainsFilterChainIdResponse, error)

	// ListKeySetWithResponse request
	ListKeySetWithResponse(ctx context.Context, params *ListKeySetParams, reqEditors ...RequestEditorFn) (*ListKeySetResponse, error)

	// CreateKeySetWithBodyWithResponse request with any body
	CreateKeySetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeySetResponse, error)

	CreateKeySetWithResponse(ctx context.Context, body CreateKeySetJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeySetResponse, error)

	// DeleteKeySetWithResponse request
	DeleteKeySetWithResponse(ctx context.Context, keySetIdOrName string, reqEditors ...RequestEditorFn) (*DeleteKeySetResponse, error)

	// GetKeySetWithResponse request
	GetKeySetWithResponse(ctx context.Context, keySetIdOrName string, reqEditors ...RequestEditorFn) (*GetKeySetResponse, error)

	// UpdateKeySetWithBodyWithResponse request with any body
	UpdateKeySetWithBodyWithResponse(ctx context.Context, keySetIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateKeySetResponse, error)

	UpdateKeySetWithResponse(ctx context.Context, keySetIdOrName string, body UpdateKeySetJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateKeySetResponse, error)

	// UpsertKeySetWithBodyWithResponse request with any body
	UpsertKeySetWithBodyWithResponse(ctx context.Context, keySetIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertKeySetResponse, error)

	UpsertKeySetWithResponse(ctx context.Context, keySetIdOrName string, body UpsertKeySetJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertKeySetResponse, error)

	// ListKeyWithResponse request
	ListKeyWithResponse(ctx context.Context, params *ListKeyParams, reqEditors ...RequestEditorFn) (*ListKeyResponse, error)

	// CreateKeyWithBodyWithResponse request with any body
	CreateKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeyResponse, error)

	CreateKeyWithResponse(ctx context.Context, body CreateKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeyResponse, error)

	// DeleteKeyWithResponse request
	DeleteKeyWithResponse(ctx context.Context, keyIdOrName string, reqEditors ...RequestEditorFn) (*DeleteKeyResponse, error)

	// GetKeyWithResponse request
	GetKeyWithResponse(ctx context.Context, keyIdOrName string, reqEditors ...RequestEditorFn) (*GetKeyResponse, error)

	// UpdateKeyWithBodyWithResponse request with any body
	UpdateKeyWithBodyWithResponse(ctx context.Context, keyIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateKeyResponse, error)

	UpdateKeyWithResponse(ctx context.Context, keyIdOrName string, body UpdateKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateKeyResponse, error)

	// UpsertKeyWithBodyWithResponse request with any body
	UpsertKeyWithBodyWithResponse(ctx context.Context, keyIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertKeyResponse, error)

	UpsertKeyWithResponse(ctx context.Context, keyIdOrName string, body UpsertKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertKeyResponse, error)

	// ListPluginWithResponse request
	ListPluginWithResponse(ctx context.Context, params *ListPluginParams, reqEditors ...RequestEditorFn) (*ListPluginResponse, error)

	// CreatePluginWithBodyWithResponse request with any body
	CreatePluginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePluginResponse, error)

	CreatePluginWithResponse(ctx context.Context, body CreatePluginJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePluginResponse, error)

	// DeletePluginWithResponse request
	DeletePluginWithResponse(ctx context.Context, pluginId string, reqEditors ...RequestEditorFn) (*DeletePluginResponse, error)

	// GetPluginWithResponse request
	GetPluginWithResponse(ctx context.Context, pluginId string, reqEditors ...RequestEditorFn) (*GetPluginResponse, error)

	// UpdatePluginWithBodyWithResponse request with any body
	UpdatePluginWithBodyWithResponse(ctx context.Context, pluginId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePluginResponse, error)

	UpdatePluginWithResponse(ctx context.Context, pluginId string, body UpdatePluginJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePluginResponse, error)

	// UpsertPluginWithBodyWithResponse request with any body
	UpsertPluginWithBodyWithResponse(ctx context.Context, pluginId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertPluginResponse, error)

	UpsertPluginWithResponse(ctx context.Context, pluginId string, body UpsertPluginJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertPluginResponse, error)

	// ListRouteWithResponse request
	ListRouteWithResponse(ctx context.Context, params *ListRouteParams, reqEditors ...RequestEditorFn) (*ListRouteResponse, error)

	// CreateRouteWithBodyWithResponse request with any body
	CreateRouteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRouteResponse, error)

	CreateRouteWithResponse(ctx context.Context, body CreateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRouteResponse, error)

	// DeleteRouteWithResponse request
	DeleteRouteWithResponse(ctx context.Context, routeIdOrName string, reqEditors ...RequestEditorFn) (*DeleteRouteResponse, error)

	// GetRouteWithResponse request
	GetRouteWithResponse(ctx context.Context, routeIdOrName string, reqEditors ...RequestEditorFn) (*GetRouteResponse, error)

	// UpdateRouteWithBodyWithResponse request with any body
	UpdateRouteWithBodyWithResponse(ctx context.Context, routeIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRouteResponse, error)

	UpdateRouteWithResponse(ctx context.Context, routeIdOrName string, body UpdateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRouteResponse, error)

	// UpsertRouteWithBodyWithResponse request with any body
	UpsertRouteWithBodyWithResponse(ctx context.Context, routeIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertRouteResponse, error)

	UpsertRouteWithResponse(ctx context.Context, routeIdOrName string, body UpsertRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertRouteResponse, error)

	// GetRoutesRouteIdOrNameFilterChainsWithResponse request
	GetRoutesRouteIdOrNameFilterChainsWithResponse(ctx context.Context, routeIdOrName string, reqEditors ...RequestEditorFn) (*GetRoutesRouteIdOrNameFilterChainsResponse, error)

	// PatchRoutesRouteIdOrNameFilterChainsWithBodyWithResponse request with any body
	PatchRoutesRouteIdOrNameFilterChainsWithBodyWithResponse(ctx context.Context, routeIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchRoutesRouteIdOrNameFilterChainsResponse, error)

	PatchRoutesRouteIdOrNameFilterChainsWithResponse(ctx context.Context, routeIdOrName string, body PatchRoutesRouteIdOrNameFilterChainsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchRoutesRouteIdOrNameFilterChainsResponse, error)

	// GetRoutesRouteNameOrIdFilterChainsWithBodyWithResponse request with any body
	GetRoutesRouteNameOrIdFilterChainsWithBodyWithResponse(ctx context.Context, routeIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetRoutesRouteNameOrIdFilterChainsResponse, error)

	GetRoutesRouteNameOrIdFilterChainsWithResponse(ctx context.Context, routeIdOrName string, body GetRoutesRouteNameOrIdFilterChainsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetRoutesRouteNameOrIdFilterChainsResponse, error)

	// GetRoutesRouteIdOrNameFilterChainsFilterChainIdWithResponse request
	GetRoutesRouteIdOrNameFilterChainsFilterChainIdWithResponse(ctx context.Context, routeIdOrName string, filterChainId string, reqEditors ...RequestEditorFn) (*GetRoutesRouteIdOrNameFilterChainsFilterChainIdResponse, error)

	// PutRoutesRouteIdOrNameFilterChainsFilterChainIdWithBodyWithResponse request with any body
	PutRoutesRouteIdOrNameFilterChainsFilterChainIdWithBodyWithResponse(ctx context.Context, routeIdOrName string, filterChainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutRoutesRouteIdOrNameFilterChainsFilterChainIdResponse, error)

	PutRoutesRouteIdOrNameFilterChainsFilterChainIdWithResponse(ctx context.Context, routeIdOrName string, filterChainId string, body PutRoutesRouteIdOrNameFilterChainsFilterChainIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutRoutesRouteIdOrNameFilterChainsFilterChainIdResponse, error)

	// ListPluginsForRouteWithResponse request
	ListPluginsForRouteWithResponse(ctx context.Context, routeIdOrName string, params *ListPluginsForRouteParams, reqEditors ...RequestEditorFn) (*ListPluginsForRouteResponse, error)

	// CreatePluginForRouteWithBodyWithResponse request with any body
	CreatePluginForRouteWithBodyWithResponse(ctx context.Context, routeIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePluginForRouteResponse, error)

	CreatePluginForRouteWithResponse(ctx context.Context, routeIdOrName string, body CreatePluginForRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePluginForRouteResponse, error)

	// DeletePluginForRouteWithResponse request
	DeletePluginForRouteWithResponse(ctx context.Context, routeIdOrName string, pluginId string, reqEditors ...RequestEditorFn) (*DeletePluginForRouteResponse, error)

	// FetchPluginForRouteWithResponse request
	FetchPluginForRouteWithResponse(ctx context.Context, routeIdOrName string, pluginId string, reqEditors ...RequestEditorFn) (*FetchPluginForRouteResponse, error)

	// UpdatePluginForRouteWithBodyWithResponse request with any body
	UpdatePluginForRouteWithBodyWithResponse(ctx context.Context, routeIdOrName string, pluginId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePluginForRouteResponse, error)

	UpdatePluginForRouteWithResponse(ctx context.Context, routeIdOrName string, pluginId string, body UpdatePluginForRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePluginForRouteResponse, error)

	// UpsertPluginForRouteWithBodyWithResponse request with any body
	UpsertPluginForRouteWithBodyWithResponse(ctx context.Context, routeIdOrName string, pluginId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertPluginForRouteResponse, error)

	UpsertPluginForRouteWithResponse(ctx context.Context, routeIdOrName string, pluginId string, body UpsertPluginForRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertPluginForRouteResponse, error)

	// GetRoutesRouteIdOrNameFilterChainIdWithResponse request
	GetRoutesRouteIdOrNameFilterChainIdWithResponse(ctx context.Context, routeIdOrName string, filterChainId string, reqEditors ...RequestEditorFn) (*GetRoutesRouteIdOrNameFilterChainIdResponse, error)

	// GetSchemasFiltersFilterNameWithResponse request
	GetSchemasFiltersFilterNameWithResponse(ctx context.Context, filterName string, reqEditors ...RequestEditorFn) (*GetSchemasFiltersFilterNameResponse, error)

	// PostSchemasPluginsValidateWithResponse request
	PostSchemasPluginsValidateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostSchemasPluginsValidateResponse, error)

	// GetSchemasPluginsPluginNameWithResponse request
	GetSchemasPluginsPluginNameWithResponse(ctx context.Context, pluginName string, reqEditors ...RequestEditorFn) (*GetSchemasPluginsPluginNameResponse, error)

	// GetSchemasVaultsVaultNameWithResponse request
	GetSchemasVaultsVaultNameWithResponse(ctx context.Context, vaultName string, reqEditors ...RequestEditorFn) (*GetSchemasVaultsVaultNameResponse, error)

	// PostSchemasVaultsValidateWithBodyWithResponse request with any body
	PostSchemasVaultsValidateWithBodyWithResponse(ctx context.Context, vaultName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSchemasVaultsValidateResponse, error)

	PostSchemasVaultsValidateWithResponse(ctx context.Context, vaultName string, body PostSchemasVaultsValidateJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSchemasVaultsValidateResponse, error)

	// GetSchemasEntityWithResponse request
	GetSchemasEntityWithResponse(ctx context.Context, entity string, reqEditors ...RequestEditorFn) (*GetSchemasEntityResponse, error)

	// PostSchemasEntityValidateWithResponse request
	PostSchemasEntityValidateWithResponse(ctx context.Context, entity string, reqEditors ...RequestEditorFn) (*PostSchemasEntityValidateResponse, error)

	// ListServiceWithResponse request
	ListServiceWithResponse(ctx context.Context, params *ListServiceParams, reqEditors ...RequestEditorFn) (*ListServiceResponse, error)

	// CreateServiceWithBodyWithResponse request with any body
	CreateServiceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceResponse, error)

	CreateServiceWithResponse(ctx context.Context, body CreateServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceResponse, error)

	// DeleteServiceWithResponse request
	DeleteServiceWithResponse(ctx context.Context, serviceIdOrName string, reqEditors ...RequestEditorFn) (*DeleteServiceResponse, error)

	// GetServiceWithResponse request
	GetServiceWithResponse(ctx context.Context, serviceIdOrName string, reqEditors ...RequestEditorFn) (*GetServiceResponse, error)

	// UpdateServiceWithBodyWithResponse request with any body
	UpdateServiceWithBodyWithResponse(ctx context.Context, serviceIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceResponse, error)

	UpdateServiceWithResponse(ctx context.Context, serviceIdOrName string, body UpdateServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceResponse, error)

	// UpsertServiceWithBodyWithResponse request with any body
	UpsertServiceWithBodyWithResponse(ctx context.Context, serviceIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertServiceResponse, error)

	UpsertServiceWithResponse(ctx context.Context, serviceIdOrName string, body UpsertServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertServiceResponse, error)

	// GetServiceIdOrNameFilterChainsWithResponse request
	GetServiceIdOrNameFilterChainsWithResponse(ctx context.Context, serviceIdOrName string, reqEditors ...RequestEditorFn) (*GetServiceIdOrNameFilterChainsResponse, error)

	// GetServicesServiceIdOrNameFilterChainsWithBodyWithResponse request with any body
	GetServicesServiceIdOrNameFilterChainsWithBodyWithResponse(ctx context.Context, serviceIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetServicesServiceIdOrNameFilterChainsResponse, error)

	GetServicesServiceIdOrNameFilterChainsWithResponse(ctx context.Context, serviceIdOrName string, body GetServicesServiceIdOrNameFilterChainsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetServicesServiceIdOrNameFilterChainsResponse, error)

	// DeleteServicesServiceIdOrNameFilterChainsFilterChainIdWithResponse request
	DeleteServicesServiceIdOrNameFilterChainsFilterChainIdWithResponse(ctx context.Context, serviceIdOrName string, filterChainId string, reqEditors ...RequestEditorFn) (*DeleteServicesServiceIdOrNameFilterChainsFilterChainIdResponse, error)

	// DeletePluginForAServiceWithResponse request
	DeletePluginForAServiceWithResponse(ctx context.Context, serviceIdOrName string, pluginId string, reqEditors ...RequestEditorFn) (*DeletePluginForAServiceResponse, error)

	// FetchPluginWithAServiceWithResponse request
	FetchPluginWithAServiceWithResponse(ctx context.Context, serviceIdOrName string, pluginId string, reqEditors ...RequestEditorFn) (*FetchPluginWithAServiceResponse, error)

	// UpdatePluginForAServiceWithBodyWithResponse request with any body
	UpdatePluginForAServiceWithBodyWithResponse(ctx context.Context, serviceIdOrName string, pluginId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePluginForAServiceResponse, error)

	UpdatePluginForAServiceWithResponse(ctx context.Context, serviceIdOrName string, pluginId string, body UpdatePluginForAServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePluginForAServiceResponse, error)

	// UpsertPluginForAServiceWithBodyWithResponse request with any body
	UpsertPluginForAServiceWithBodyWithResponse(ctx context.Context, serviceIdOrName string, pluginId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertPluginForAServiceResponse, error)

	UpsertPluginForAServiceWithResponse(ctx context.Context, serviceIdOrName string, pluginId string, body UpsertPluginForAServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertPluginForAServiceResponse, error)

	// ListRoutesForServiceWithResponse request
	ListRoutesForServiceWithResponse(ctx context.Context, serviceIdOrName string, params *ListRoutesForServiceParams, reqEditors ...RequestEditorFn) (*ListRoutesForServiceResponse, error)

	// CreateRouteForServiceWithBodyWithResponse request with any body
	CreateRouteForServiceWithBodyWithResponse(ctx context.Context, serviceIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRouteForServiceResponse, error)

	CreateRouteForServiceWithResponse(ctx context.Context, serviceIdOrName string, body CreateRouteForServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRouteForServiceResponse, error)

	// DeleteRouteForServiceWithResponse request
	DeleteRouteForServiceWithResponse(ctx context.Context, serviceIdOrName string, routeIdOrName string, reqEditors ...RequestEditorFn) (*DeleteRouteForServiceResponse, error)

	// FetchRouteForServiceWithResponse request
	FetchRouteForServiceWithResponse(ctx context.Context, serviceIdOrName string, routeIdOrName string, reqEditors ...RequestEditorFn) (*FetchRouteForServiceResponse, error)

	// UpdateRouteForServiceWithBodyWithResponse request with any body
	UpdateRouteForServiceWithBodyWithResponse(ctx context.Context, serviceIdOrName string, routeIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRouteForServiceResponse, error)

	UpdateRouteForServiceWithResponse(ctx context.Context, serviceIdOrName string, routeIdOrName string, body UpdateRouteForServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRouteForServiceResponse, error)

	// UpsertRouteForServiceWithBodyWithResponse request with any body
	UpsertRouteForServiceWithBodyWithResponse(ctx context.Context, serviceIdOrName string, routeIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertRouteForServiceResponse, error)

	UpsertRouteForServiceWithResponse(ctx context.Context, serviceIdOrName string, routeIdOrName string, body UpsertRouteForServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertRouteForServiceResponse, error)

	// GetPluginsForServiceWithResponse request
	GetPluginsForServiceWithResponse(ctx context.Context, serviceIdOrName string, params *GetPluginsForServiceParams, reqEditors ...RequestEditorFn) (*GetPluginsForServiceResponse, error)

	// CreatePluginForServiceWithBodyWithResponse request with any body
	CreatePluginForServiceWithBodyWithResponse(ctx context.Context, serviceIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePluginForServiceResponse, error)

	CreatePluginForServiceWithResponse(ctx context.Context, serviceIdOrName string, body CreatePluginForServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePluginForServiceResponse, error)

	// ListSniWithResponse request
	ListSniWithResponse(ctx context.Context, params *ListSniParams, reqEditors ...RequestEditorFn) (*ListSniResponse, error)

	// CreateSniWithBodyWithResponse request with any body
	CreateSniWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSniResponse, error)

	CreateSniWithResponse(ctx context.Context, body CreateSniJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSniResponse, error)

	// DeleteSniWithResponse request
	DeleteSniWithResponse(ctx context.Context, sniNameOrId string, reqEditors ...RequestEditorFn) (*DeleteSniResponse, error)

	// GetSniWithResponse request
	GetSniWithResponse(ctx context.Context, sniNameOrId string, reqEditors ...RequestEditorFn) (*GetSniResponse, error)

	// UpdateSniWithBodyWithResponse request with any body
	UpdateSniWithBodyWithResponse(ctx context.Context, sniNameOrId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSniResponse, error)

	UpdateSniWithResponse(ctx context.Context, sniNameOrId string, body UpdateSniJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSniResponse, error)

	// UpsertSniWithBodyWithResponse request with any body
	UpsertSniWithBodyWithResponse(ctx context.Context, sniNameOrId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertSniResponse, error)

	UpsertSniWithResponse(ctx context.Context, sniNameOrId string, body UpsertSniJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertSniResponse, error)

	// GetStatusWithResponse request
	GetStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStatusResponse, error)

	// GetDnsStatusWithResponse request
	GetDnsStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDnsStatusResponse, error)

	// GetTagsWithResponse request
	GetTagsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTagsResponse, error)

	// GetTagsTagsWithResponse request
	GetTagsTagsWithResponse(ctx context.Context, tags string, reqEditors ...RequestEditorFn) (*GetTagsTagsResponse, error)

	// GetTimersWithResponse request
	GetTimersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTimersResponse, error)

	// ListUpstreamWithResponse request
	ListUpstreamWithResponse(ctx context.Context, params *ListUpstreamParams, reqEditors ...RequestEditorFn) (*ListUpstreamResponse, error)

	// CreateUpstreamWithBodyWithResponse request with any body
	CreateUpstreamWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUpstreamResponse, error)

	CreateUpstreamWithResponse(ctx context.Context, body CreateUpstreamJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUpstreamResponse, error)

	// DeleteUpstreamWithResponse request
	DeleteUpstreamWithResponse(ctx context.Context, upstreamIdOrName string, reqEditors ...RequestEditorFn) (*DeleteUpstreamResponse, error)

	// GetUpstreamWithResponse request
	GetUpstreamWithResponse(ctx context.Context, upstreamIdOrName string, reqEditors ...RequestEditorFn) (*GetUpstreamResponse, error)

	// UpdateUpstreamWithBodyWithResponse request with any body
	UpdateUpstreamWithBodyWithResponse(ctx context.Context, upstreamIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUpstreamResponse, error)

	UpdateUpstreamWithResponse(ctx context.Context, upstreamIdOrName string, body UpdateUpstreamJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUpstreamResponse, error)

	// UpsertUpstreamWithBodyWithResponse request with any body
	UpsertUpstreamWithBodyWithResponse(ctx context.Context, upstreamIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertUpstreamResponse, error)

	UpsertUpstreamWithResponse(ctx context.Context, upstreamIdOrName string, body UpsertUpstreamJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertUpstreamResponse, error)

	// ListTargetsForUpstreamWithResponse request
	ListTargetsForUpstreamWithResponse(ctx context.Context, upstreamIdOrName string, params *ListTargetsForUpstreamParams, reqEditors ...RequestEditorFn) (*ListTargetsForUpstreamResponse, error)

	// CreateTargetForUpstreamWithBodyWithResponse request with any body
	CreateTargetForUpstreamWithBodyWithResponse(ctx context.Context, upstreamIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTargetForUpstreamResponse, error)

	CreateTargetForUpstreamWithResponse(ctx context.Context, upstreamIdOrName string, body CreateTargetForUpstreamJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTargetForUpstreamResponse, error)

	// DeleteUpstreamTargetWithResponse request
	DeleteUpstreamTargetWithResponse(ctx context.Context, upstreamIdOrName string, targetIdOrTarget string, reqEditors ...RequestEditorFn) (*DeleteUpstreamTargetResponse, error)

	// FetchTargetForUpstreamWithResponse request
	FetchTargetForUpstreamWithResponse(ctx context.Context, upstreamIdOrName string, targetIdOrTarget string, reqEditors ...RequestEditorFn) (*FetchTargetForUpstreamResponse, error)

	// UpdateTargetForUpstreamWithBodyWithResponse request with any body
	UpdateTargetForUpstreamWithBodyWithResponse(ctx context.Context, upstreamIdOrName string, targetIdOrTarget string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTargetForUpstreamResponse, error)

	UpdateTargetForUpstreamWithResponse(ctx context.Context, upstreamIdOrName string, targetIdOrTarget string, body UpdateTargetForUpstreamJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTargetForUpstreamResponse, error)

	// UpsertTargetForUpstreamWithBodyWithResponse request with any body
	UpsertTargetForUpstreamWithBodyWithResponse(ctx context.Context, upstreamIdOrName string, targetIdOrTarget string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertTargetForUpstreamResponse, error)

	UpsertTargetForUpstreamWithResponse(ctx context.Context, upstreamIdOrName string, targetIdOrTarget string, body UpsertTargetForUpstreamJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertTargetForUpstreamResponse, error)

	// ListVaultWithResponse request
	ListVaultWithResponse(ctx context.Context, params *ListVaultParams, reqEditors ...RequestEditorFn) (*ListVaultResponse, error)

	// CreateVaultWithBodyWithResponse request with any body
	CreateVaultWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVaultResponse, error)

	CreateVaultWithResponse(ctx context.Context, body CreateVaultJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVaultResponse, error)

	// DeleteVaultWithResponse request
	DeleteVaultWithResponse(ctx context.Context, vaultIdOrPrefix string, reqEditors ...RequestEditorFn) (*DeleteVaultResponse, error)

	// GetVaultWithResponse request
	GetVaultWithResponse(ctx context.Context, vaultIdOrPrefix string, reqEditors ...RequestEditorFn) (*GetVaultResponse, error)

	// UpdateVaultWithBodyWithResponse request with any body
	UpdateVaultWithBodyWithResponse(ctx context.Context, vaultIdOrPrefix string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVaultResponse, error)

	UpdateVaultWithResponse(ctx context.Context, vaultIdOrPrefix string, body UpdateVaultJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVaultResponse, error)

	// UpsertVaultWithBodyWithResponse request with any body
	UpsertVaultWithBodyWithResponse(ctx context.Context, vaultIdOrPrefix string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertVaultResponse, error)

	UpsertVaultWithResponse(ctx context.Context, vaultIdOrPrefix string, body UpsertVaultJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertVaultResponse, error)

	// HeadEndpointsWithResponse request
	HeadEndpointsWithResponse(ctx context.Context, endpoint string, reqEditors ...RequestEditorFn) (*HeadEndpointsResponse, error)

	// OptionsEndpointWithResponse request
	OptionsEndpointWithResponse(ctx context.Context, endpoint string, reqEditors ...RequestEditorFn) (*OptionsEndpointResponse, error)
}

type GeInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GeInfo200Response
	JSON401      *UnauthorizedError
	JSON405      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r GeInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GeInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCaCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CACertificate
}

// Status returns HTTPResponse.Status
func (r ListCaCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCaCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCaCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CACertificate
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r CreateCaCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCaCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCaCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r DeleteCaCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCaCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCaCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CACertificate
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r GetCaCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCaCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCaCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CACertificate
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r UpdateCaCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCaCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatetCaCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CACertificate
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r UpdatetCaCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatetCaCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PurgeAllCacheResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PurgeAllCacheResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PurgeAllCacheResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCacheByKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteCacheByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCacheByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCacheByKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCacheByKey200Response
	JSON404      *GetCacheByKey404Response
}

// Status returns HTTPResponse.Status
func (r GetCacheByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCacheByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListCertificate200Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r ListCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Certificate
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r CreateCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r DeleteCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Certificate
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r GetCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Certificate
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r UpdateCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCertificatePutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Certificate
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r UpdateCertificatePutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCertificatePutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSniForCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r DeleteSniForCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSniForCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FetchSniWithCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SNI
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r FetchSniWithCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSniWithCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSniForCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SNI
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r UpdateSniForCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSniForCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpsertSniForCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SNI
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r UpsertSniForCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpsertSniForCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSniWithCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetSniWithCertificate200Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r GetSniWithCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSniWithCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSniForCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SNI
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r CreateSniForCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSniForCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDataPlanesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetDataPlanes200Response
	JSON400      *GetDataPlanes400Response
}

// Status returns HTTPResponse.Status
func (r GetDataPlanesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataPlanesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDataPlaneStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]GetDataPlaneStatus200ResponseValue
	JSON400      *GetDataPlanes400Response
}

// Status returns HTTPResponse.Status
func (r GetDataPlaneStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataPlaneStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListConsumer200Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r ListConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Consumer
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r CreateConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupOfConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteGroupOfConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupOfConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ViewGroupConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConsumerGroupResponse
}

// Status returns HTTPResponse.Status
func (r ViewGroupConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ViewGroupConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddConsumerToGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Consumer
	JSON201      *Consumer
}

// Status returns HTTPResponse.Status
func (r AddConsumerToGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddConsumerToGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r DeleteConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Consumer
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r GetConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Consumer
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r UpdateConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpsertConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpsertConsumer200Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r UpsertConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpsertConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPluginsForConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPluginsForConsumer200Response
}

// Status returns HTTPResponse.Status
func (r ListPluginsForConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPluginsForConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePluginForConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Plugin
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r CreatePluginForConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePluginForConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePluginForConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r DeletePluginForConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePluginForConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FetchPluginForConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Plugin
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r FetchPluginForConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchPluginForConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePluginForConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPluginsForConsumer200Response
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r UpdatePluginForConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePluginForConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpsertPluginForConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPluginsForConsumer200Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r UpsertPluginForConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpsertPluginForConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutDebugClusterControlPlanesNodesLogLevelLogLevelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PutDebugClusterControlPlanesNodesLogLevelLogLevel200Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r PutDebugClusterControlPlanesNodesLogLevelLogLevelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutDebugClusterControlPlanesNodesLogLevelLogLevelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutDebugClusterLogLevelLogLevelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PutDebugClusterLogLevelLogLevel200Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r PutDebugClusterLogLevelLogLevelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutDebugClusterLogLevelLogLevelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDebugNodeLogLevelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetDebugNodeLogLevel200Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r GetDebugNodeLogLevelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDebugNodeLogLevelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutDebugNodeLogLevelLogLevelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PutDebugNodeLogLevelLogLevel200Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r PutDebugNodeLogLevelLogLevelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutDebugNodeLogLevelLogLevelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetEndpoints200Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r GetEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFilterChainsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FilterChains
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r GetFilterChainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFilterChainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostFilterChainsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *FilterChains
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r PostFilterChainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFilterChainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFilterChainsFilterChainIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r DeleteFilterChainsFilterChainIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFilterChainsFilterChainIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFilterChainsFilterChainIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FilterChains
}

// Status returns HTTPResponse.Status
func (r GetFilterChainsFilterChainIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFilterChainsFilterChainIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchFilterChainsFilterChainIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *FilterChains
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r PatchFilterChainsFilterChainIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchFilterChainsFilterChainIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutFilterChainsFilterChainIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r PutFilterChainsFilterChainIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutFilterChainsFilterChainIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListKeySetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListKeySet200Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r ListKeySetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListKeySetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateKeySetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListKeySet200Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r CreateKeySetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateKeySetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteKeySetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r DeleteKeySetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteKeySetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeySetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListKeySet200Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r GetKeySetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeySetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateKeySetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListKeySet200Response
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r UpdateKeySetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateKeySetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpsertKeySetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListKeySet200Response
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r UpsertKeySetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpsertKeySetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListKey200Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r ListKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Key
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r CreateKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r DeleteKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Key
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r GetKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Key
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r UpdateKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpsertKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Key
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r UpsertKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpsertKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPluginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPluginsForConsumer200Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r ListPluginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPluginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePluginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Plugin
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r CreatePluginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePluginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePluginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r DeletePluginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePluginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPluginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Plugin
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r GetPluginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPluginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePluginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Plugin
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r UpdatePluginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePluginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpsertPluginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Plugin
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r UpsertPluginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpsertPluginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRouteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListRoute200Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r ListRouteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRouteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRouteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Route
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r CreateRouteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRouteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRouteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r DeleteRouteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRouteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRouteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Route
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r GetRouteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRouteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRouteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Route
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r UpdateRouteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRouteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpsertRouteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Route
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r UpsertRouteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpsertRouteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoutesRouteIdOrNameFilterChainsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FilterChains
}

// Status returns HTTPResponse.Status
func (r GetRoutesRouteIdOrNameFilterChainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoutesRouteIdOrNameFilterChainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchRoutesRouteIdOrNameFilterChainsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *FilterChains
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r PatchRoutesRouteIdOrNameFilterChainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchRoutesRouteIdOrNameFilterChainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoutesRouteNameOrIdFilterChainsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *FilterChains
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r GetRoutesRouteNameOrIdFilterChainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoutesRouteNameOrIdFilterChainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoutesRouteIdOrNameFilterChainsFilterChainIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FilterChains
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r GetRoutesRouteIdOrNameFilterChainsFilterChainIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoutesRouteIdOrNameFilterChainsFilterChainIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutRoutesRouteIdOrNameFilterChainsFilterChainIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r PutRoutesRouteIdOrNameFilterChainsFilterChainIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutRoutesRouteIdOrNameFilterChainsFilterChainIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPluginsForRouteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPluginsForRoute200Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r ListPluginsForRouteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPluginsForRouteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePluginForRouteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Plugin
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r CreatePluginForRouteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePluginForRouteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePluginForRouteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r DeletePluginForRouteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePluginForRouteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FetchPluginForRouteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Plugin
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r FetchPluginForRouteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchPluginForRouteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePluginForRouteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Plugin
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r UpdatePluginForRouteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePluginForRouteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpsertPluginForRouteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Plugin
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r UpsertPluginForRouteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpsertPluginForRouteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoutesRouteIdOrNameFilterChainIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r GetRoutesRouteIdOrNameFilterChainIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoutesRouteIdOrNameFilterChainIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchemasFiltersFilterNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r GetSchemasFiltersFilterNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchemasFiltersFilterNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSchemasPluginsValidateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostSchemasPluginsValidate200Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r PostSchemasPluginsValidateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSchemasPluginsValidateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchemasPluginsPluginNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r GetSchemasPluginsPluginNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchemasPluginsPluginNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchemasVaultsVaultNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Vault
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r GetSchemasVaultsVaultNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchemasVaultsVaultNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSchemasVaultsValidateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostSchemasVaultsValidate200Response
}

// Status returns HTTPResponse.Status
func (r PostSchemasVaultsValidateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSchemasVaultsValidateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchemasEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetSchemasEntity200Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r GetSchemasEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchemasEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSchemasEntityValidateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostSchemasEntityValidate200Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r PostSchemasEntityValidateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSchemasEntityValidateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Service
	XML200       *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r ListServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Service
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r CreateServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r DeleteServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Service
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r GetServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Service
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r UpdateServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpsertServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Service
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r UpsertServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpsertServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceIdOrNameFilterChainsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FilterChains
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r GetServiceIdOrNameFilterChainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceIdOrNameFilterChainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServicesServiceIdOrNameFilterChainsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *FilterChains
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r GetServicesServiceIdOrNameFilterChainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServicesServiceIdOrNameFilterChainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServicesServiceIdOrNameFilterChainsFilterChainIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r DeleteServicesServiceIdOrNameFilterChainsFilterChainIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServicesServiceIdOrNameFilterChainsFilterChainIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePluginForAServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r DeletePluginForAServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePluginForAServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FetchPluginWithAServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Plugin
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r FetchPluginWithAServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchPluginWithAServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePluginForAServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Plugin
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r UpdatePluginForAServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePluginForAServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpsertPluginForAServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Plugin
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r UpsertPluginForAServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpsertPluginForAServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRoutesForServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListRoute200Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r ListRoutesForServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRoutesForServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRouteForServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Route
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r CreateRouteForServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRouteForServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRouteForServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r DeleteRouteForServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRouteForServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FetchRouteForServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Route
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r FetchRouteForServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchRouteForServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRouteForServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Route
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r UpdateRouteForServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRouteForServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpsertRouteForServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Route
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r UpsertRouteForServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpsertRouteForServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPluginsForServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPluginsForRoute200Response
}

// Status returns HTTPResponse.Status
func (r GetPluginsForServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPluginsForServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePluginForServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Plugin
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r CreatePluginForServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePluginForServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSniResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetSniWithCertificate200Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r ListSniResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSniResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSniResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetSniWithCertificate200Response
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r CreateSniResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSniResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSniResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r DeleteSniResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSniResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSniResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetSniWithCertificate200Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r GetSniResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSniResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSniResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetSniWithCertificate200Response
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r UpdateSniResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSniResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpsertSniResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetSniWithCertificate200Response
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r UpsertSniResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpsertSniResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetStatus200Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r GetStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDnsStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetDnsStatus200Response
	JSON401      *UnauthorizedError
	JSON501      *GetDnsStatus501Response
}

// Status returns HTTPResponse.Status
func (r GetDnsStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDnsStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetTags200Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r GetTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTagsTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetTags200Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r GetTagsTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTagsTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTimersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetTimers200Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r GetTimersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTimersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUpstreamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListUpstream200Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r ListUpstreamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUpstreamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUpstreamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Upstream
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r CreateUpstreamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUpstreamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUpstreamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r DeleteUpstreamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUpstreamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUpstreamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Upstream
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r GetUpstreamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUpstreamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUpstreamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Upstream
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r UpdateUpstreamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUpstreamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpsertUpstreamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Upstream
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r UpsertUpstreamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpsertUpstreamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTargetsForUpstreamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListTargetsForUpstream200Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r ListTargetsForUpstreamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTargetsForUpstreamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTargetForUpstreamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Target
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r CreateTargetForUpstreamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTargetForUpstreamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUpstreamTargetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r DeleteUpstreamTargetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUpstreamTargetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FetchTargetForUpstreamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Target
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r FetchTargetForUpstreamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchTargetForUpstreamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTargetForUpstreamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Target
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r UpdateTargetForUpstreamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTargetForUpstreamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpsertTargetForUpstreamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Target
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r UpsertTargetForUpstreamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpsertTargetForUpstreamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListVault200Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r ListVaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Vault
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r CreateVaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r DeleteVaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Vault
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r GetVaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Vault
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r UpdateVaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpsertVaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Vault
	JSON400      *map[string]interface{}
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r UpsertVaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpsertVaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HeadEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r HeadEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HeadEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OptionsEndpointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r OptionsEndpointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OptionsEndpointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GeInfoWithResponse request returning *GeInfoResponse
func (c *ClientWithResponses) GeInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GeInfoResponse, error) {
	rsp, err := c.GeInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGeInfoResponse(rsp)
}

// ListCaCertificateWithResponse request returning *ListCaCertificateResponse
func (c *ClientWithResponses) ListCaCertificateWithResponse(ctx context.Context, params *ListCaCertificateParams, reqEditors ...RequestEditorFn) (*ListCaCertificateResponse, error) {
	rsp, err := c.ListCaCertificate(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCaCertificateResponse(rsp)
}

// CreateCaCertificateWithBodyWithResponse request with arbitrary body returning *CreateCaCertificateResponse
func (c *ClientWithResponses) CreateCaCertificateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCaCertificateResponse, error) {
	rsp, err := c.CreateCaCertificateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCaCertificateResponse(rsp)
}

func (c *ClientWithResponses) CreateCaCertificateWithResponse(ctx context.Context, body CreateCaCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCaCertificateResponse, error) {
	rsp, err := c.CreateCaCertificate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCaCertificateResponse(rsp)
}

// DeleteCaCertificateWithResponse request returning *DeleteCaCertificateResponse
func (c *ClientWithResponses) DeleteCaCertificateWithResponse(ctx context.Context, caCertificateId string, reqEditors ...RequestEditorFn) (*DeleteCaCertificateResponse, error) {
	rsp, err := c.DeleteCaCertificate(ctx, caCertificateId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCaCertificateResponse(rsp)
}

// GetCaCertificateWithResponse request returning *GetCaCertificateResponse
func (c *ClientWithResponses) GetCaCertificateWithResponse(ctx context.Context, caCertificateId string, reqEditors ...RequestEditorFn) (*GetCaCertificateResponse, error) {
	rsp, err := c.GetCaCertificate(ctx, caCertificateId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCaCertificateResponse(rsp)
}

// UpdateCaCertificateWithBodyWithResponse request with arbitrary body returning *UpdateCaCertificateResponse
func (c *ClientWithResponses) UpdateCaCertificateWithBodyWithResponse(ctx context.Context, caCertificateId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCaCertificateResponse, error) {
	rsp, err := c.UpdateCaCertificateWithBody(ctx, caCertificateId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCaCertificateResponse(rsp)
}

func (c *ClientWithResponses) UpdateCaCertificateWithResponse(ctx context.Context, caCertificateId string, body UpdateCaCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCaCertificateResponse, error) {
	rsp, err := c.UpdateCaCertificate(ctx, caCertificateId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCaCertificateResponse(rsp)
}

// UpdatetCaCertificateWithBodyWithResponse request with arbitrary body returning *UpdatetCaCertificateResponse
func (c *ClientWithResponses) UpdatetCaCertificateWithBodyWithResponse(ctx context.Context, caCertificateId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatetCaCertificateResponse, error) {
	rsp, err := c.UpdatetCaCertificateWithBody(ctx, caCertificateId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatetCaCertificateResponse(rsp)
}

func (c *ClientWithResponses) UpdatetCaCertificateWithResponse(ctx context.Context, caCertificateId string, body UpdatetCaCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatetCaCertificateResponse, error) {
	rsp, err := c.UpdatetCaCertificate(ctx, caCertificateId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatetCaCertificateResponse(rsp)
}

// PurgeAllCacheWithResponse request returning *PurgeAllCacheResponse
func (c *ClientWithResponses) PurgeAllCacheWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PurgeAllCacheResponse, error) {
	rsp, err := c.PurgeAllCache(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePurgeAllCacheResponse(rsp)
}

// DeleteCacheByKeyWithResponse request returning *DeleteCacheByKeyResponse
func (c *ClientWithResponses) DeleteCacheByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*DeleteCacheByKeyResponse, error) {
	rsp, err := c.DeleteCacheByKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCacheByKeyResponse(rsp)
}

// GetCacheByKeyWithResponse request returning *GetCacheByKeyResponse
func (c *ClientWithResponses) GetCacheByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetCacheByKeyResponse, error) {
	rsp, err := c.GetCacheByKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCacheByKeyResponse(rsp)
}

// ListCertificateWithResponse request returning *ListCertificateResponse
func (c *ClientWithResponses) ListCertificateWithResponse(ctx context.Context, params *ListCertificateParams, reqEditors ...RequestEditorFn) (*ListCertificateResponse, error) {
	rsp, err := c.ListCertificate(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCertificateResponse(rsp)
}

// CreateCertificateWithBodyWithResponse request with arbitrary body returning *CreateCertificateResponse
func (c *ClientWithResponses) CreateCertificateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCertificateResponse, error) {
	rsp, err := c.CreateCertificateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCertificateResponse(rsp)
}

func (c *ClientWithResponses) CreateCertificateWithResponse(ctx context.Context, body CreateCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCertificateResponse, error) {
	rsp, err := c.CreateCertificate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCertificateResponse(rsp)
}

// DeleteCertificateWithResponse request returning *DeleteCertificateResponse
func (c *ClientWithResponses) DeleteCertificateWithResponse(ctx context.Context, certificateId string, reqEditors ...RequestEditorFn) (*DeleteCertificateResponse, error) {
	rsp, err := c.DeleteCertificate(ctx, certificateId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCertificateResponse(rsp)
}

// GetCertificateWithResponse request returning *GetCertificateResponse
func (c *ClientWithResponses) GetCertificateWithResponse(ctx context.Context, certificateId string, reqEditors ...RequestEditorFn) (*GetCertificateResponse, error) {
	rsp, err := c.GetCertificate(ctx, certificateId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCertificateResponse(rsp)
}

// UpdateCertificateWithBodyWithResponse request with arbitrary body returning *UpdateCertificateResponse
func (c *ClientWithResponses) UpdateCertificateWithBodyWithResponse(ctx context.Context, certificateId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCertificateResponse, error) {
	rsp, err := c.UpdateCertificateWithBody(ctx, certificateId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCertificateResponse(rsp)
}

func (c *ClientWithResponses) UpdateCertificateWithResponse(ctx context.Context, certificateId string, body UpdateCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCertificateResponse, error) {
	rsp, err := c.UpdateCertificate(ctx, certificateId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCertificateResponse(rsp)
}

// UpdateCertificatePutWithBodyWithResponse request with arbitrary body returning *UpdateCertificatePutResponse
func (c *ClientWithResponses) UpdateCertificatePutWithBodyWithResponse(ctx context.Context, certificateId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCertificatePutResponse, error) {
	rsp, err := c.UpdateCertificatePutWithBody(ctx, certificateId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCertificatePutResponse(rsp)
}

func (c *ClientWithResponses) UpdateCertificatePutWithResponse(ctx context.Context, certificateId string, body UpdateCertificatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCertificatePutResponse, error) {
	rsp, err := c.UpdateCertificatePut(ctx, certificateId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCertificatePutResponse(rsp)
}

// DeleteSniForCertificateWithResponse request returning *DeleteSniForCertificateResponse
func (c *ClientWithResponses) DeleteSniForCertificateWithResponse(ctx context.Context, certificateId string, sniNameOrId string, reqEditors ...RequestEditorFn) (*DeleteSniForCertificateResponse, error) {
	rsp, err := c.DeleteSniForCertificate(ctx, certificateId, sniNameOrId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSniForCertificateResponse(rsp)
}

// FetchSniWithCertificateWithResponse request returning *FetchSniWithCertificateResponse
func (c *ClientWithResponses) FetchSniWithCertificateWithResponse(ctx context.Context, certificateId string, sniNameOrId string, reqEditors ...RequestEditorFn) (*FetchSniWithCertificateResponse, error) {
	rsp, err := c.FetchSniWithCertificate(ctx, certificateId, sniNameOrId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFetchSniWithCertificateResponse(rsp)
}

// UpdateSniForCertificateWithBodyWithResponse request with arbitrary body returning *UpdateSniForCertificateResponse
func (c *ClientWithResponses) UpdateSniForCertificateWithBodyWithResponse(ctx context.Context, certificateId string, sniNameOrId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSniForCertificateResponse, error) {
	rsp, err := c.UpdateSniForCertificateWithBody(ctx, certificateId, sniNameOrId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSniForCertificateResponse(rsp)
}

func (c *ClientWithResponses) UpdateSniForCertificateWithResponse(ctx context.Context, certificateId string, sniNameOrId string, body UpdateSniForCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSniForCertificateResponse, error) {
	rsp, err := c.UpdateSniForCertificate(ctx, certificateId, sniNameOrId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSniForCertificateResponse(rsp)
}

// UpsertSniForCertificateWithBodyWithResponse request with arbitrary body returning *UpsertSniForCertificateResponse
func (c *ClientWithResponses) UpsertSniForCertificateWithBodyWithResponse(ctx context.Context, certificateId string, sniNameOrId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertSniForCertificateResponse, error) {
	rsp, err := c.UpsertSniForCertificateWithBody(ctx, certificateId, sniNameOrId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertSniForCertificateResponse(rsp)
}

func (c *ClientWithResponses) UpsertSniForCertificateWithResponse(ctx context.Context, certificateId string, sniNameOrId string, body UpsertSniForCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertSniForCertificateResponse, error) {
	rsp, err := c.UpsertSniForCertificate(ctx, certificateId, sniNameOrId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertSniForCertificateResponse(rsp)
}

// GetSniWithCertificateWithResponse request returning *GetSniWithCertificateResponse
func (c *ClientWithResponses) GetSniWithCertificateWithResponse(ctx context.Context, certificateNameOrId GetSniWithCertificateParamsCertificateNameOrId, params *GetSniWithCertificateParams, reqEditors ...RequestEditorFn) (*GetSniWithCertificateResponse, error) {
	rsp, err := c.GetSniWithCertificate(ctx, certificateNameOrId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSniWithCertificateResponse(rsp)
}

// CreateSniForCertificateWithBodyWithResponse request with arbitrary body returning *CreateSniForCertificateResponse
func (c *ClientWithResponses) CreateSniForCertificateWithBodyWithResponse(ctx context.Context, certificateNameOrId CreateSniForCertificateParamsCertificateNameOrId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSniForCertificateResponse, error) {
	rsp, err := c.CreateSniForCertificateWithBody(ctx, certificateNameOrId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSniForCertificateResponse(rsp)
}

func (c *ClientWithResponses) CreateSniForCertificateWithResponse(ctx context.Context, certificateNameOrId CreateSniForCertificateParamsCertificateNameOrId, body CreateSniForCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSniForCertificateResponse, error) {
	rsp, err := c.CreateSniForCertificate(ctx, certificateNameOrId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSniForCertificateResponse(rsp)
}

// GetDataPlanesWithResponse request returning *GetDataPlanesResponse
func (c *ClientWithResponses) GetDataPlanesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDataPlanesResponse, error) {
	rsp, err := c.GetDataPlanes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataPlanesResponse(rsp)
}

// GetDataPlaneStatusWithResponse request returning *GetDataPlaneStatusResponse
func (c *ClientWithResponses) GetDataPlaneStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDataPlaneStatusResponse, error) {
	rsp, err := c.GetDataPlaneStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataPlaneStatusResponse(rsp)
}

// ListConsumerWithResponse request returning *ListConsumerResponse
func (c *ClientWithResponses) ListConsumerWithResponse(ctx context.Context, params *ListConsumerParams, reqEditors ...RequestEditorFn) (*ListConsumerResponse, error) {
	rsp, err := c.ListConsumer(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListConsumerResponse(rsp)
}

// CreateConsumerWithBodyWithResponse request with arbitrary body returning *CreateConsumerResponse
func (c *ClientWithResponses) CreateConsumerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateConsumerResponse, error) {
	rsp, err := c.CreateConsumerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateConsumerResponse(rsp)
}

func (c *ClientWithResponses) CreateConsumerWithResponse(ctx context.Context, body CreateConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateConsumerResponse, error) {
	rsp, err := c.CreateConsumer(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateConsumerResponse(rsp)
}

// DeleteGroupOfConsumerWithResponse request returning *DeleteGroupOfConsumerResponse
func (c *ClientWithResponses) DeleteGroupOfConsumerWithResponse(ctx context.Context, consumerNameOrId string, reqEditors ...RequestEditorFn) (*DeleteGroupOfConsumerResponse, error) {
	rsp, err := c.DeleteGroupOfConsumer(ctx, consumerNameOrId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupOfConsumerResponse(rsp)
}

// ViewGroupConsumerWithResponse request returning *ViewGroupConsumerResponse
func (c *ClientWithResponses) ViewGroupConsumerWithResponse(ctx context.Context, consumerNameOrId string, reqEditors ...RequestEditorFn) (*ViewGroupConsumerResponse, error) {
	rsp, err := c.ViewGroupConsumer(ctx, consumerNameOrId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseViewGroupConsumerResponse(rsp)
}

// AddConsumerToGroupWithBodyWithResponse request with arbitrary body returning *AddConsumerToGroupResponse
func (c *ClientWithResponses) AddConsumerToGroupWithBodyWithResponse(ctx context.Context, consumerNameOrId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddConsumerToGroupResponse, error) {
	rsp, err := c.AddConsumerToGroupWithBody(ctx, consumerNameOrId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddConsumerToGroupResponse(rsp)
}

func (c *ClientWithResponses) AddConsumerToGroupWithResponse(ctx context.Context, consumerNameOrId string, body AddConsumerToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AddConsumerToGroupResponse, error) {
	rsp, err := c.AddConsumerToGroup(ctx, consumerNameOrId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddConsumerToGroupResponse(rsp)
}

// DeleteConsumerWithResponse request returning *DeleteConsumerResponse
func (c *ClientWithResponses) DeleteConsumerWithResponse(ctx context.Context, consumerUsernameOrId string, reqEditors ...RequestEditorFn) (*DeleteConsumerResponse, error) {
	rsp, err := c.DeleteConsumer(ctx, consumerUsernameOrId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteConsumerResponse(rsp)
}

// GetConsumerWithResponse request returning *GetConsumerResponse
func (c *ClientWithResponses) GetConsumerWithResponse(ctx context.Context, consumerUsernameOrId string, reqEditors ...RequestEditorFn) (*GetConsumerResponse, error) {
	rsp, err := c.GetConsumer(ctx, consumerUsernameOrId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConsumerResponse(rsp)
}

// UpdateConsumerWithBodyWithResponse request with arbitrary body returning *UpdateConsumerResponse
func (c *ClientWithResponses) UpdateConsumerWithBodyWithResponse(ctx context.Context, consumerUsernameOrId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConsumerResponse, error) {
	rsp, err := c.UpdateConsumerWithBody(ctx, consumerUsernameOrId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateConsumerResponse(rsp)
}

func (c *ClientWithResponses) UpdateConsumerWithResponse(ctx context.Context, consumerUsernameOrId string, body UpdateConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConsumerResponse, error) {
	rsp, err := c.UpdateConsumer(ctx, consumerUsernameOrId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateConsumerResponse(rsp)
}

// UpsertConsumerWithBodyWithResponse request with arbitrary body returning *UpsertConsumerResponse
func (c *ClientWithResponses) UpsertConsumerWithBodyWithResponse(ctx context.Context, consumerUsernameOrId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertConsumerResponse, error) {
	rsp, err := c.UpsertConsumerWithBody(ctx, consumerUsernameOrId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertConsumerResponse(rsp)
}

func (c *ClientWithResponses) UpsertConsumerWithResponse(ctx context.Context, consumerUsernameOrId string, body UpsertConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertConsumerResponse, error) {
	rsp, err := c.UpsertConsumer(ctx, consumerUsernameOrId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertConsumerResponse(rsp)
}

// ListPluginsForConsumerWithResponse request returning *ListPluginsForConsumerResponse
func (c *ClientWithResponses) ListPluginsForConsumerWithResponse(ctx context.Context, consumerUsernameOrId string, params *ListPluginsForConsumerParams, reqEditors ...RequestEditorFn) (*ListPluginsForConsumerResponse, error) {
	rsp, err := c.ListPluginsForConsumer(ctx, consumerUsernameOrId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPluginsForConsumerResponse(rsp)
}

// CreatePluginForConsumerWithBodyWithResponse request with arbitrary body returning *CreatePluginForConsumerResponse
func (c *ClientWithResponses) CreatePluginForConsumerWithBodyWithResponse(ctx context.Context, consumerUsernameOrId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePluginForConsumerResponse, error) {
	rsp, err := c.CreatePluginForConsumerWithBody(ctx, consumerUsernameOrId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePluginForConsumerResponse(rsp)
}

func (c *ClientWithResponses) CreatePluginForConsumerWithResponse(ctx context.Context, consumerUsernameOrId string, body CreatePluginForConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePluginForConsumerResponse, error) {
	rsp, err := c.CreatePluginForConsumer(ctx, consumerUsernameOrId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePluginForConsumerResponse(rsp)
}

// DeletePluginForConsumerWithResponse request returning *DeletePluginForConsumerResponse
func (c *ClientWithResponses) DeletePluginForConsumerWithResponse(ctx context.Context, consumerUsernameOrId string, pluginId string, reqEditors ...RequestEditorFn) (*DeletePluginForConsumerResponse, error) {
	rsp, err := c.DeletePluginForConsumer(ctx, consumerUsernameOrId, pluginId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePluginForConsumerResponse(rsp)
}

// FetchPluginForConsumerWithResponse request returning *FetchPluginForConsumerResponse
func (c *ClientWithResponses) FetchPluginForConsumerWithResponse(ctx context.Context, consumerUsernameOrId string, pluginId string, reqEditors ...RequestEditorFn) (*FetchPluginForConsumerResponse, error) {
	rsp, err := c.FetchPluginForConsumer(ctx, consumerUsernameOrId, pluginId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFetchPluginForConsumerResponse(rsp)
}

// UpdatePluginForConsumerWithBodyWithResponse request with arbitrary body returning *UpdatePluginForConsumerResponse
func (c *ClientWithResponses) UpdatePluginForConsumerWithBodyWithResponse(ctx context.Context, consumerUsernameOrId string, pluginId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePluginForConsumerResponse, error) {
	rsp, err := c.UpdatePluginForConsumerWithBody(ctx, consumerUsernameOrId, pluginId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePluginForConsumerResponse(rsp)
}

func (c *ClientWithResponses) UpdatePluginForConsumerWithResponse(ctx context.Context, consumerUsernameOrId string, pluginId string, body UpdatePluginForConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePluginForConsumerResponse, error) {
	rsp, err := c.UpdatePluginForConsumer(ctx, consumerUsernameOrId, pluginId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePluginForConsumerResponse(rsp)
}

// UpsertPluginForConsumerWithBodyWithResponse request with arbitrary body returning *UpsertPluginForConsumerResponse
func (c *ClientWithResponses) UpsertPluginForConsumerWithBodyWithResponse(ctx context.Context, consumerUsernameOrId string, pluginId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertPluginForConsumerResponse, error) {
	rsp, err := c.UpsertPluginForConsumerWithBody(ctx, consumerUsernameOrId, pluginId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertPluginForConsumerResponse(rsp)
}

func (c *ClientWithResponses) UpsertPluginForConsumerWithResponse(ctx context.Context, consumerUsernameOrId string, pluginId string, body UpsertPluginForConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertPluginForConsumerResponse, error) {
	rsp, err := c.UpsertPluginForConsumer(ctx, consumerUsernameOrId, pluginId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertPluginForConsumerResponse(rsp)
}

// PutDebugClusterControlPlanesNodesLogLevelLogLevelWithResponse request returning *PutDebugClusterControlPlanesNodesLogLevelLogLevelResponse
func (c *ClientWithResponses) PutDebugClusterControlPlanesNodesLogLevelLogLevelWithResponse(ctx context.Context, logLevel PutDebugClusterControlPlanesNodesLogLevelLogLevelParamsLogLevel, reqEditors ...RequestEditorFn) (*PutDebugClusterControlPlanesNodesLogLevelLogLevelResponse, error) {
	rsp, err := c.PutDebugClusterControlPlanesNodesLogLevelLogLevel(ctx, logLevel, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutDebugClusterControlPlanesNodesLogLevelLogLevelResponse(rsp)
}

// PutDebugClusterLogLevelLogLevelWithResponse request returning *PutDebugClusterLogLevelLogLevelResponse
func (c *ClientWithResponses) PutDebugClusterLogLevelLogLevelWithResponse(ctx context.Context, logLevel PutDebugClusterLogLevelLogLevelParamsLogLevel, reqEditors ...RequestEditorFn) (*PutDebugClusterLogLevelLogLevelResponse, error) {
	rsp, err := c.PutDebugClusterLogLevelLogLevel(ctx, logLevel, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutDebugClusterLogLevelLogLevelResponse(rsp)
}

// GetDebugNodeLogLevelWithResponse request returning *GetDebugNodeLogLevelResponse
func (c *ClientWithResponses) GetDebugNodeLogLevelWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDebugNodeLogLevelResponse, error) {
	rsp, err := c.GetDebugNodeLogLevel(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDebugNodeLogLevelResponse(rsp)
}

// PutDebugNodeLogLevelLogLevelWithResponse request returning *PutDebugNodeLogLevelLogLevelResponse
func (c *ClientWithResponses) PutDebugNodeLogLevelLogLevelWithResponse(ctx context.Context, logLevel PutDebugNodeLogLevelLogLevelParamsLogLevel, reqEditors ...RequestEditorFn) (*PutDebugNodeLogLevelLogLevelResponse, error) {
	rsp, err := c.PutDebugNodeLogLevelLogLevel(ctx, logLevel, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutDebugNodeLogLevelLogLevelResponse(rsp)
}

// GetEndpointsWithResponse request returning *GetEndpointsResponse
func (c *ClientWithResponses) GetEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEndpointsResponse, error) {
	rsp, err := c.GetEndpoints(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEndpointsResponse(rsp)
}

// GetFilterChainsWithResponse request returning *GetFilterChainsResponse
func (c *ClientWithResponses) GetFilterChainsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFilterChainsResponse, error) {
	rsp, err := c.GetFilterChains(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFilterChainsResponse(rsp)
}

// PostFilterChainsWithBodyWithResponse request with arbitrary body returning *PostFilterChainsResponse
func (c *ClientWithResponses) PostFilterChainsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFilterChainsResponse, error) {
	rsp, err := c.PostFilterChainsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFilterChainsResponse(rsp)
}

func (c *ClientWithResponses) PostFilterChainsWithResponse(ctx context.Context, body PostFilterChainsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFilterChainsResponse, error) {
	rsp, err := c.PostFilterChains(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFilterChainsResponse(rsp)
}

// DeleteFilterChainsFilterChainIdWithResponse request returning *DeleteFilterChainsFilterChainIdResponse
func (c *ClientWithResponses) DeleteFilterChainsFilterChainIdWithResponse(ctx context.Context, filterChainId string, reqEditors ...RequestEditorFn) (*DeleteFilterChainsFilterChainIdResponse, error) {
	rsp, err := c.DeleteFilterChainsFilterChainId(ctx, filterChainId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFilterChainsFilterChainIdResponse(rsp)
}

// GetFilterChainsFilterChainIdWithResponse request returning *GetFilterChainsFilterChainIdResponse
func (c *ClientWithResponses) GetFilterChainsFilterChainIdWithResponse(ctx context.Context, filterChainId string, reqEditors ...RequestEditorFn) (*GetFilterChainsFilterChainIdResponse, error) {
	rsp, err := c.GetFilterChainsFilterChainId(ctx, filterChainId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFilterChainsFilterChainIdResponse(rsp)
}

// PatchFilterChainsFilterChainIdWithBodyWithResponse request with arbitrary body returning *PatchFilterChainsFilterChainIdResponse
func (c *ClientWithResponses) PatchFilterChainsFilterChainIdWithBodyWithResponse(ctx context.Context, filterChainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchFilterChainsFilterChainIdResponse, error) {
	rsp, err := c.PatchFilterChainsFilterChainIdWithBody(ctx, filterChainId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchFilterChainsFilterChainIdResponse(rsp)
}

func (c *ClientWithResponses) PatchFilterChainsFilterChainIdWithResponse(ctx context.Context, filterChainId string, body PatchFilterChainsFilterChainIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchFilterChainsFilterChainIdResponse, error) {
	rsp, err := c.PatchFilterChainsFilterChainId(ctx, filterChainId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchFilterChainsFilterChainIdResponse(rsp)
}

// PutFilterChainsFilterChainIdWithBodyWithResponse request with arbitrary body returning *PutFilterChainsFilterChainIdResponse
func (c *ClientWithResponses) PutFilterChainsFilterChainIdWithBodyWithResponse(ctx context.Context, filterChainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutFilterChainsFilterChainIdResponse, error) {
	rsp, err := c.PutFilterChainsFilterChainIdWithBody(ctx, filterChainId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutFilterChainsFilterChainIdResponse(rsp)
}

func (c *ClientWithResponses) PutFilterChainsFilterChainIdWithResponse(ctx context.Context, filterChainId string, body PutFilterChainsFilterChainIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutFilterChainsFilterChainIdResponse, error) {
	rsp, err := c.PutFilterChainsFilterChainId(ctx, filterChainId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutFilterChainsFilterChainIdResponse(rsp)
}

// ListKeySetWithResponse request returning *ListKeySetResponse
func (c *ClientWithResponses) ListKeySetWithResponse(ctx context.Context, params *ListKeySetParams, reqEditors ...RequestEditorFn) (*ListKeySetResponse, error) {
	rsp, err := c.ListKeySet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListKeySetResponse(rsp)
}

// CreateKeySetWithBodyWithResponse request with arbitrary body returning *CreateKeySetResponse
func (c *ClientWithResponses) CreateKeySetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeySetResponse, error) {
	rsp, err := c.CreateKeySetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeySetResponse(rsp)
}

func (c *ClientWithResponses) CreateKeySetWithResponse(ctx context.Context, body CreateKeySetJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeySetResponse, error) {
	rsp, err := c.CreateKeySet(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeySetResponse(rsp)
}

// DeleteKeySetWithResponse request returning *DeleteKeySetResponse
func (c *ClientWithResponses) DeleteKeySetWithResponse(ctx context.Context, keySetIdOrName string, reqEditors ...RequestEditorFn) (*DeleteKeySetResponse, error) {
	rsp, err := c.DeleteKeySet(ctx, keySetIdOrName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteKeySetResponse(rsp)
}

// GetKeySetWithResponse request returning *GetKeySetResponse
func (c *ClientWithResponses) GetKeySetWithResponse(ctx context.Context, keySetIdOrName string, reqEditors ...RequestEditorFn) (*GetKeySetResponse, error) {
	rsp, err := c.GetKeySet(ctx, keySetIdOrName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeySetResponse(rsp)
}

// UpdateKeySetWithBodyWithResponse request with arbitrary body returning *UpdateKeySetResponse
func (c *ClientWithResponses) UpdateKeySetWithBodyWithResponse(ctx context.Context, keySetIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateKeySetResponse, error) {
	rsp, err := c.UpdateKeySetWithBody(ctx, keySetIdOrName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateKeySetResponse(rsp)
}

func (c *ClientWithResponses) UpdateKeySetWithResponse(ctx context.Context, keySetIdOrName string, body UpdateKeySetJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateKeySetResponse, error) {
	rsp, err := c.UpdateKeySet(ctx, keySetIdOrName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateKeySetResponse(rsp)
}

// UpsertKeySetWithBodyWithResponse request with arbitrary body returning *UpsertKeySetResponse
func (c *ClientWithResponses) UpsertKeySetWithBodyWithResponse(ctx context.Context, keySetIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertKeySetResponse, error) {
	rsp, err := c.UpsertKeySetWithBody(ctx, keySetIdOrName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertKeySetResponse(rsp)
}

func (c *ClientWithResponses) UpsertKeySetWithResponse(ctx context.Context, keySetIdOrName string, body UpsertKeySetJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertKeySetResponse, error) {
	rsp, err := c.UpsertKeySet(ctx, keySetIdOrName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertKeySetResponse(rsp)
}

// ListKeyWithResponse request returning *ListKeyResponse
func (c *ClientWithResponses) ListKeyWithResponse(ctx context.Context, params *ListKeyParams, reqEditors ...RequestEditorFn) (*ListKeyResponse, error) {
	rsp, err := c.ListKey(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListKeyResponse(rsp)
}

// CreateKeyWithBodyWithResponse request with arbitrary body returning *CreateKeyResponse
func (c *ClientWithResponses) CreateKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeyResponse, error) {
	rsp, err := c.CreateKeyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeyResponse(rsp)
}

func (c *ClientWithResponses) CreateKeyWithResponse(ctx context.Context, body CreateKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeyResponse, error) {
	rsp, err := c.CreateKey(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeyResponse(rsp)
}

// DeleteKeyWithResponse request returning *DeleteKeyResponse
func (c *ClientWithResponses) DeleteKeyWithResponse(ctx context.Context, keyIdOrName string, reqEditors ...RequestEditorFn) (*DeleteKeyResponse, error) {
	rsp, err := c.DeleteKey(ctx, keyIdOrName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteKeyResponse(rsp)
}

// GetKeyWithResponse request returning *GetKeyResponse
func (c *ClientWithResponses) GetKeyWithResponse(ctx context.Context, keyIdOrName string, reqEditors ...RequestEditorFn) (*GetKeyResponse, error) {
	rsp, err := c.GetKey(ctx, keyIdOrName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeyResponse(rsp)
}

// UpdateKeyWithBodyWithResponse request with arbitrary body returning *UpdateKeyResponse
func (c *ClientWithResponses) UpdateKeyWithBodyWithResponse(ctx context.Context, keyIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateKeyResponse, error) {
	rsp, err := c.UpdateKeyWithBody(ctx, keyIdOrName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateKeyResponse(rsp)
}

func (c *ClientWithResponses) UpdateKeyWithResponse(ctx context.Context, keyIdOrName string, body UpdateKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateKeyResponse, error) {
	rsp, err := c.UpdateKey(ctx, keyIdOrName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateKeyResponse(rsp)
}

// UpsertKeyWithBodyWithResponse request with arbitrary body returning *UpsertKeyResponse
func (c *ClientWithResponses) UpsertKeyWithBodyWithResponse(ctx context.Context, keyIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertKeyResponse, error) {
	rsp, err := c.UpsertKeyWithBody(ctx, keyIdOrName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertKeyResponse(rsp)
}

func (c *ClientWithResponses) UpsertKeyWithResponse(ctx context.Context, keyIdOrName string, body UpsertKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertKeyResponse, error) {
	rsp, err := c.UpsertKey(ctx, keyIdOrName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertKeyResponse(rsp)
}

// ListPluginWithResponse request returning *ListPluginResponse
func (c *ClientWithResponses) ListPluginWithResponse(ctx context.Context, params *ListPluginParams, reqEditors ...RequestEditorFn) (*ListPluginResponse, error) {
	rsp, err := c.ListPlugin(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPluginResponse(rsp)
}

// CreatePluginWithBodyWithResponse request with arbitrary body returning *CreatePluginResponse
func (c *ClientWithResponses) CreatePluginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePluginResponse, error) {
	rsp, err := c.CreatePluginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePluginResponse(rsp)
}

func (c *ClientWithResponses) CreatePluginWithResponse(ctx context.Context, body CreatePluginJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePluginResponse, error) {
	rsp, err := c.CreatePlugin(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePluginResponse(rsp)
}

// DeletePluginWithResponse request returning *DeletePluginResponse
func (c *ClientWithResponses) DeletePluginWithResponse(ctx context.Context, pluginId string, reqEditors ...RequestEditorFn) (*DeletePluginResponse, error) {
	rsp, err := c.DeletePlugin(ctx, pluginId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePluginResponse(rsp)
}

// GetPluginWithResponse request returning *GetPluginResponse
func (c *ClientWithResponses) GetPluginWithResponse(ctx context.Context, pluginId string, reqEditors ...RequestEditorFn) (*GetPluginResponse, error) {
	rsp, err := c.GetPlugin(ctx, pluginId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPluginResponse(rsp)
}

// UpdatePluginWithBodyWithResponse request with arbitrary body returning *UpdatePluginResponse
func (c *ClientWithResponses) UpdatePluginWithBodyWithResponse(ctx context.Context, pluginId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePluginResponse, error) {
	rsp, err := c.UpdatePluginWithBody(ctx, pluginId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePluginResponse(rsp)
}

func (c *ClientWithResponses) UpdatePluginWithResponse(ctx context.Context, pluginId string, body UpdatePluginJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePluginResponse, error) {
	rsp, err := c.UpdatePlugin(ctx, pluginId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePluginResponse(rsp)
}

// UpsertPluginWithBodyWithResponse request with arbitrary body returning *UpsertPluginResponse
func (c *ClientWithResponses) UpsertPluginWithBodyWithResponse(ctx context.Context, pluginId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertPluginResponse, error) {
	rsp, err := c.UpsertPluginWithBody(ctx, pluginId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertPluginResponse(rsp)
}

func (c *ClientWithResponses) UpsertPluginWithResponse(ctx context.Context, pluginId string, body UpsertPluginJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertPluginResponse, error) {
	rsp, err := c.UpsertPlugin(ctx, pluginId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertPluginResponse(rsp)
}

// ListRouteWithResponse request returning *ListRouteResponse
func (c *ClientWithResponses) ListRouteWithResponse(ctx context.Context, params *ListRouteParams, reqEditors ...RequestEditorFn) (*ListRouteResponse, error) {
	rsp, err := c.ListRoute(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRouteResponse(rsp)
}

// CreateRouteWithBodyWithResponse request with arbitrary body returning *CreateRouteResponse
func (c *ClientWithResponses) CreateRouteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRouteResponse, error) {
	rsp, err := c.CreateRouteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRouteResponse(rsp)
}

func (c *ClientWithResponses) CreateRouteWithResponse(ctx context.Context, body CreateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRouteResponse, error) {
	rsp, err := c.CreateRoute(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRouteResponse(rsp)
}

// DeleteRouteWithResponse request returning *DeleteRouteResponse
func (c *ClientWithResponses) DeleteRouteWithResponse(ctx context.Context, routeIdOrName string, reqEditors ...RequestEditorFn) (*DeleteRouteResponse, error) {
	rsp, err := c.DeleteRoute(ctx, routeIdOrName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRouteResponse(rsp)
}

// GetRouteWithResponse request returning *GetRouteResponse
func (c *ClientWithResponses) GetRouteWithResponse(ctx context.Context, routeIdOrName string, reqEditors ...RequestEditorFn) (*GetRouteResponse, error) {
	rsp, err := c.GetRoute(ctx, routeIdOrName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRouteResponse(rsp)
}

// UpdateRouteWithBodyWithResponse request with arbitrary body returning *UpdateRouteResponse
func (c *ClientWithResponses) UpdateRouteWithBodyWithResponse(ctx context.Context, routeIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRouteResponse, error) {
	rsp, err := c.UpdateRouteWithBody(ctx, routeIdOrName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRouteResponse(rsp)
}

func (c *ClientWithResponses) UpdateRouteWithResponse(ctx context.Context, routeIdOrName string, body UpdateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRouteResponse, error) {
	rsp, err := c.UpdateRoute(ctx, routeIdOrName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRouteResponse(rsp)
}

// UpsertRouteWithBodyWithResponse request with arbitrary body returning *UpsertRouteResponse
func (c *ClientWithResponses) UpsertRouteWithBodyWithResponse(ctx context.Context, routeIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertRouteResponse, error) {
	rsp, err := c.UpsertRouteWithBody(ctx, routeIdOrName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertRouteResponse(rsp)
}

func (c *ClientWithResponses) UpsertRouteWithResponse(ctx context.Context, routeIdOrName string, body UpsertRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertRouteResponse, error) {
	rsp, err := c.UpsertRoute(ctx, routeIdOrName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertRouteResponse(rsp)
}

// GetRoutesRouteIdOrNameFilterChainsWithResponse request returning *GetRoutesRouteIdOrNameFilterChainsResponse
func (c *ClientWithResponses) GetRoutesRouteIdOrNameFilterChainsWithResponse(ctx context.Context, routeIdOrName string, reqEditors ...RequestEditorFn) (*GetRoutesRouteIdOrNameFilterChainsResponse, error) {
	rsp, err := c.GetRoutesRouteIdOrNameFilterChains(ctx, routeIdOrName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoutesRouteIdOrNameFilterChainsResponse(rsp)
}

// PatchRoutesRouteIdOrNameFilterChainsWithBodyWithResponse request with arbitrary body returning *PatchRoutesRouteIdOrNameFilterChainsResponse
func (c *ClientWithResponses) PatchRoutesRouteIdOrNameFilterChainsWithBodyWithResponse(ctx context.Context, routeIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchRoutesRouteIdOrNameFilterChainsResponse, error) {
	rsp, err := c.PatchRoutesRouteIdOrNameFilterChainsWithBody(ctx, routeIdOrName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchRoutesRouteIdOrNameFilterChainsResponse(rsp)
}

func (c *ClientWithResponses) PatchRoutesRouteIdOrNameFilterChainsWithResponse(ctx context.Context, routeIdOrName string, body PatchRoutesRouteIdOrNameFilterChainsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchRoutesRouteIdOrNameFilterChainsResponse, error) {
	rsp, err := c.PatchRoutesRouteIdOrNameFilterChains(ctx, routeIdOrName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchRoutesRouteIdOrNameFilterChainsResponse(rsp)
}

// GetRoutesRouteNameOrIdFilterChainsWithBodyWithResponse request with arbitrary body returning *GetRoutesRouteNameOrIdFilterChainsResponse
func (c *ClientWithResponses) GetRoutesRouteNameOrIdFilterChainsWithBodyWithResponse(ctx context.Context, routeIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetRoutesRouteNameOrIdFilterChainsResponse, error) {
	rsp, err := c.GetRoutesRouteNameOrIdFilterChainsWithBody(ctx, routeIdOrName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoutesRouteNameOrIdFilterChainsResponse(rsp)
}

func (c *ClientWithResponses) GetRoutesRouteNameOrIdFilterChainsWithResponse(ctx context.Context, routeIdOrName string, body GetRoutesRouteNameOrIdFilterChainsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetRoutesRouteNameOrIdFilterChainsResponse, error) {
	rsp, err := c.GetRoutesRouteNameOrIdFilterChains(ctx, routeIdOrName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoutesRouteNameOrIdFilterChainsResponse(rsp)
}

// GetRoutesRouteIdOrNameFilterChainsFilterChainIdWithResponse request returning *GetRoutesRouteIdOrNameFilterChainsFilterChainIdResponse
func (c *ClientWithResponses) GetRoutesRouteIdOrNameFilterChainsFilterChainIdWithResponse(ctx context.Context, routeIdOrName string, filterChainId string, reqEditors ...RequestEditorFn) (*GetRoutesRouteIdOrNameFilterChainsFilterChainIdResponse, error) {
	rsp, err := c.GetRoutesRouteIdOrNameFilterChainsFilterChainId(ctx, routeIdOrName, filterChainId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoutesRouteIdOrNameFilterChainsFilterChainIdResponse(rsp)
}

// PutRoutesRouteIdOrNameFilterChainsFilterChainIdWithBodyWithResponse request with arbitrary body returning *PutRoutesRouteIdOrNameFilterChainsFilterChainIdResponse
func (c *ClientWithResponses) PutRoutesRouteIdOrNameFilterChainsFilterChainIdWithBodyWithResponse(ctx context.Context, routeIdOrName string, filterChainId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutRoutesRouteIdOrNameFilterChainsFilterChainIdResponse, error) {
	rsp, err := c.PutRoutesRouteIdOrNameFilterChainsFilterChainIdWithBody(ctx, routeIdOrName, filterChainId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutRoutesRouteIdOrNameFilterChainsFilterChainIdResponse(rsp)
}

func (c *ClientWithResponses) PutRoutesRouteIdOrNameFilterChainsFilterChainIdWithResponse(ctx context.Context, routeIdOrName string, filterChainId string, body PutRoutesRouteIdOrNameFilterChainsFilterChainIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutRoutesRouteIdOrNameFilterChainsFilterChainIdResponse, error) {
	rsp, err := c.PutRoutesRouteIdOrNameFilterChainsFilterChainId(ctx, routeIdOrName, filterChainId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutRoutesRouteIdOrNameFilterChainsFilterChainIdResponse(rsp)
}

// ListPluginsForRouteWithResponse request returning *ListPluginsForRouteResponse
func (c *ClientWithResponses) ListPluginsForRouteWithResponse(ctx context.Context, routeIdOrName string, params *ListPluginsForRouteParams, reqEditors ...RequestEditorFn) (*ListPluginsForRouteResponse, error) {
	rsp, err := c.ListPluginsForRoute(ctx, routeIdOrName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPluginsForRouteResponse(rsp)
}

// CreatePluginForRouteWithBodyWithResponse request with arbitrary body returning *CreatePluginForRouteResponse
func (c *ClientWithResponses) CreatePluginForRouteWithBodyWithResponse(ctx context.Context, routeIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePluginForRouteResponse, error) {
	rsp, err := c.CreatePluginForRouteWithBody(ctx, routeIdOrName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePluginForRouteResponse(rsp)
}

func (c *ClientWithResponses) CreatePluginForRouteWithResponse(ctx context.Context, routeIdOrName string, body CreatePluginForRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePluginForRouteResponse, error) {
	rsp, err := c.CreatePluginForRoute(ctx, routeIdOrName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePluginForRouteResponse(rsp)
}

// DeletePluginForRouteWithResponse request returning *DeletePluginForRouteResponse
func (c *ClientWithResponses) DeletePluginForRouteWithResponse(ctx context.Context, routeIdOrName string, pluginId string, reqEditors ...RequestEditorFn) (*DeletePluginForRouteResponse, error) {
	rsp, err := c.DeletePluginForRoute(ctx, routeIdOrName, pluginId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePluginForRouteResponse(rsp)
}

// FetchPluginForRouteWithResponse request returning *FetchPluginForRouteResponse
func (c *ClientWithResponses) FetchPluginForRouteWithResponse(ctx context.Context, routeIdOrName string, pluginId string, reqEditors ...RequestEditorFn) (*FetchPluginForRouteResponse, error) {
	rsp, err := c.FetchPluginForRoute(ctx, routeIdOrName, pluginId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFetchPluginForRouteResponse(rsp)
}

// UpdatePluginForRouteWithBodyWithResponse request with arbitrary body returning *UpdatePluginForRouteResponse
func (c *ClientWithResponses) UpdatePluginForRouteWithBodyWithResponse(ctx context.Context, routeIdOrName string, pluginId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePluginForRouteResponse, error) {
	rsp, err := c.UpdatePluginForRouteWithBody(ctx, routeIdOrName, pluginId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePluginForRouteResponse(rsp)
}

func (c *ClientWithResponses) UpdatePluginForRouteWithResponse(ctx context.Context, routeIdOrName string, pluginId string, body UpdatePluginForRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePluginForRouteResponse, error) {
	rsp, err := c.UpdatePluginForRoute(ctx, routeIdOrName, pluginId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePluginForRouteResponse(rsp)
}

// UpsertPluginForRouteWithBodyWithResponse request with arbitrary body returning *UpsertPluginForRouteResponse
func (c *ClientWithResponses) UpsertPluginForRouteWithBodyWithResponse(ctx context.Context, routeIdOrName string, pluginId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertPluginForRouteResponse, error) {
	rsp, err := c.UpsertPluginForRouteWithBody(ctx, routeIdOrName, pluginId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertPluginForRouteResponse(rsp)
}

func (c *ClientWithResponses) UpsertPluginForRouteWithResponse(ctx context.Context, routeIdOrName string, pluginId string, body UpsertPluginForRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertPluginForRouteResponse, error) {
	rsp, err := c.UpsertPluginForRoute(ctx, routeIdOrName, pluginId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertPluginForRouteResponse(rsp)
}

// GetRoutesRouteIdOrNameFilterChainIdWithResponse request returning *GetRoutesRouteIdOrNameFilterChainIdResponse
func (c *ClientWithResponses) GetRoutesRouteIdOrNameFilterChainIdWithResponse(ctx context.Context, routeIdOrName string, filterChainId string, reqEditors ...RequestEditorFn) (*GetRoutesRouteIdOrNameFilterChainIdResponse, error) {
	rsp, err := c.GetRoutesRouteIdOrNameFilterChainId(ctx, routeIdOrName, filterChainId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoutesRouteIdOrNameFilterChainIdResponse(rsp)
}

// GetSchemasFiltersFilterNameWithResponse request returning *GetSchemasFiltersFilterNameResponse
func (c *ClientWithResponses) GetSchemasFiltersFilterNameWithResponse(ctx context.Context, filterName string, reqEditors ...RequestEditorFn) (*GetSchemasFiltersFilterNameResponse, error) {
	rsp, err := c.GetSchemasFiltersFilterName(ctx, filterName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchemasFiltersFilterNameResponse(rsp)
}

// PostSchemasPluginsValidateWithResponse request returning *PostSchemasPluginsValidateResponse
func (c *ClientWithResponses) PostSchemasPluginsValidateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostSchemasPluginsValidateResponse, error) {
	rsp, err := c.PostSchemasPluginsValidate(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSchemasPluginsValidateResponse(rsp)
}

// GetSchemasPluginsPluginNameWithResponse request returning *GetSchemasPluginsPluginNameResponse
func (c *ClientWithResponses) GetSchemasPluginsPluginNameWithResponse(ctx context.Context, pluginName string, reqEditors ...RequestEditorFn) (*GetSchemasPluginsPluginNameResponse, error) {
	rsp, err := c.GetSchemasPluginsPluginName(ctx, pluginName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchemasPluginsPluginNameResponse(rsp)
}

// GetSchemasVaultsVaultNameWithResponse request returning *GetSchemasVaultsVaultNameResponse
func (c *ClientWithResponses) GetSchemasVaultsVaultNameWithResponse(ctx context.Context, vaultName string, reqEditors ...RequestEditorFn) (*GetSchemasVaultsVaultNameResponse, error) {
	rsp, err := c.GetSchemasVaultsVaultName(ctx, vaultName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchemasVaultsVaultNameResponse(rsp)
}

// PostSchemasVaultsValidateWithBodyWithResponse request with arbitrary body returning *PostSchemasVaultsValidateResponse
func (c *ClientWithResponses) PostSchemasVaultsValidateWithBodyWithResponse(ctx context.Context, vaultName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSchemasVaultsValidateResponse, error) {
	rsp, err := c.PostSchemasVaultsValidateWithBody(ctx, vaultName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSchemasVaultsValidateResponse(rsp)
}

func (c *ClientWithResponses) PostSchemasVaultsValidateWithResponse(ctx context.Context, vaultName string, body PostSchemasVaultsValidateJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSchemasVaultsValidateResponse, error) {
	rsp, err := c.PostSchemasVaultsValidate(ctx, vaultName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSchemasVaultsValidateResponse(rsp)
}

// GetSchemasEntityWithResponse request returning *GetSchemasEntityResponse
func (c *ClientWithResponses) GetSchemasEntityWithResponse(ctx context.Context, entity string, reqEditors ...RequestEditorFn) (*GetSchemasEntityResponse, error) {
	rsp, err := c.GetSchemasEntity(ctx, entity, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchemasEntityResponse(rsp)
}

// PostSchemasEntityValidateWithResponse request returning *PostSchemasEntityValidateResponse
func (c *ClientWithResponses) PostSchemasEntityValidateWithResponse(ctx context.Context, entity string, reqEditors ...RequestEditorFn) (*PostSchemasEntityValidateResponse, error) {
	rsp, err := c.PostSchemasEntityValidate(ctx, entity, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSchemasEntityValidateResponse(rsp)
}

// ListServiceWithResponse request returning *ListServiceResponse
func (c *ClientWithResponses) ListServiceWithResponse(ctx context.Context, params *ListServiceParams, reqEditors ...RequestEditorFn) (*ListServiceResponse, error) {
	rsp, err := c.ListService(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListServiceResponse(rsp)
}

// CreateServiceWithBodyWithResponse request with arbitrary body returning *CreateServiceResponse
func (c *ClientWithResponses) CreateServiceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceResponse, error) {
	rsp, err := c.CreateServiceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceResponse(rsp)
}

func (c *ClientWithResponses) CreateServiceWithResponse(ctx context.Context, body CreateServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceResponse, error) {
	rsp, err := c.CreateService(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceResponse(rsp)
}

// DeleteServiceWithResponse request returning *DeleteServiceResponse
func (c *ClientWithResponses) DeleteServiceWithResponse(ctx context.Context, serviceIdOrName string, reqEditors ...RequestEditorFn) (*DeleteServiceResponse, error) {
	rsp, err := c.DeleteService(ctx, serviceIdOrName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServiceResponse(rsp)
}

// GetServiceWithResponse request returning *GetServiceResponse
func (c *ClientWithResponses) GetServiceWithResponse(ctx context.Context, serviceIdOrName string, reqEditors ...RequestEditorFn) (*GetServiceResponse, error) {
	rsp, err := c.GetService(ctx, serviceIdOrName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceResponse(rsp)
}

// UpdateServiceWithBodyWithResponse request with arbitrary body returning *UpdateServiceResponse
func (c *ClientWithResponses) UpdateServiceWithBodyWithResponse(ctx context.Context, serviceIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceResponse, error) {
	rsp, err := c.UpdateServiceWithBody(ctx, serviceIdOrName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceResponse(rsp)
}

func (c *ClientWithResponses) UpdateServiceWithResponse(ctx context.Context, serviceIdOrName string, body UpdateServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceResponse, error) {
	rsp, err := c.UpdateService(ctx, serviceIdOrName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceResponse(rsp)
}

// UpsertServiceWithBodyWithResponse request with arbitrary body returning *UpsertServiceResponse
func (c *ClientWithResponses) UpsertServiceWithBodyWithResponse(ctx context.Context, serviceIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertServiceResponse, error) {
	rsp, err := c.UpsertServiceWithBody(ctx, serviceIdOrName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertServiceResponse(rsp)
}

func (c *ClientWithResponses) UpsertServiceWithResponse(ctx context.Context, serviceIdOrName string, body UpsertServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertServiceResponse, error) {
	rsp, err := c.UpsertService(ctx, serviceIdOrName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertServiceResponse(rsp)
}

// GetServiceIdOrNameFilterChainsWithResponse request returning *GetServiceIdOrNameFilterChainsResponse
func (c *ClientWithResponses) GetServiceIdOrNameFilterChainsWithResponse(ctx context.Context, serviceIdOrName string, reqEditors ...RequestEditorFn) (*GetServiceIdOrNameFilterChainsResponse, error) {
	rsp, err := c.GetServiceIdOrNameFilterChains(ctx, serviceIdOrName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceIdOrNameFilterChainsResponse(rsp)
}

// GetServicesServiceIdOrNameFilterChainsWithBodyWithResponse request with arbitrary body returning *GetServicesServiceIdOrNameFilterChainsResponse
func (c *ClientWithResponses) GetServicesServiceIdOrNameFilterChainsWithBodyWithResponse(ctx context.Context, serviceIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetServicesServiceIdOrNameFilterChainsResponse, error) {
	rsp, err := c.GetServicesServiceIdOrNameFilterChainsWithBody(ctx, serviceIdOrName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServicesServiceIdOrNameFilterChainsResponse(rsp)
}

func (c *ClientWithResponses) GetServicesServiceIdOrNameFilterChainsWithResponse(ctx context.Context, serviceIdOrName string, body GetServicesServiceIdOrNameFilterChainsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetServicesServiceIdOrNameFilterChainsResponse, error) {
	rsp, err := c.GetServicesServiceIdOrNameFilterChains(ctx, serviceIdOrName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServicesServiceIdOrNameFilterChainsResponse(rsp)
}

// DeleteServicesServiceIdOrNameFilterChainsFilterChainIdWithResponse request returning *DeleteServicesServiceIdOrNameFilterChainsFilterChainIdResponse
func (c *ClientWithResponses) DeleteServicesServiceIdOrNameFilterChainsFilterChainIdWithResponse(ctx context.Context, serviceIdOrName string, filterChainId string, reqEditors ...RequestEditorFn) (*DeleteServicesServiceIdOrNameFilterChainsFilterChainIdResponse, error) {
	rsp, err := c.DeleteServicesServiceIdOrNameFilterChainsFilterChainId(ctx, serviceIdOrName, filterChainId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServicesServiceIdOrNameFilterChainsFilterChainIdResponse(rsp)
}

// DeletePluginForAServiceWithResponse request returning *DeletePluginForAServiceResponse
func (c *ClientWithResponses) DeletePluginForAServiceWithResponse(ctx context.Context, serviceIdOrName string, pluginId string, reqEditors ...RequestEditorFn) (*DeletePluginForAServiceResponse, error) {
	rsp, err := c.DeletePluginForAService(ctx, serviceIdOrName, pluginId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePluginForAServiceResponse(rsp)
}

// FetchPluginWithAServiceWithResponse request returning *FetchPluginWithAServiceResponse
func (c *ClientWithResponses) FetchPluginWithAServiceWithResponse(ctx context.Context, serviceIdOrName string, pluginId string, reqEditors ...RequestEditorFn) (*FetchPluginWithAServiceResponse, error) {
	rsp, err := c.FetchPluginWithAService(ctx, serviceIdOrName, pluginId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFetchPluginWithAServiceResponse(rsp)
}

// UpdatePluginForAServiceWithBodyWithResponse request with arbitrary body returning *UpdatePluginForAServiceResponse
func (c *ClientWithResponses) UpdatePluginForAServiceWithBodyWithResponse(ctx context.Context, serviceIdOrName string, pluginId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePluginForAServiceResponse, error) {
	rsp, err := c.UpdatePluginForAServiceWithBody(ctx, serviceIdOrName, pluginId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePluginForAServiceResponse(rsp)
}

func (c *ClientWithResponses) UpdatePluginForAServiceWithResponse(ctx context.Context, serviceIdOrName string, pluginId string, body UpdatePluginForAServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePluginForAServiceResponse, error) {
	rsp, err := c.UpdatePluginForAService(ctx, serviceIdOrName, pluginId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePluginForAServiceResponse(rsp)
}

// UpsertPluginForAServiceWithBodyWithResponse request with arbitrary body returning *UpsertPluginForAServiceResponse
func (c *ClientWithResponses) UpsertPluginForAServiceWithBodyWithResponse(ctx context.Context, serviceIdOrName string, pluginId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertPluginForAServiceResponse, error) {
	rsp, err := c.UpsertPluginForAServiceWithBody(ctx, serviceIdOrName, pluginId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertPluginForAServiceResponse(rsp)
}

func (c *ClientWithResponses) UpsertPluginForAServiceWithResponse(ctx context.Context, serviceIdOrName string, pluginId string, body UpsertPluginForAServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertPluginForAServiceResponse, error) {
	rsp, err := c.UpsertPluginForAService(ctx, serviceIdOrName, pluginId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertPluginForAServiceResponse(rsp)
}

// ListRoutesForServiceWithResponse request returning *ListRoutesForServiceResponse
func (c *ClientWithResponses) ListRoutesForServiceWithResponse(ctx context.Context, serviceIdOrName string, params *ListRoutesForServiceParams, reqEditors ...RequestEditorFn) (*ListRoutesForServiceResponse, error) {
	rsp, err := c.ListRoutesForService(ctx, serviceIdOrName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRoutesForServiceResponse(rsp)
}

// CreateRouteForServiceWithBodyWithResponse request with arbitrary body returning *CreateRouteForServiceResponse
func (c *ClientWithResponses) CreateRouteForServiceWithBodyWithResponse(ctx context.Context, serviceIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRouteForServiceResponse, error) {
	rsp, err := c.CreateRouteForServiceWithBody(ctx, serviceIdOrName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRouteForServiceResponse(rsp)
}

func (c *ClientWithResponses) CreateRouteForServiceWithResponse(ctx context.Context, serviceIdOrName string, body CreateRouteForServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRouteForServiceResponse, error) {
	rsp, err := c.CreateRouteForService(ctx, serviceIdOrName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRouteForServiceResponse(rsp)
}

// DeleteRouteForServiceWithResponse request returning *DeleteRouteForServiceResponse
func (c *ClientWithResponses) DeleteRouteForServiceWithResponse(ctx context.Context, serviceIdOrName string, routeIdOrName string, reqEditors ...RequestEditorFn) (*DeleteRouteForServiceResponse, error) {
	rsp, err := c.DeleteRouteForService(ctx, serviceIdOrName, routeIdOrName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRouteForServiceResponse(rsp)
}

// FetchRouteForServiceWithResponse request returning *FetchRouteForServiceResponse
func (c *ClientWithResponses) FetchRouteForServiceWithResponse(ctx context.Context, serviceIdOrName string, routeIdOrName string, reqEditors ...RequestEditorFn) (*FetchRouteForServiceResponse, error) {
	rsp, err := c.FetchRouteForService(ctx, serviceIdOrName, routeIdOrName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFetchRouteForServiceResponse(rsp)
}

// UpdateRouteForServiceWithBodyWithResponse request with arbitrary body returning *UpdateRouteForServiceResponse
func (c *ClientWithResponses) UpdateRouteForServiceWithBodyWithResponse(ctx context.Context, serviceIdOrName string, routeIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRouteForServiceResponse, error) {
	rsp, err := c.UpdateRouteForServiceWithBody(ctx, serviceIdOrName, routeIdOrName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRouteForServiceResponse(rsp)
}

func (c *ClientWithResponses) UpdateRouteForServiceWithResponse(ctx context.Context, serviceIdOrName string, routeIdOrName string, body UpdateRouteForServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRouteForServiceResponse, error) {
	rsp, err := c.UpdateRouteForService(ctx, serviceIdOrName, routeIdOrName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRouteForServiceResponse(rsp)
}

// UpsertRouteForServiceWithBodyWithResponse request with arbitrary body returning *UpsertRouteForServiceResponse
func (c *ClientWithResponses) UpsertRouteForServiceWithBodyWithResponse(ctx context.Context, serviceIdOrName string, routeIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertRouteForServiceResponse, error) {
	rsp, err := c.UpsertRouteForServiceWithBody(ctx, serviceIdOrName, routeIdOrName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertRouteForServiceResponse(rsp)
}

func (c *ClientWithResponses) UpsertRouteForServiceWithResponse(ctx context.Context, serviceIdOrName string, routeIdOrName string, body UpsertRouteForServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertRouteForServiceResponse, error) {
	rsp, err := c.UpsertRouteForService(ctx, serviceIdOrName, routeIdOrName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertRouteForServiceResponse(rsp)
}

// GetPluginsForServiceWithResponse request returning *GetPluginsForServiceResponse
func (c *ClientWithResponses) GetPluginsForServiceWithResponse(ctx context.Context, serviceIdOrName string, params *GetPluginsForServiceParams, reqEditors ...RequestEditorFn) (*GetPluginsForServiceResponse, error) {
	rsp, err := c.GetPluginsForService(ctx, serviceIdOrName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPluginsForServiceResponse(rsp)
}

// CreatePluginForServiceWithBodyWithResponse request with arbitrary body returning *CreatePluginForServiceResponse
func (c *ClientWithResponses) CreatePluginForServiceWithBodyWithResponse(ctx context.Context, serviceIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePluginForServiceResponse, error) {
	rsp, err := c.CreatePluginForServiceWithBody(ctx, serviceIdOrName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePluginForServiceResponse(rsp)
}

func (c *ClientWithResponses) CreatePluginForServiceWithResponse(ctx context.Context, serviceIdOrName string, body CreatePluginForServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePluginForServiceResponse, error) {
	rsp, err := c.CreatePluginForService(ctx, serviceIdOrName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePluginForServiceResponse(rsp)
}

// ListSniWithResponse request returning *ListSniResponse
func (c *ClientWithResponses) ListSniWithResponse(ctx context.Context, params *ListSniParams, reqEditors ...RequestEditorFn) (*ListSniResponse, error) {
	rsp, err := c.ListSni(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSniResponse(rsp)
}

// CreateSniWithBodyWithResponse request with arbitrary body returning *CreateSniResponse
func (c *ClientWithResponses) CreateSniWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSniResponse, error) {
	rsp, err := c.CreateSniWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSniResponse(rsp)
}

func (c *ClientWithResponses) CreateSniWithResponse(ctx context.Context, body CreateSniJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSniResponse, error) {
	rsp, err := c.CreateSni(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSniResponse(rsp)
}

// DeleteSniWithResponse request returning *DeleteSniResponse
func (c *ClientWithResponses) DeleteSniWithResponse(ctx context.Context, sniNameOrId string, reqEditors ...RequestEditorFn) (*DeleteSniResponse, error) {
	rsp, err := c.DeleteSni(ctx, sniNameOrId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSniResponse(rsp)
}

// GetSniWithResponse request returning *GetSniResponse
func (c *ClientWithResponses) GetSniWithResponse(ctx context.Context, sniNameOrId string, reqEditors ...RequestEditorFn) (*GetSniResponse, error) {
	rsp, err := c.GetSni(ctx, sniNameOrId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSniResponse(rsp)
}

// UpdateSniWithBodyWithResponse request with arbitrary body returning *UpdateSniResponse
func (c *ClientWithResponses) UpdateSniWithBodyWithResponse(ctx context.Context, sniNameOrId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSniResponse, error) {
	rsp, err := c.UpdateSniWithBody(ctx, sniNameOrId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSniResponse(rsp)
}

func (c *ClientWithResponses) UpdateSniWithResponse(ctx context.Context, sniNameOrId string, body UpdateSniJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSniResponse, error) {
	rsp, err := c.UpdateSni(ctx, sniNameOrId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSniResponse(rsp)
}

// UpsertSniWithBodyWithResponse request with arbitrary body returning *UpsertSniResponse
func (c *ClientWithResponses) UpsertSniWithBodyWithResponse(ctx context.Context, sniNameOrId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertSniResponse, error) {
	rsp, err := c.UpsertSniWithBody(ctx, sniNameOrId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertSniResponse(rsp)
}

func (c *ClientWithResponses) UpsertSniWithResponse(ctx context.Context, sniNameOrId string, body UpsertSniJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertSniResponse, error) {
	rsp, err := c.UpsertSni(ctx, sniNameOrId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertSniResponse(rsp)
}

// GetStatusWithResponse request returning *GetStatusResponse
func (c *ClientWithResponses) GetStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStatusResponse, error) {
	rsp, err := c.GetStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatusResponse(rsp)
}

// GetDnsStatusWithResponse request returning *GetDnsStatusResponse
func (c *ClientWithResponses) GetDnsStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDnsStatusResponse, error) {
	rsp, err := c.GetDnsStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDnsStatusResponse(rsp)
}

// GetTagsWithResponse request returning *GetTagsResponse
func (c *ClientWithResponses) GetTagsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTagsResponse, error) {
	rsp, err := c.GetTags(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTagsResponse(rsp)
}

// GetTagsTagsWithResponse request returning *GetTagsTagsResponse
func (c *ClientWithResponses) GetTagsTagsWithResponse(ctx context.Context, tags string, reqEditors ...RequestEditorFn) (*GetTagsTagsResponse, error) {
	rsp, err := c.GetTagsTags(ctx, tags, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTagsTagsResponse(rsp)
}

// GetTimersWithResponse request returning *GetTimersResponse
func (c *ClientWithResponses) GetTimersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTimersResponse, error) {
	rsp, err := c.GetTimers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTimersResponse(rsp)
}

// ListUpstreamWithResponse request returning *ListUpstreamResponse
func (c *ClientWithResponses) ListUpstreamWithResponse(ctx context.Context, params *ListUpstreamParams, reqEditors ...RequestEditorFn) (*ListUpstreamResponse, error) {
	rsp, err := c.ListUpstream(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUpstreamResponse(rsp)
}

// CreateUpstreamWithBodyWithResponse request with arbitrary body returning *CreateUpstreamResponse
func (c *ClientWithResponses) CreateUpstreamWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUpstreamResponse, error) {
	rsp, err := c.CreateUpstreamWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUpstreamResponse(rsp)
}

func (c *ClientWithResponses) CreateUpstreamWithResponse(ctx context.Context, body CreateUpstreamJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUpstreamResponse, error) {
	rsp, err := c.CreateUpstream(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUpstreamResponse(rsp)
}

// DeleteUpstreamWithResponse request returning *DeleteUpstreamResponse
func (c *ClientWithResponses) DeleteUpstreamWithResponse(ctx context.Context, upstreamIdOrName string, reqEditors ...RequestEditorFn) (*DeleteUpstreamResponse, error) {
	rsp, err := c.DeleteUpstream(ctx, upstreamIdOrName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUpstreamResponse(rsp)
}

// GetUpstreamWithResponse request returning *GetUpstreamResponse
func (c *ClientWithResponses) GetUpstreamWithResponse(ctx context.Context, upstreamIdOrName string, reqEditors ...RequestEditorFn) (*GetUpstreamResponse, error) {
	rsp, err := c.GetUpstream(ctx, upstreamIdOrName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUpstreamResponse(rsp)
}

// UpdateUpstreamWithBodyWithResponse request with arbitrary body returning *UpdateUpstreamResponse
func (c *ClientWithResponses) UpdateUpstreamWithBodyWithResponse(ctx context.Context, upstreamIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUpstreamResponse, error) {
	rsp, err := c.UpdateUpstreamWithBody(ctx, upstreamIdOrName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUpstreamResponse(rsp)
}

func (c *ClientWithResponses) UpdateUpstreamWithResponse(ctx context.Context, upstreamIdOrName string, body UpdateUpstreamJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUpstreamResponse, error) {
	rsp, err := c.UpdateUpstream(ctx, upstreamIdOrName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUpstreamResponse(rsp)
}

// UpsertUpstreamWithBodyWithResponse request with arbitrary body returning *UpsertUpstreamResponse
func (c *ClientWithResponses) UpsertUpstreamWithBodyWithResponse(ctx context.Context, upstreamIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertUpstreamResponse, error) {
	rsp, err := c.UpsertUpstreamWithBody(ctx, upstreamIdOrName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertUpstreamResponse(rsp)
}

func (c *ClientWithResponses) UpsertUpstreamWithResponse(ctx context.Context, upstreamIdOrName string, body UpsertUpstreamJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertUpstreamResponse, error) {
	rsp, err := c.UpsertUpstream(ctx, upstreamIdOrName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertUpstreamResponse(rsp)
}

// ListTargetsForUpstreamWithResponse request returning *ListTargetsForUpstreamResponse
func (c *ClientWithResponses) ListTargetsForUpstreamWithResponse(ctx context.Context, upstreamIdOrName string, params *ListTargetsForUpstreamParams, reqEditors ...RequestEditorFn) (*ListTargetsForUpstreamResponse, error) {
	rsp, err := c.ListTargetsForUpstream(ctx, upstreamIdOrName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTargetsForUpstreamResponse(rsp)
}

// CreateTargetForUpstreamWithBodyWithResponse request with arbitrary body returning *CreateTargetForUpstreamResponse
func (c *ClientWithResponses) CreateTargetForUpstreamWithBodyWithResponse(ctx context.Context, upstreamIdOrName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTargetForUpstreamResponse, error) {
	rsp, err := c.CreateTargetForUpstreamWithBody(ctx, upstreamIdOrName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTargetForUpstreamResponse(rsp)
}

func (c *ClientWithResponses) CreateTargetForUpstreamWithResponse(ctx context.Context, upstreamIdOrName string, body CreateTargetForUpstreamJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTargetForUpstreamResponse, error) {
	rsp, err := c.CreateTargetForUpstream(ctx, upstreamIdOrName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTargetForUpstreamResponse(rsp)
}

// DeleteUpstreamTargetWithResponse request returning *DeleteUpstreamTargetResponse
func (c *ClientWithResponses) DeleteUpstreamTargetWithResponse(ctx context.Context, upstreamIdOrName string, targetIdOrTarget string, reqEditors ...RequestEditorFn) (*DeleteUpstreamTargetResponse, error) {
	rsp, err := c.DeleteUpstreamTarget(ctx, upstreamIdOrName, targetIdOrTarget, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUpstreamTargetResponse(rsp)
}

// FetchTargetForUpstreamWithResponse request returning *FetchTargetForUpstreamResponse
func (c *ClientWithResponses) FetchTargetForUpstreamWithResponse(ctx context.Context, upstreamIdOrName string, targetIdOrTarget string, reqEditors ...RequestEditorFn) (*FetchTargetForUpstreamResponse, error) {
	rsp, err := c.FetchTargetForUpstream(ctx, upstreamIdOrName, targetIdOrTarget, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFetchTargetForUpstreamResponse(rsp)
}

// UpdateTargetForUpstreamWithBodyWithResponse request with arbitrary body returning *UpdateTargetForUpstreamResponse
func (c *ClientWithResponses) UpdateTargetForUpstreamWithBodyWithResponse(ctx context.Context, upstreamIdOrName string, targetIdOrTarget string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTargetForUpstreamResponse, error) {
	rsp, err := c.UpdateTargetForUpstreamWithBody(ctx, upstreamIdOrName, targetIdOrTarget, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTargetForUpstreamResponse(rsp)
}

func (c *ClientWithResponses) UpdateTargetForUpstreamWithResponse(ctx context.Context, upstreamIdOrName string, targetIdOrTarget string, body UpdateTargetForUpstreamJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTargetForUpstreamResponse, error) {
	rsp, err := c.UpdateTargetForUpstream(ctx, upstreamIdOrName, targetIdOrTarget, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTargetForUpstreamResponse(rsp)
}

// UpsertTargetForUpstreamWithBodyWithResponse request with arbitrary body returning *UpsertTargetForUpstreamResponse
func (c *ClientWithResponses) UpsertTargetForUpstreamWithBodyWithResponse(ctx context.Context, upstreamIdOrName string, targetIdOrTarget string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertTargetForUpstreamResponse, error) {
	rsp, err := c.UpsertTargetForUpstreamWithBody(ctx, upstreamIdOrName, targetIdOrTarget, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertTargetForUpstreamResponse(rsp)
}

func (c *ClientWithResponses) UpsertTargetForUpstreamWithResponse(ctx context.Context, upstreamIdOrName string, targetIdOrTarget string, body UpsertTargetForUpstreamJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertTargetForUpstreamResponse, error) {
	rsp, err := c.UpsertTargetForUpstream(ctx, upstreamIdOrName, targetIdOrTarget, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertTargetForUpstreamResponse(rsp)
}

// ListVaultWithResponse request returning *ListVaultResponse
func (c *ClientWithResponses) ListVaultWithResponse(ctx context.Context, params *ListVaultParams, reqEditors ...RequestEditorFn) (*ListVaultResponse, error) {
	rsp, err := c.ListVault(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVaultResponse(rsp)
}

// CreateVaultWithBodyWithResponse request with arbitrary body returning *CreateVaultResponse
func (c *ClientWithResponses) CreateVaultWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVaultResponse, error) {
	rsp, err := c.CreateVaultWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVaultResponse(rsp)
}

func (c *ClientWithResponses) CreateVaultWithResponse(ctx context.Context, body CreateVaultJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVaultResponse, error) {
	rsp, err := c.CreateVault(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVaultResponse(rsp)
}

// DeleteVaultWithResponse request returning *DeleteVaultResponse
func (c *ClientWithResponses) DeleteVaultWithResponse(ctx context.Context, vaultIdOrPrefix string, reqEditors ...RequestEditorFn) (*DeleteVaultResponse, error) {
	rsp, err := c.DeleteVault(ctx, vaultIdOrPrefix, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVaultResponse(rsp)
}

// GetVaultWithResponse request returning *GetVaultResponse
func (c *ClientWithResponses) GetVaultWithResponse(ctx context.Context, vaultIdOrPrefix string, reqEditors ...RequestEditorFn) (*GetVaultResponse, error) {
	rsp, err := c.GetVault(ctx, vaultIdOrPrefix, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVaultResponse(rsp)
}

// UpdateVaultWithBodyWithResponse request with arbitrary body returning *UpdateVaultResponse
func (c *ClientWithResponses) UpdateVaultWithBodyWithResponse(ctx context.Context, vaultIdOrPrefix string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVaultResponse, error) {
	rsp, err := c.UpdateVaultWithBody(ctx, vaultIdOrPrefix, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVaultResponse(rsp)
}

func (c *ClientWithResponses) UpdateVaultWithResponse(ctx context.Context, vaultIdOrPrefix string, body UpdateVaultJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVaultResponse, error) {
	rsp, err := c.UpdateVault(ctx, vaultIdOrPrefix, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVaultResponse(rsp)
}

// UpsertVaultWithBodyWithResponse request with arbitrary body returning *UpsertVaultResponse
func (c *ClientWithResponses) UpsertVaultWithBodyWithResponse(ctx context.Context, vaultIdOrPrefix string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertVaultResponse, error) {
	rsp, err := c.UpsertVaultWithBody(ctx, vaultIdOrPrefix, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertVaultResponse(rsp)
}

func (c *ClientWithResponses) UpsertVaultWithResponse(ctx context.Context, vaultIdOrPrefix string, body UpsertVaultJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertVaultResponse, error) {
	rsp, err := c.UpsertVault(ctx, vaultIdOrPrefix, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertVaultResponse(rsp)
}

// HeadEndpointsWithResponse request returning *HeadEndpointsResponse
func (c *ClientWithResponses) HeadEndpointsWithResponse(ctx context.Context, endpoint string, reqEditors ...RequestEditorFn) (*HeadEndpointsResponse, error) {
	rsp, err := c.HeadEndpoints(ctx, endpoint, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeadEndpointsResponse(rsp)
}

// OptionsEndpointWithResponse request returning *OptionsEndpointResponse
func (c *ClientWithResponses) OptionsEndpointWithResponse(ctx context.Context, endpoint string, reqEditors ...RequestEditorFn) (*OptionsEndpointResponse, error) {
	rsp, err := c.OptionsEndpoint(ctx, endpoint, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOptionsEndpointResponse(rsp)
}

// ParseGeInfoResponse parses an HTTP response from a GeInfoWithResponse call
func ParseGeInfoResponse(rsp *http.Response) (*GeInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GeInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GeInfo200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseListCaCertificateResponse parses an HTTP response from a ListCaCertificateWithResponse call
func ParseListCaCertificateResponse(rsp *http.Response) (*ListCaCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCaCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CACertificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseCreateCaCertificateResponse parses an HTTP response from a CreateCaCertificateWithResponse call
func ParseCreateCaCertificateResponse(rsp *http.Response) (*CreateCaCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCaCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CACertificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteCaCertificateResponse parses an HTTP response from a DeleteCaCertificateWithResponse call
func ParseDeleteCaCertificateResponse(rsp *http.Response) (*DeleteCaCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCaCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetCaCertificateResponse parses an HTTP response from a GetCaCertificateWithResponse call
func ParseGetCaCertificateResponse(rsp *http.Response) (*GetCaCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCaCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CACertificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateCaCertificateResponse parses an HTTP response from a UpdateCaCertificateWithResponse call
func ParseUpdateCaCertificateResponse(rsp *http.Response) (*UpdateCaCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCaCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CACertificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdatetCaCertificateResponse parses an HTTP response from a UpdatetCaCertificateWithResponse call
func ParseUpdatetCaCertificateResponse(rsp *http.Response) (*UpdatetCaCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatetCaCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CACertificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParsePurgeAllCacheResponse parses an HTTP response from a PurgeAllCacheWithResponse call
func ParsePurgeAllCacheResponse(rsp *http.Response) (*PurgeAllCacheResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PurgeAllCacheResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteCacheByKeyResponse parses an HTTP response from a DeleteCacheByKeyWithResponse call
func ParseDeleteCacheByKeyResponse(rsp *http.Response) (*DeleteCacheByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCacheByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCacheByKeyResponse parses an HTTP response from a GetCacheByKeyWithResponse call
func ParseGetCacheByKeyResponse(rsp *http.Response) (*GetCacheByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCacheByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCacheByKey200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetCacheByKey404Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListCertificateResponse parses an HTTP response from a ListCertificateWithResponse call
func ParseListCertificateResponse(rsp *http.Response) (*ListCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListCertificate200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateCertificateResponse parses an HTTP response from a CreateCertificateWithResponse call
func ParseCreateCertificateResponse(rsp *http.Response) (*CreateCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Certificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteCertificateResponse parses an HTTP response from a DeleteCertificateWithResponse call
func ParseDeleteCertificateResponse(rsp *http.Response) (*DeleteCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetCertificateResponse parses an HTTP response from a GetCertificateWithResponse call
func ParseGetCertificateResponse(rsp *http.Response) (*GetCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Certificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateCertificateResponse parses an HTTP response from a UpdateCertificateWithResponse call
func ParseUpdateCertificateResponse(rsp *http.Response) (*UpdateCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Certificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateCertificatePutResponse parses an HTTP response from a UpdateCertificatePutWithResponse call
func ParseUpdateCertificatePutResponse(rsp *http.Response) (*UpdateCertificatePutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCertificatePutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Certificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteSniForCertificateResponse parses an HTTP response from a DeleteSniForCertificateWithResponse call
func ParseDeleteSniForCertificateResponse(rsp *http.Response) (*DeleteSniForCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSniForCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFetchSniWithCertificateResponse parses an HTTP response from a FetchSniWithCertificateWithResponse call
func ParseFetchSniWithCertificateResponse(rsp *http.Response) (*FetchSniWithCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FetchSniWithCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SNI
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateSniForCertificateResponse parses an HTTP response from a UpdateSniForCertificateWithResponse call
func ParseUpdateSniForCertificateResponse(rsp *http.Response) (*UpdateSniForCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSniForCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SNI
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpsertSniForCertificateResponse parses an HTTP response from a UpsertSniForCertificateWithResponse call
func ParseUpsertSniForCertificateResponse(rsp *http.Response) (*UpsertSniForCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpsertSniForCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SNI
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetSniWithCertificateResponse parses an HTTP response from a GetSniWithCertificateWithResponse call
func ParseGetSniWithCertificateResponse(rsp *http.Response) (*GetSniWithCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSniWithCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetSniWithCertificate200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateSniForCertificateResponse parses an HTTP response from a CreateSniForCertificateWithResponse call
func ParseCreateSniForCertificateResponse(rsp *http.Response) (*CreateSniForCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSniForCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SNI
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetDataPlanesResponse parses an HTTP response from a GetDataPlanesWithResponse call
func ParseGetDataPlanesResponse(rsp *http.Response) (*GetDataPlanesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataPlanesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetDataPlanes200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetDataPlanes400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetDataPlaneStatusResponse parses an HTTP response from a GetDataPlaneStatusWithResponse call
func ParseGetDataPlaneStatusResponse(rsp *http.Response) (*GetDataPlaneStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataPlaneStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]GetDataPlaneStatus200ResponseValue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetDataPlanes400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListConsumerResponse parses an HTTP response from a ListConsumerWithResponse call
func ParseListConsumerResponse(rsp *http.Response) (*ListConsumerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListConsumer200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateConsumerResponse parses an HTTP response from a CreateConsumerWithResponse call
func ParseCreateConsumerResponse(rsp *http.Response) (*CreateConsumerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Consumer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteGroupOfConsumerResponse parses an HTTP response from a DeleteGroupOfConsumerWithResponse call
func ParseDeleteGroupOfConsumerResponse(rsp *http.Response) (*DeleteGroupOfConsumerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupOfConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseViewGroupConsumerResponse parses an HTTP response from a ViewGroupConsumerWithResponse call
func ParseViewGroupConsumerResponse(rsp *http.Response) (*ViewGroupConsumerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ViewGroupConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConsumerGroupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddConsumerToGroupResponse parses an HTTP response from a AddConsumerToGroupWithResponse call
func ParseAddConsumerToGroupResponse(rsp *http.Response) (*AddConsumerToGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddConsumerToGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Consumer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Consumer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteConsumerResponse parses an HTTP response from a DeleteConsumerWithResponse call
func ParseDeleteConsumerResponse(rsp *http.Response) (*DeleteConsumerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetConsumerResponse parses an HTTP response from a GetConsumerWithResponse call
func ParseGetConsumerResponse(rsp *http.Response) (*GetConsumerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Consumer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateConsumerResponse parses an HTTP response from a UpdateConsumerWithResponse call
func ParseUpdateConsumerResponse(rsp *http.Response) (*UpdateConsumerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Consumer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpsertConsumerResponse parses an HTTP response from a UpsertConsumerWithResponse call
func ParseUpsertConsumerResponse(rsp *http.Response) (*UpsertConsumerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpsertConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpsertConsumer200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListPluginsForConsumerResponse parses an HTTP response from a ListPluginsForConsumerWithResponse call
func ParseListPluginsForConsumerResponse(rsp *http.Response) (*ListPluginsForConsumerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPluginsForConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPluginsForConsumer200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreatePluginForConsumerResponse parses an HTTP response from a CreatePluginForConsumerWithResponse call
func ParseCreatePluginForConsumerResponse(rsp *http.Response) (*CreatePluginForConsumerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePluginForConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Plugin
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeletePluginForConsumerResponse parses an HTTP response from a DeletePluginForConsumerWithResponse call
func ParseDeletePluginForConsumerResponse(rsp *http.Response) (*DeletePluginForConsumerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePluginForConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFetchPluginForConsumerResponse parses an HTTP response from a FetchPluginForConsumerWithResponse call
func ParseFetchPluginForConsumerResponse(rsp *http.Response) (*FetchPluginForConsumerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FetchPluginForConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Plugin
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdatePluginForConsumerResponse parses an HTTP response from a UpdatePluginForConsumerWithResponse call
func ParseUpdatePluginForConsumerResponse(rsp *http.Response) (*UpdatePluginForConsumerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePluginForConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPluginsForConsumer200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpsertPluginForConsumerResponse parses an HTTP response from a UpsertPluginForConsumerWithResponse call
func ParseUpsertPluginForConsumerResponse(rsp *http.Response) (*UpsertPluginForConsumerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpsertPluginForConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPluginsForConsumer200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParsePutDebugClusterControlPlanesNodesLogLevelLogLevelResponse parses an HTTP response from a PutDebugClusterControlPlanesNodesLogLevelLogLevelWithResponse call
func ParsePutDebugClusterControlPlanesNodesLogLevelLogLevelResponse(rsp *http.Response) (*PutDebugClusterControlPlanesNodesLogLevelLogLevelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutDebugClusterControlPlanesNodesLogLevelLogLevelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PutDebugClusterControlPlanesNodesLogLevelLogLevel200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParsePutDebugClusterLogLevelLogLevelResponse parses an HTTP response from a PutDebugClusterLogLevelLogLevelWithResponse call
func ParsePutDebugClusterLogLevelLogLevelResponse(rsp *http.Response) (*PutDebugClusterLogLevelLogLevelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutDebugClusterLogLevelLogLevelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PutDebugClusterLogLevelLogLevel200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetDebugNodeLogLevelResponse parses an HTTP response from a GetDebugNodeLogLevelWithResponse call
func ParseGetDebugNodeLogLevelResponse(rsp *http.Response) (*GetDebugNodeLogLevelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDebugNodeLogLevelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetDebugNodeLogLevel200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParsePutDebugNodeLogLevelLogLevelResponse parses an HTTP response from a PutDebugNodeLogLevelLogLevelWithResponse call
func ParsePutDebugNodeLogLevelLogLevelResponse(rsp *http.Response) (*PutDebugNodeLogLevelLogLevelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutDebugNodeLogLevelLogLevelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PutDebugNodeLogLevelLogLevel200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetEndpointsResponse parses an HTTP response from a GetEndpointsWithResponse call
func ParseGetEndpointsResponse(rsp *http.Response) (*GetEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetEndpoints200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetFilterChainsResponse parses an HTTP response from a GetFilterChainsWithResponse call
func ParseGetFilterChainsResponse(rsp *http.Response) (*GetFilterChainsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFilterChainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FilterChains
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParsePostFilterChainsResponse parses an HTTP response from a PostFilterChainsWithResponse call
func ParsePostFilterChainsResponse(rsp *http.Response) (*PostFilterChainsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostFilterChainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest FilterChains
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteFilterChainsFilterChainIdResponse parses an HTTP response from a DeleteFilterChainsFilterChainIdWithResponse call
func ParseDeleteFilterChainsFilterChainIdResponse(rsp *http.Response) (*DeleteFilterChainsFilterChainIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFilterChainsFilterChainIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetFilterChainsFilterChainIdResponse parses an HTTP response from a GetFilterChainsFilterChainIdWithResponse call
func ParseGetFilterChainsFilterChainIdResponse(rsp *http.Response) (*GetFilterChainsFilterChainIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFilterChainsFilterChainIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FilterChains
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchFilterChainsFilterChainIdResponse parses an HTTP response from a PatchFilterChainsFilterChainIdWithResponse call
func ParsePatchFilterChainsFilterChainIdResponse(rsp *http.Response) (*PatchFilterChainsFilterChainIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchFilterChainsFilterChainIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest FilterChains
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParsePutFilterChainsFilterChainIdResponse parses an HTTP response from a PutFilterChainsFilterChainIdWithResponse call
func ParsePutFilterChainsFilterChainIdResponse(rsp *http.Response) (*PutFilterChainsFilterChainIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutFilterChainsFilterChainIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListKeySetResponse parses an HTTP response from a ListKeySetWithResponse call
func ParseListKeySetResponse(rsp *http.Response) (*ListKeySetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListKeySetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListKeySet200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateKeySetResponse parses an HTTP response from a CreateKeySetWithResponse call
func ParseCreateKeySetResponse(rsp *http.Response) (*CreateKeySetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateKeySetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListKeySet200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteKeySetResponse parses an HTTP response from a DeleteKeySetWithResponse call
func ParseDeleteKeySetResponse(rsp *http.Response) (*DeleteKeySetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteKeySetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetKeySetResponse parses an HTTP response from a GetKeySetWithResponse call
func ParseGetKeySetResponse(rsp *http.Response) (*GetKeySetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeySetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListKeySet200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateKeySetResponse parses an HTTP response from a UpdateKeySetWithResponse call
func ParseUpdateKeySetResponse(rsp *http.Response) (*UpdateKeySetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateKeySetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListKeySet200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpsertKeySetResponse parses an HTTP response from a UpsertKeySetWithResponse call
func ParseUpsertKeySetResponse(rsp *http.Response) (*UpsertKeySetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpsertKeySetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListKeySet200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListKeyResponse parses an HTTP response from a ListKeyWithResponse call
func ParseListKeyResponse(rsp *http.Response) (*ListKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListKey200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateKeyResponse parses an HTTP response from a CreateKeyWithResponse call
func ParseCreateKeyResponse(rsp *http.Response) (*CreateKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Key
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteKeyResponse parses an HTTP response from a DeleteKeyWithResponse call
func ParseDeleteKeyResponse(rsp *http.Response) (*DeleteKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetKeyResponse parses an HTTP response from a GetKeyWithResponse call
func ParseGetKeyResponse(rsp *http.Response) (*GetKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Key
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateKeyResponse parses an HTTP response from a UpdateKeyWithResponse call
func ParseUpdateKeyResponse(rsp *http.Response) (*UpdateKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Key
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpsertKeyResponse parses an HTTP response from a UpsertKeyWithResponse call
func ParseUpsertKeyResponse(rsp *http.Response) (*UpsertKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpsertKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Key
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListPluginResponse parses an HTTP response from a ListPluginWithResponse call
func ParseListPluginResponse(rsp *http.Response) (*ListPluginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPluginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPluginsForConsumer200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreatePluginResponse parses an HTTP response from a CreatePluginWithResponse call
func ParseCreatePluginResponse(rsp *http.Response) (*CreatePluginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePluginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Plugin
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeletePluginResponse parses an HTTP response from a DeletePluginWithResponse call
func ParseDeletePluginResponse(rsp *http.Response) (*DeletePluginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePluginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetPluginResponse parses an HTTP response from a GetPluginWithResponse call
func ParseGetPluginResponse(rsp *http.Response) (*GetPluginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPluginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Plugin
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdatePluginResponse parses an HTTP response from a UpdatePluginWithResponse call
func ParseUpdatePluginResponse(rsp *http.Response) (*UpdatePluginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePluginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Plugin
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpsertPluginResponse parses an HTTP response from a UpsertPluginWithResponse call
func ParseUpsertPluginResponse(rsp *http.Response) (*UpsertPluginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpsertPluginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Plugin
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListRouteResponse parses an HTTP response from a ListRouteWithResponse call
func ParseListRouteResponse(rsp *http.Response) (*ListRouteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRouteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListRoute200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateRouteResponse parses an HTTP response from a CreateRouteWithResponse call
func ParseCreateRouteResponse(rsp *http.Response) (*CreateRouteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRouteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Route
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteRouteResponse parses an HTTP response from a DeleteRouteWithResponse call
func ParseDeleteRouteResponse(rsp *http.Response) (*DeleteRouteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRouteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetRouteResponse parses an HTTP response from a GetRouteWithResponse call
func ParseGetRouteResponse(rsp *http.Response) (*GetRouteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRouteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Route
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateRouteResponse parses an HTTP response from a UpdateRouteWithResponse call
func ParseUpdateRouteResponse(rsp *http.Response) (*UpdateRouteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRouteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Route
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpsertRouteResponse parses an HTTP response from a UpsertRouteWithResponse call
func ParseUpsertRouteResponse(rsp *http.Response) (*UpsertRouteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpsertRouteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Route
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetRoutesRouteIdOrNameFilterChainsResponse parses an HTTP response from a GetRoutesRouteIdOrNameFilterChainsWithResponse call
func ParseGetRoutesRouteIdOrNameFilterChainsResponse(rsp *http.Response) (*GetRoutesRouteIdOrNameFilterChainsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoutesRouteIdOrNameFilterChainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FilterChains
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchRoutesRouteIdOrNameFilterChainsResponse parses an HTTP response from a PatchRoutesRouteIdOrNameFilterChainsWithResponse call
func ParsePatchRoutesRouteIdOrNameFilterChainsResponse(rsp *http.Response) (*PatchRoutesRouteIdOrNameFilterChainsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchRoutesRouteIdOrNameFilterChainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest FilterChains
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetRoutesRouteNameOrIdFilterChainsResponse parses an HTTP response from a GetRoutesRouteNameOrIdFilterChainsWithResponse call
func ParseGetRoutesRouteNameOrIdFilterChainsResponse(rsp *http.Response) (*GetRoutesRouteNameOrIdFilterChainsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoutesRouteNameOrIdFilterChainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest FilterChains
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetRoutesRouteIdOrNameFilterChainsFilterChainIdResponse parses an HTTP response from a GetRoutesRouteIdOrNameFilterChainsFilterChainIdWithResponse call
func ParseGetRoutesRouteIdOrNameFilterChainsFilterChainIdResponse(rsp *http.Response) (*GetRoutesRouteIdOrNameFilterChainsFilterChainIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoutesRouteIdOrNameFilterChainsFilterChainIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FilterChains
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParsePutRoutesRouteIdOrNameFilterChainsFilterChainIdResponse parses an HTTP response from a PutRoutesRouteIdOrNameFilterChainsFilterChainIdWithResponse call
func ParsePutRoutesRouteIdOrNameFilterChainsFilterChainIdResponse(rsp *http.Response) (*PutRoutesRouteIdOrNameFilterChainsFilterChainIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutRoutesRouteIdOrNameFilterChainsFilterChainIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListPluginsForRouteResponse parses an HTTP response from a ListPluginsForRouteWithResponse call
func ParseListPluginsForRouteResponse(rsp *http.Response) (*ListPluginsForRouteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPluginsForRouteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPluginsForRoute200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreatePluginForRouteResponse parses an HTTP response from a CreatePluginForRouteWithResponse call
func ParseCreatePluginForRouteResponse(rsp *http.Response) (*CreatePluginForRouteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePluginForRouteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Plugin
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeletePluginForRouteResponse parses an HTTP response from a DeletePluginForRouteWithResponse call
func ParseDeletePluginForRouteResponse(rsp *http.Response) (*DeletePluginForRouteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePluginForRouteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFetchPluginForRouteResponse parses an HTTP response from a FetchPluginForRouteWithResponse call
func ParseFetchPluginForRouteResponse(rsp *http.Response) (*FetchPluginForRouteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FetchPluginForRouteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Plugin
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdatePluginForRouteResponse parses an HTTP response from a UpdatePluginForRouteWithResponse call
func ParseUpdatePluginForRouteResponse(rsp *http.Response) (*UpdatePluginForRouteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePluginForRouteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Plugin
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpsertPluginForRouteResponse parses an HTTP response from a UpsertPluginForRouteWithResponse call
func ParseUpsertPluginForRouteResponse(rsp *http.Response) (*UpsertPluginForRouteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpsertPluginForRouteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Plugin
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetRoutesRouteIdOrNameFilterChainIdResponse parses an HTTP response from a GetRoutesRouteIdOrNameFilterChainIdWithResponse call
func ParseGetRoutesRouteIdOrNameFilterChainIdResponse(rsp *http.Response) (*GetRoutesRouteIdOrNameFilterChainIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoutesRouteIdOrNameFilterChainIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetSchemasFiltersFilterNameResponse parses an HTTP response from a GetSchemasFiltersFilterNameWithResponse call
func ParseGetSchemasFiltersFilterNameResponse(rsp *http.Response) (*GetSchemasFiltersFilterNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchemasFiltersFilterNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParsePostSchemasPluginsValidateResponse parses an HTTP response from a PostSchemasPluginsValidateWithResponse call
func ParsePostSchemasPluginsValidateResponse(rsp *http.Response) (*PostSchemasPluginsValidateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSchemasPluginsValidateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostSchemasPluginsValidate200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetSchemasPluginsPluginNameResponse parses an HTTP response from a GetSchemasPluginsPluginNameWithResponse call
func ParseGetSchemasPluginsPluginNameResponse(rsp *http.Response) (*GetSchemasPluginsPluginNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchemasPluginsPluginNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetSchemasVaultsVaultNameResponse parses an HTTP response from a GetSchemasVaultsVaultNameWithResponse call
func ParseGetSchemasVaultsVaultNameResponse(rsp *http.Response) (*GetSchemasVaultsVaultNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchemasVaultsVaultNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Vault
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParsePostSchemasVaultsValidateResponse parses an HTTP response from a PostSchemasVaultsValidateWithResponse call
func ParsePostSchemasVaultsValidateResponse(rsp *http.Response) (*PostSchemasVaultsValidateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSchemasVaultsValidateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostSchemasVaultsValidate200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSchemasEntityResponse parses an HTTP response from a GetSchemasEntityWithResponse call
func ParseGetSchemasEntityResponse(rsp *http.Response) (*GetSchemasEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchemasEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetSchemasEntity200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParsePostSchemasEntityValidateResponse parses an HTTP response from a PostSchemasEntityValidateWithResponse call
func ParsePostSchemasEntityValidateResponse(rsp *http.Response) (*PostSchemasEntityValidateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSchemasEntityValidateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostSchemasEntityValidate200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListServiceResponse parses an HTTP response from a ListServiceWithResponse call
func ParseListServiceResponse(rsp *http.Response) (*ListServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseCreateServiceResponse parses an HTTP response from a CreateServiceWithResponse call
func ParseCreateServiceResponse(rsp *http.Response) (*CreateServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteServiceResponse parses an HTTP response from a DeleteServiceWithResponse call
func ParseDeleteServiceResponse(rsp *http.Response) (*DeleteServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetServiceResponse parses an HTTP response from a GetServiceWithResponse call
func ParseGetServiceResponse(rsp *http.Response) (*GetServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateServiceResponse parses an HTTP response from a UpdateServiceWithResponse call
func ParseUpdateServiceResponse(rsp *http.Response) (*UpdateServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpsertServiceResponse parses an HTTP response from a UpsertServiceWithResponse call
func ParseUpsertServiceResponse(rsp *http.Response) (*UpsertServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpsertServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetServiceIdOrNameFilterChainsResponse parses an HTTP response from a GetServiceIdOrNameFilterChainsWithResponse call
func ParseGetServiceIdOrNameFilterChainsResponse(rsp *http.Response) (*GetServiceIdOrNameFilterChainsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceIdOrNameFilterChainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FilterChains
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetServicesServiceIdOrNameFilterChainsResponse parses an HTTP response from a GetServicesServiceIdOrNameFilterChainsWithResponse call
func ParseGetServicesServiceIdOrNameFilterChainsResponse(rsp *http.Response) (*GetServicesServiceIdOrNameFilterChainsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServicesServiceIdOrNameFilterChainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest FilterChains
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteServicesServiceIdOrNameFilterChainsFilterChainIdResponse parses an HTTP response from a DeleteServicesServiceIdOrNameFilterChainsFilterChainIdWithResponse call
func ParseDeleteServicesServiceIdOrNameFilterChainsFilterChainIdResponse(rsp *http.Response) (*DeleteServicesServiceIdOrNameFilterChainsFilterChainIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServicesServiceIdOrNameFilterChainsFilterChainIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeletePluginForAServiceResponse parses an HTTP response from a DeletePluginForAServiceWithResponse call
func ParseDeletePluginForAServiceResponse(rsp *http.Response) (*DeletePluginForAServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePluginForAServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFetchPluginWithAServiceResponse parses an HTTP response from a FetchPluginWithAServiceWithResponse call
func ParseFetchPluginWithAServiceResponse(rsp *http.Response) (*FetchPluginWithAServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FetchPluginWithAServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Plugin
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdatePluginForAServiceResponse parses an HTTP response from a UpdatePluginForAServiceWithResponse call
func ParseUpdatePluginForAServiceResponse(rsp *http.Response) (*UpdatePluginForAServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePluginForAServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Plugin
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpsertPluginForAServiceResponse parses an HTTP response from a UpsertPluginForAServiceWithResponse call
func ParseUpsertPluginForAServiceResponse(rsp *http.Response) (*UpsertPluginForAServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpsertPluginForAServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Plugin
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListRoutesForServiceResponse parses an HTTP response from a ListRoutesForServiceWithResponse call
func ParseListRoutesForServiceResponse(rsp *http.Response) (*ListRoutesForServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRoutesForServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListRoute200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateRouteForServiceResponse parses an HTTP response from a CreateRouteForServiceWithResponse call
func ParseCreateRouteForServiceResponse(rsp *http.Response) (*CreateRouteForServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRouteForServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Route
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteRouteForServiceResponse parses an HTTP response from a DeleteRouteForServiceWithResponse call
func ParseDeleteRouteForServiceResponse(rsp *http.Response) (*DeleteRouteForServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRouteForServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFetchRouteForServiceResponse parses an HTTP response from a FetchRouteForServiceWithResponse call
func ParseFetchRouteForServiceResponse(rsp *http.Response) (*FetchRouteForServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FetchRouteForServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Route
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateRouteForServiceResponse parses an HTTP response from a UpdateRouteForServiceWithResponse call
func ParseUpdateRouteForServiceResponse(rsp *http.Response) (*UpdateRouteForServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRouteForServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Route
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpsertRouteForServiceResponse parses an HTTP response from a UpsertRouteForServiceWithResponse call
func ParseUpsertRouteForServiceResponse(rsp *http.Response) (*UpsertRouteForServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpsertRouteForServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Route
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetPluginsForServiceResponse parses an HTTP response from a GetPluginsForServiceWithResponse call
func ParseGetPluginsForServiceResponse(rsp *http.Response) (*GetPluginsForServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPluginsForServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPluginsForRoute200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreatePluginForServiceResponse parses an HTTP response from a CreatePluginForServiceWithResponse call
func ParseCreatePluginForServiceResponse(rsp *http.Response) (*CreatePluginForServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePluginForServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Plugin
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListSniResponse parses an HTTP response from a ListSniWithResponse call
func ParseListSniResponse(rsp *http.Response) (*ListSniResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSniResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetSniWithCertificate200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateSniResponse parses an HTTP response from a CreateSniWithResponse call
func ParseCreateSniResponse(rsp *http.Response) (*CreateSniResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSniResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetSniWithCertificate200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteSniResponse parses an HTTP response from a DeleteSniWithResponse call
func ParseDeleteSniResponse(rsp *http.Response) (*DeleteSniResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSniResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetSniResponse parses an HTTP response from a GetSniWithResponse call
func ParseGetSniResponse(rsp *http.Response) (*GetSniResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSniResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetSniWithCertificate200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateSniResponse parses an HTTP response from a UpdateSniWithResponse call
func ParseUpdateSniResponse(rsp *http.Response) (*UpdateSniResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSniResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetSniWithCertificate200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpsertSniResponse parses an HTTP response from a UpsertSniWithResponse call
func ParseUpsertSniResponse(rsp *http.Response) (*UpsertSniResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpsertSniResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetSniWithCertificate200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetStatusResponse parses an HTTP response from a GetStatusWithResponse call
func ParseGetStatusResponse(rsp *http.Response) (*GetStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetStatus200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetDnsStatusResponse parses an HTTP response from a GetDnsStatusWithResponse call
func ParseGetDnsStatusResponse(rsp *http.Response) (*GetDnsStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDnsStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetDnsStatus200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest GetDnsStatus501Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetTagsResponse parses an HTTP response from a GetTagsWithResponse call
func ParseGetTagsResponse(rsp *http.Response) (*GetTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetTags200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetTagsTagsResponse parses an HTTP response from a GetTagsTagsWithResponse call
func ParseGetTagsTagsResponse(rsp *http.Response) (*GetTagsTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTagsTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetTags200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetTimersResponse parses an HTTP response from a GetTimersWithResponse call
func ParseGetTimersResponse(rsp *http.Response) (*GetTimersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTimersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetTimers200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListUpstreamResponse parses an HTTP response from a ListUpstreamWithResponse call
func ParseListUpstreamResponse(rsp *http.Response) (*ListUpstreamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUpstreamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListUpstream200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateUpstreamResponse parses an HTTP response from a CreateUpstreamWithResponse call
func ParseCreateUpstreamResponse(rsp *http.Response) (*CreateUpstreamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUpstreamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Upstream
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteUpstreamResponse parses an HTTP response from a DeleteUpstreamWithResponse call
func ParseDeleteUpstreamResponse(rsp *http.Response) (*DeleteUpstreamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUpstreamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetUpstreamResponse parses an HTTP response from a GetUpstreamWithResponse call
func ParseGetUpstreamResponse(rsp *http.Response) (*GetUpstreamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUpstreamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Upstream
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateUpstreamResponse parses an HTTP response from a UpdateUpstreamWithResponse call
func ParseUpdateUpstreamResponse(rsp *http.Response) (*UpdateUpstreamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUpstreamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Upstream
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpsertUpstreamResponse parses an HTTP response from a UpsertUpstreamWithResponse call
func ParseUpsertUpstreamResponse(rsp *http.Response) (*UpsertUpstreamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpsertUpstreamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Upstream
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListTargetsForUpstreamResponse parses an HTTP response from a ListTargetsForUpstreamWithResponse call
func ParseListTargetsForUpstreamResponse(rsp *http.Response) (*ListTargetsForUpstreamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTargetsForUpstreamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListTargetsForUpstream200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateTargetForUpstreamResponse parses an HTTP response from a CreateTargetForUpstreamWithResponse call
func ParseCreateTargetForUpstreamResponse(rsp *http.Response) (*CreateTargetForUpstreamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTargetForUpstreamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Target
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteUpstreamTargetResponse parses an HTTP response from a DeleteUpstreamTargetWithResponse call
func ParseDeleteUpstreamTargetResponse(rsp *http.Response) (*DeleteUpstreamTargetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUpstreamTargetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFetchTargetForUpstreamResponse parses an HTTP response from a FetchTargetForUpstreamWithResponse call
func ParseFetchTargetForUpstreamResponse(rsp *http.Response) (*FetchTargetForUpstreamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FetchTargetForUpstreamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Target
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateTargetForUpstreamResponse parses an HTTP response from a UpdateTargetForUpstreamWithResponse call
func ParseUpdateTargetForUpstreamResponse(rsp *http.Response) (*UpdateTargetForUpstreamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTargetForUpstreamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Target
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpsertTargetForUpstreamResponse parses an HTTP response from a UpsertTargetForUpstreamWithResponse call
func ParseUpsertTargetForUpstreamResponse(rsp *http.Response) (*UpsertTargetForUpstreamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpsertTargetForUpstreamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Target
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListVaultResponse parses an HTTP response from a ListVaultWithResponse call
func ParseListVaultResponse(rsp *http.Response) (*ListVaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListVault200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateVaultResponse parses an HTTP response from a CreateVaultWithResponse call
func ParseCreateVaultResponse(rsp *http.Response) (*CreateVaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Vault
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteVaultResponse parses an HTTP response from a DeleteVaultWithResponse call
func ParseDeleteVaultResponse(rsp *http.Response) (*DeleteVaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetVaultResponse parses an HTTP response from a GetVaultWithResponse call
func ParseGetVaultResponse(rsp *http.Response) (*GetVaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Vault
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateVaultResponse parses an HTTP response from a UpdateVaultWithResponse call
func ParseUpdateVaultResponse(rsp *http.Response) (*UpdateVaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Vault
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpsertVaultResponse parses an HTTP response from a UpsertVaultWithResponse call
func ParseUpsertVaultResponse(rsp *http.Response) (*UpsertVaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpsertVaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Vault
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseHeadEndpointsResponse parses an HTTP response from a HeadEndpointsWithResponse call
func ParseHeadEndpointsResponse(rsp *http.Response) (*HeadEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HeadEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseOptionsEndpointResponse parses an HTTP response from a OptionsEndpointWithResponse call
func ParseOptionsEndpointResponse(rsp *http.Response) (*OptionsEndpointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OptionsEndpointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}
